import { Transaction, VersionedTransaction, CompileV0Args, TransactionInstruction, Keypair, Connection, SendOptions, PublicKey, AddressLookupTableAccount } from '@solana/web3.js';
import { TransactionResult, Transaction as Transaction$1 } from '@mysten/sui/transactions';
import { Buffer } from 'buffer';
import { TransactionRequest, Signer, Overrides, TransactionResponse, ethers, JsonRpcProvider } from 'ethers';
import { SuiClient, CoinStruct } from '@mysten/sui/client';

type ChainName = 'solana' | 'ethereum' | 'bsc' | 'polygon' | 'avalanche' | 'arbitrum' | 'optimism' | 'base' | 'aptos' | 'sui' | 'unichain' | 'linea' | 'hypercore' | 'sonic' | 'hyperevm' | 'fogo' | 'ton' | 'monad';
type TokenStandard = 'native' | 'erc20' | 'spl' | 'spl2022' | 'suicoin' | 'hypertoken';
type Token = {
    name: string;
    symbol: string;
    mint: string;
    contract: string;
    chainId: number;
    wChainId: number;
    decimals: number;
    logoURI: string;
    coingeckoId: string;
    realOriginChainId?: number;
    realOriginContractAddress?: string;
    supportsPermit?: boolean;
    verified: boolean;
    standard: TokenStandard;
    verifiedAddress?: string;
};
type QuoteParams = {
    /**
     * @deprecated to avoid precision issues, use {@link amountIn64} instead
     */
    amount?: number;
    amountIn64?: string;
    fromToken: string;
    fromChain: ChainName;
    toToken: string;
    toChain: ChainName;
    /**
     * @deprecated Use the new property {@link slippageBps} instead
     */
    slippage?: number;
    /**
     * Slippage in basis points.
     * One basis point (bps) = 0.01%.
     *
     * - A value of `50` means a slippage of 0.5%.
     * - A value of `100` means a slippage of 1%.
     * - If set to `'auto'`, the system will automatically determine slippage.
     *
     * @example
     * slippageBps: 50 // 0.5% slippage
     */
    slippageBps: 'auto' | number;
    gasDrop?: number;
    referrer?: string;
    referrerBps?: number;
    destinationAddress?: string;
};
type QuoteError = {
    message: string;
    code: number;
    data: any;
};
type QuoteType = 'WH' | 'SWIFT' | 'MCTP' | 'SHUTTLE' | 'FAST_MCTP' | 'MONO_CHAIN';
type Quote = {
    type: QuoteType;
    /**
     * @deprecated Use the new property {@link effectiveAmountIn64} instead
     */
    effectiveAmountIn: number;
    effectiveAmountIn64: string;
    expectedAmountOut: number;
    priceImpact?: number | null;
    minAmountOut: number;
    minReceived: number;
    gasDrop: number;
    price: number;
    swapRelayerFee: number;
    redeemRelayerFee: number;
    refundRelayerFee: number;
    solanaRelayerFee: number;
    swapRelayerFee64?: string | null;
    redeemRelayerFee64?: string | null;
    refundRelayerFee64?: string | null;
    cancelRelayerFee64: string | null;
    submitRelayerFee64: string | null;
    solanaRelayerFee64: string;
    clientRelayerFeeSuccess: number | null;
    clientRelayerFeeRefund: number | null;
    eta: number;
    etaSeconds: number;
    clientEta: string;
    fromToken: Token;
    toToken: Token;
    fromChain: ChainName;
    toChain: ChainName;
    slippageBps: number;
    priceStat: {
        ratio: number;
        status: 'GOOD' | 'NORMAL' | 'BAD';
    };
    mintDecimals?: {
        from: number;
        to: number;
    } | null;
    bridgeFee: number;
    suggestedPriorityFee: number;
    meta: {
        icon: string;
        title: string;
        advertisedTitle: string;
        advertisedDescription: string;
        switchText: string;
    };
    onlyBridging: boolean;
    deadline64: string;
    referrerBps?: number;
    protocolBps?: number;
    whMayanContract: string;
    cheaperChain: ChainName;
    mctpInputContract: string;
    mctpOutputContract: string;
    hasAuction: boolean;
    minMiddleAmount?: number;
    evmSwapRouterAddress?: string;
    evmSwapRouterCalldata?: string;
    mctpMayanContract?: string;
    swiftMayanContract?: string;
    shuttleContract?: string;
    swiftAuctionMode?: number;
    swiftInputContract: string;
    swiftInputDecimals: number;
    gasless: boolean;
    relayer: string;
    sendTransactionCost: number;
    maxUserGasDrop: number;
    rentCost?: string;
    shuttleParams: {
        maxLLFee: string;
        maxRelayingFee: string;
        fastTransferDeadline: number;
        hasDestSwap: boolean;
        path: string;
    };
    shuttleInputContract: string;
    shuttleInputDecimals: number;
    mctpVerifiedInputAddress: string;
    mctpInputTreasury: string;
    circleMaxFee64: string;
    fastMctpMayanContract: string;
    fastMctpInputContract: string;
    fastMctpMinFinality: number;
    hyperCoreParams?: {
        depositAmountUSDC64: string;
        bridgeAmountUSDC64: string;
        initiateTokenContract: string;
        initiateContractAddress?: string;
        failureGasDrop: number;
    };
    monoChainMayanContract: string;
    swiftInputContractStandard: TokenStandard;
    swiftVerifiedInputAddress: string;
    swiftVersion: 'V1' | 'V2';
    quoteId: string;
    expectedAmountOutBaseUnits: string;
    minReceivedBaseUnits: string;
};
type QuoteOptions = {
    wormhole?: boolean;
    swift?: boolean;
    mctp?: boolean;
    shuttle?: boolean;
    fastMctp?: boolean;
    gasless?: boolean;
    onlyDirect?: boolean;
    fullList?: boolean;
    payload?: string;
    monoChain?: boolean;
};
type SolanaTransactionSigner = {
    (trx: Transaction): Promise<Transaction>;
    (trx: VersionedTransaction): Promise<VersionedTransaction>;
};
type Erc20Permit = {
    value: bigint;
    deadline: number;
    v: number;
    r: string;
    s: string;
};
type BaseGetSolanaSwapParams = {
    amountIn64: string;
    fromToken: string;
    minMiddleAmount: number;
    middleToken: string;
    userWallet: string;
    slippageBps: number;
    referrerAddress?: string | null;
    fillMaxAccounts?: boolean;
    tpmTokenAccount?: string | null;
    chainName: ChainName;
};
type MctpGetSolanaSwapParams = BaseGetSolanaSwapParams & {
    userLedger: string;
    depositMode: 'WITH_FEE' | 'LOCK_FEE' | 'SWAP';
};
type SwiftGetSolanaSwapParams = BaseGetSolanaSwapParams & {
    depositMode: 'SWIFT' | 'SWIFT_GASLESS';
    userLedger: string;
};
type HCDepositUSDCGetSolanaSwapParams = BaseGetSolanaSwapParams & {
    tpmTokenAccount: string;
    depositMode: 'HC_USDC';
    userLedger: string;
    quoteType: 'MCTP' | 'FAST_MCTP';
};
type MonoChainGetSolanaSwapParams = Omit<BaseGetSolanaSwapParams, 'minMiddleAmount' | 'fillMaxAccounts' | 'tpmTokenAccount'> & {
    destinationWallet: string;
    expectedAmountOut64: string;
    depositMode: 'MONO_CHAIN';
    referrerBps: number;
};
type FastMctpGetSolanaSwapParams = BaseGetSolanaSwapParams & {
    userLedger: string;
    depositMode: 'FAST_MCTP_BRIDGE' | 'FAST_MCTP_ORDER';
};
type GetSolanaSwapParams = MctpGetSolanaSwapParams | SwiftGetSolanaSwapParams | HCDepositUSDCGetSolanaSwapParams | MonoChainGetSolanaSwapParams | FastMctpGetSolanaSwapParams;
type BaseGetSuiSwapParams = {
    amountIn64: string;
    inputCoinType: string;
    middleCoinType: string;
    userWallet: string;
    referrerAddress?: string | null;
    inputCoin?: SuiFunctionParameter | null;
    transaction?: string | null;
    chainName: ChainName;
    slippageBps: number;
};
type BaseGetEvmSwapParams = {
    forwarderAddress: string;
    chainName: ChainName;
    amountIn64: string;
    fromToken: string;
    middleToken: string;
    referrerAddress?: string | null;
    slippageBps: number;
};
type GetEvmSwapParams = BaseGetEvmSwapParams;
type MctpGetSuiSwapParams = BaseGetSuiSwapParams & {
    withWhFee: boolean;
};
type GetSuiSwapParams = MctpGetSuiSwapParams;
type SolanaKeyInfo = {
    pubkey: string;
    isWritable: boolean;
    isSigner: boolean;
};
type InstructionInfo = {
    accounts: SolanaKeyInfo[];
    data: string;
    programId: string;
};
type SolanaClientSwap = {
    computeBudgetInstructions?: InstructionInfo[];
    setupInstructions?: InstructionInfo[];
    swapInstruction: InstructionInfo;
    cleanupInstruction: InstructionInfo;
    addressLookupTableAddresses: string[];
    maxAccountsFilled: boolean;
};
type SuiFunctionNestedResult = {
    $kind: 'NestedResult';
    NestedResult: [number, number];
};
type SuiFunctionParameter = {
    result: TransactionResult | SuiFunctionNestedResult | {
        $kind: 'Input';
        Input: number;
        type?: 'object';
    };
    objectId?: undefined | null;
} | {
    result?: undefined | null;
    objectId: string;
};
type SuiClientSwap = {
    tx: string;
    outCoin: TransactionResult;
    whFeeCoin?: TransactionResult | SuiFunctionNestedResult;
};
type ReferrerAddresses = {
    solana?: string | null;
    evm?: string | null;
    sui?: string | null;
};
type SwiftEvmOrderTypedData = {
    domain: {
        name: "Mayan Swift";
        chainId: number;
        verifyingContract: string;
    };
    types: {
        CreateOrder: [
            {
                name: 'OrderId';
                type: 'bytes32';
            },
            {
                name: 'InputAmount';
                type: 'uint256';
            },
            {
                name: 'SubmissionFee';
                type: 'uint256';
            }
        ];
    };
    value: {
        OrderId: string;
        InputAmount: bigint;
        SubmissionFee: bigint;
    };
};
type EvmForwarderParams = {
    method: string;
    params: any[];
};
type JitoBundleOptions = {
    tipLamports: number;
    signAllTransactions: <T extends Transaction | VersionedTransaction>(transactions: T[]) => Promise<T[]>;
    jitoAccount?: string;
    jitoSendUrl?: string;
    separateSwapTx?: boolean;
};
type ComposableSuiMoveCallsOptions = {
    builtTransaction?: Transaction$1 | null;
    inputCoin?: SuiFunctionParameter | null;
    whFeeCoin?: SuiFunctionParameter | null;
    usdcPermitSignature?: string | null;
};
type SwapMessageV0Params = {
    messageV0: Omit<CompileV0Args, 'recentBlockhash'>;
    createTmpTokenAccountIxs: TransactionInstruction[];
    tmpTokenAccount: Keypair;
};
type PermitDomain = {
    name: string;
    version: string;
    verifyingContract: string;
    chainId?: number;
    salt?: string;
};
type PermitValue = {
    owner: string;
    spender: string;
    value: string;
    nonce: string;
    deadline: string;
};
type SolanaBridgeOptions = {
    allowSwapperOffCurve?: boolean;
    forceSkipCctpInstructions?: boolean;
    separateSwapTx?: boolean;
    usdcPermitSignature?: string | null;
    skipProxyMayanInstructions?: boolean;
    customPayload?: Buffer | Uint8Array | null;
};
type EstimateGasEvmParams = {
    from: string;
    tokenIn: string;
    value: string;
    to: string;
    data: string;
    chainId: number;
};

type SwiftOrderParams = {
    payloadType: number;
    trader: string;
    tokenOut: string;
    minAmountOut: bigint;
    gasDrop: bigint;
    cancelFee: bigint;
    refundFee: bigint;
    deadline: bigint;
    destAddr: string;
    destChainId: number;
    referrerAddr: string;
    referrerBps: number;
    auctionMode: number;
    random: string;
};
type EvmSwiftParams = {
    contractAddress: string;
    tokenIn: string;
    amountIn: bigint;
    order: SwiftOrderParams;
    customPayload: string;
};
declare function getEvmSwiftParams(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, signerChainId: string | number, customPayload: Buffer | Uint8Array | null | undefined): EvmSwiftParams;
declare function getSwiftFromEvmTxPayload(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, signerChainId: number | string, permit: Erc20Permit | null | undefined, customPayload: Buffer | Uint8Array | null | undefined): Promise<TransactionRequest & {
    _forwarder: EvmForwarderParams;
}>;
declare function getSwiftOrderTypeData(quote: Quote, orderHash: string, signerChainId: number | string): SwiftEvmOrderTypedData;
type SwiftEvmGasLessParams = {
    swiftVersion: string;
    permitParams: Erc20Permit | null | undefined;
    orderHash: string;
    orderParams: {
        trader: string;
        sourceChainId: number;
        tokenIn: string;
        amountIn: bigint;
        destAddr: string;
        destChainId: number;
        tokenOut: string;
        minAmountOut: bigint;
        gasDrop: bigint;
        cancelFee: bigint;
        refundFee: bigint;
        deadline: bigint;
        referrerAddr: string;
        referrerBps: number;
        auctionMode: number;
        random: string;
        submissionFee: bigint;
    };
    customPayload: string;
    orderTypedData: SwiftEvmOrderTypedData;
};
declare function getSwiftFromEvmGasLessParams(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, signerChainId: number | string, permit: Erc20Permit | null | undefined, customPayload: Buffer | Uint8Array | null | undefined): SwiftEvmGasLessParams;

declare function fetchAllTokenList(tokenStandards?: TokenStandard[]): Promise<{
    [index: string]: Token[];
}>;
declare function fetchTokenList(chain: ChainName, nonPortal?: boolean, tokenStandards?: TokenStandard[]): Promise<Token[]>;
declare function generateFetchQuoteUrl(params: QuoteParams, quoteOptions?: QuoteOptions): string;
declare function fetchQuote(params: QuoteParams, quoteOptions?: QuoteOptions): Promise<Quote[]>;
declare function getCurrentChainTime(chain: ChainName): Promise<number>;
declare function getSuggestedRelayer(): Promise<string>;
declare function getSwapSolana(params: GetSolanaSwapParams): Promise<SolanaClientSwap>;
declare function getSwapSui(params: GetSuiSwapParams): Promise<SuiClientSwap>;
declare function getSwapEvm(params: GetEvmSwapParams): Promise<{
    swapRouterAddress: string;
    swapRouterCalldata: string;
}>;
declare function submitSwiftEvmSwap(params: SwiftEvmGasLessParams, signature: string): Promise<void>;
declare function submitSwiftSolanaSwap(signedTx: string, chainName: ChainName): Promise<{
    orderHash: string;
}>;
declare function checkHyperCoreDeposit(destinationAddress: string, tokenAddress: string): Promise<boolean>;
declare function getEstimateGasEvm(params: EstimateGasEvmParams): Promise<{
    estimatedGas: bigint;
    gasPrice: bigint;
}>;
declare function getSvmDurableNonce(chainName: ChainName, swapperAddress: string): Promise<{
    nonce: string;
    publicKey: string;
}>;

type ContractRelayerFees = {
    swapFee: bigint;
    redeemFee: bigint;
    refundFee: bigint;
};
type Criteria = {
    transferDeadline: bigint;
    swapDeadline: bigint;
    amountOutMin: bigint;
    gasDrop: bigint;
    unwrap: boolean;
    customPayload: string;
};
type Recipient = {
    mayanAddr: string;
    auctionAddr: string;
    referrer: string;
    destAddr: string;
    mayanChainId: number;
    destChainId: number;
    refundAddr: string;
};
type EvmSwapParams = {
    contractAddress: string;
    relayerFees: ContractRelayerFees;
    recipient: Recipient;
    tokenOut: string;
    tokenOutWChainId: number;
    criteria: Criteria;
    tokenIn: string;
    amountIn: bigint;
    bridgeFee: bigint;
};
declare function getSwapFromEvmTxPayload(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddresses: ReferrerAddresses | null | undefined, signerAddress: string, signerChainId: number | string, payload: Uint8Array | Buffer | null | undefined, permit: Erc20Permit | null | undefined, options?: {
    usdcPermitSignature?: string;
}): Promise<TransactionRequest & {
    _forwarder: EvmForwarderParams;
}>;
declare function swapFromEvm(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddresses: ReferrerAddresses | null | undefined, signer: Signer, permit: Erc20Permit | null | undefined, overrides: Overrides | null | undefined, payload: Uint8Array | Buffer | null | undefined, options?: {
    usdcPermitSignature?: string;
}): Promise<TransactionResponse | string>;
declare function estimateQuoteRequiredGas(quote: Quote, swapperAddress: string, signer: Signer, permit: Erc20Permit | null | undefined, payload: Uint8Array | Buffer | null | undefined): Promise<bigint>;
declare function estimateQuoteRequiredGasAprox(quote: Quote, provider: ethers.JsonRpcProvider, permit: Erc20Permit | null | undefined, payload: Uint8Array | Buffer | null | undefined): Promise<bigint>;
declare function estimateQuoteRequiredGasAprox2(quote: Quote, payload: Uint8Array | Buffer | null | undefined): Promise<{
    estimateGas: bigint;
    gasPrice: bigint;
    requiredNative: bigint;
}>;

declare function getMctpFromEvmTxPayload(quote: Quote, destinationAddress: string, referrerAddress: string | null | undefined, signerChainId: number | string, permit: Erc20Permit | null | undefined, payload: Uint8Array | Buffer | null | undefined): Promise<TransactionRequest & {
    _forwarder: EvmForwarderParams;
}>;

declare function getHyperCoreDepositFromEvmTxPayload(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, signerChainId: number | string, permit: Erc20Permit | null | undefined, payload: Uint8Array | Buffer | null | undefined, options?: {
    usdcPermitSignature?: string;
}): Promise<TransactionRequest & {
    _forwarder: EvmForwarderParams;
}>;

declare function getMonoChainFromEvmTxPayload(quote: Quote, destinationAddress: string, referrerAddress: string | null | undefined, signerChainId: number | string, permit: Erc20Permit | null | undefined): TransactionRequest & {
    _forwarder: EvmForwarderParams;
};

declare function getFastMctpFromEvmTxPayload(quote: Quote, destinationAddress: string, referrerAddress: string | null | undefined, signerChainId: number | string, permit: Erc20Permit | null | undefined, payload: Uint8Array | Buffer | null | undefined): Promise<TransactionRequest & {
    _forwarder: EvmForwarderParams;
}>;

declare function submitTransactionWithRetry({ trx, connection, errorChance, extraRpcs, options, rate, }: {
    trx: Uint8Array;
    connection: Connection;
    errorChance: number;
    extraRpcs: string[];
    options?: SendOptions;
    rate?: number;
}): Promise<{
    signature: string;
    serializedTrx: Uint8Array;
}>;
declare function createAssociatedTokenAccountInstruction(payer: PublicKey, associatedToken: PublicKey, owner: PublicKey, mint: PublicKey, programId?: PublicKey, associatedTokenProgramId?: PublicKey): TransactionInstruction;
declare function createInitializeRandomTokenAccountInstructions(connection: Connection, payer: PublicKey, mint: PublicKey, owner: PublicKey, keyPair: Keypair, programId?: PublicKey): Promise<TransactionInstruction[]>;
declare function createApproveInstruction(account: PublicKey, delegate: PublicKey, owner: PublicKey, amount: bigint, programId?: PublicKey): TransactionInstruction;
declare function createSyncNativeInstruction(account: PublicKey): TransactionInstruction;
declare function createCloseAccountInstruction(account: PublicKey, destination: PublicKey, owner: PublicKey, programId?: PublicKey): TransactionInstruction;
declare function createSplTransferInstruction(source: PublicKey, destination: PublicKey, owner: PublicKey, amount: bigint, programId?: PublicKey): TransactionInstruction;
declare const solMint: PublicKey;
declare function wrapSol(owner: PublicKey, amount: number, signTransaction: SolanaTransactionSigner, connection?: Connection): Promise<{
    signature: string;
    serializedTrx: Uint8Array;
}>;
declare function unwrapSol(owner: PublicKey, amount: number, signTransaction: SolanaTransactionSigner, connection?: Connection): Promise<{
    signature: string;
    serializedTrx: Uint8Array;
}>;
declare function deserializeInstructionInfo(instruction: InstructionInfo): TransactionInstruction;
declare function getAddressLookupTableAccounts(keys: string[], connection: Connection): Promise<AddressLookupTableAccount[]>;
type SolanaClientSwapInstructions = {
    swapInstruction: TransactionInstruction;
    cleanupInstruction?: TransactionInstruction | null;
    computeBudgetInstructions: TransactionInstruction[];
    setupInstructions: TransactionInstruction[];
    addressLookupTableAddresses: string[];
};
declare function decentralizeClientSwapInstructions(params: SolanaClientSwap, connection: Connection, relayer?: PublicKey): SolanaClientSwapInstructions;
declare function getAnchorInstructionData(name: string): Buffer;
declare function decideRelayer(): Promise<PublicKey>;
declare function getJitoTipTransfer(swapper: string, blockhash: string, lastValidBlockHeight: number, options: JitoBundleOptions): Transaction;
declare function sendJitoBundle(singedTrxs: Array<Transaction | VersionedTransaction>, options: JitoBundleOptions, forceToBeSubmitted?: boolean): Promise<any>;
declare function confirmJitoBundleId(bundleId: string, options: JitoBundleOptions, lastValidBlockHeight: number, mayanTxSignature: string, connection: Connection): Promise<void>;
declare function broadcastJitoBundleId(bundleId: string): Promise<void>;
declare function validateJupSwapInstructionData(instruction: TransactionInstruction, quote: Quote): void;
declare function validateJupSwap(swap: SolanaClientSwapInstructions, validDestAccount: PublicKey, validWrapOwner?: PublicKey, validCleanReceiverAddress?: PublicKey, sameSourceAndDestWallet?: boolean): void;
declare function createTransferAllAndCloseInstruction(owner: PublicKey, mint: PublicKey, tokenAccount: PublicKey, transferDestination: PublicKey, closeDestination: PublicKey, tokenProgramId?: PublicKey): TransactionInstruction;
declare function createPayloadWriterCreateInstruction(payer: PublicKey, payloadAccount: PublicKey, payload: Buffer, nonce: number): TransactionInstruction;
declare function createPayloadWriterCloseInstruction(payer: PublicKey, payloadAccount: PublicKey, nonce: number): TransactionInstruction;
declare function sandwichInstructionInCpiProxy(instruction: TransactionInstruction, skipProxy?: boolean): TransactionInstruction;
declare function getLookupTableAddress(chainName: ChainName): string;

declare function createSwapFromSolanaInstructions(quote: Quote, swapperWalletAddress: string, destinationAddress: string, referrerAddresses: ReferrerAddresses | null | undefined, connection: Connection, options?: SolanaBridgeOptions): Promise<{
    instructions: Array<TransactionInstruction>;
    signers: Array<Keypair>;
    lookupTables: Array<AddressLookupTableAccount>;
    swapMessageV0Params: SwapMessageV0Params | null;
}>;
declare function swapFromSolana(quote: Quote, swapperWalletAddress: string, destinationAddress: string, referrerAddresses: ReferrerAddresses | null | undefined, signTransaction: SolanaTransactionSigner, connection: Connection, extraRpcs?: string[], sendOptions?: SendOptions, jitoOptions?: JitoBundleOptions, instructionOptions?: {
    allowSwapperOffCurve?: boolean;
    forceSkipCctpInstructions?: boolean;
    usdcPermitSignature?: string | null;
    skipProxyMayanInstructions?: boolean;
    customPayload?: Buffer | Uint8Array | null;
}): Promise<{
    signature: string;
    serializedTrx: Uint8Array | null;
}>;

declare function createMctpBridgeWithFeeInstruction(ledger: PublicKey, toChain: ChainName, mintAddress: string, relayerAddress: string, feeSolana: bigint, fromChain: ChainName): {
    instruction: TransactionInstruction;
    signers: Keypair[];
};
type CreateMctpBridgeLedgerInstructionParams = {
    ledger: PublicKey;
    swapperAddress: string;
    mintAddress: string;
    randomKey: PublicKey;
    toChain: ChainName;
    destinationAddress: string;
    feeSolana: bigint;
    feeRedeem: number;
    gasDrop: number;
    amountInMin64: bigint;
    referrerAddress?: string | null | undefined;
    mode: 'WITH_FEE' | 'LOCK_FEE';
    customPayload?: PublicKey | null;
    relayerAddress: string;
};
declare function createMctpBridgeLedgerInstruction(params: CreateMctpBridgeLedgerInstructionParams): TransactionInstruction;
declare function createMctpFromSolanaInstructions(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, connection: Connection, options?: {
    allowSwapperOffCurve?: boolean;
    forceSkipCctpInstructions?: boolean;
    separateSwapTx?: boolean;
    skipProxyMayanInstructions?: boolean;
    customPayload?: Buffer | Uint8Array | null;
}): Promise<{
    instructions: TransactionInstruction[];
    signers: Keypair[];
    lookupTables: AddressLookupTableAccount[];
    swapMessageV0Params: SwapMessageV0Params | null;
}>;

declare function createSwiftOrderHash(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, randomKeyHex: string, customPayload: undefined | null | Uint8Array | Buffer): Buffer;
declare function createSwiftFromSolanaInstructions(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, connection: Connection, options?: {
    allowSwapperOffCurve?: boolean;
    separateSwapTx?: boolean;
    skipProxyMayanInstructions?: boolean;
}, customPayload?: Buffer | Uint8Array | null, customPayloadAccount?: string | null): Promise<{
    instructions: TransactionInstruction[];
    signers: Keypair[];
    lookupTables: AddressLookupTableAccount[];
    swapMessageV0Params: SwapMessageV0Params | null;
}>;

declare function createHyperCoreDepositFromSolanaInstructions(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, connection: Connection, options?: SolanaBridgeOptions): Promise<{
    instructions: TransactionInstruction[];
    signers: Keypair[];
    lookupTables: AddressLookupTableAccount[];
    swapMessageV0Params: SwapMessageV0Params | null;
}>;

declare function createMonoChainFromSolanaInstructions(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, connection: Connection, options?: {
    allowSwapperOffCurve?: boolean;
    separateSwapTx?: boolean;
    skipProxyMayanInstructions?: boolean;
}): Promise<{
    instructions: TransactionInstruction[];
    signers: Keypair[];
    lookupTables: AddressLookupTableAccount[];
    swapMessageV0Params: SwapMessageV0Params | null;
}>;

/**
 * assertArgumentIsImmutable
 *
 * Validates whether a specific argument of a given Move function in a Sui module is immutable.
 * This includes checking if the argument type is either `Pure` or an object passed by immutable reference.
 *
 * @param params - An object containing the following properties:
 *    - package: The Sui package containing the Move module.
 *    - module: The name of the Move module.
 *    - function: The name of the Move function to validate.
 *    - argumentIndex: The index of the argument to check for immutability.
 * @param suiClient - An instance of `SuiClient` used to interact with the Sui blockchain.
 *
 * @throws Will throw an error if:
 *    - The argument types cannot be retrieved from the Sui client.
 *    - The specified argument is not immutable (i.e., not `Pure` or passed as an immutable reference).
 *
 * @returns A Promise that resolves if the specified argument is immutable, or rejects with an error otherwise.
 */
declare function assertArgumentIsImmutable(params: {
    package: string;
    module: string;
    function: string;
    argumentIndex: number;
}, suiClient: SuiClient): Promise<void>;
/**
 * fetchCoinsUntilAmountReachedOrEnd
 *
 * This function is inspired by the `fetchAllCoins` implementation from the
 * Aftermath Finance SDK (reference: https://github.com/AftermathFinance/aftermath-ts-sdk/blob/74087402caf5ebf06f6c639cc5e23445d40a039f/src/packages/coin/api/coinApi.ts#L85).
 *
 * It retrieves a list of coins associated with a specified wallet address and coin type until
 * either the target coin amount is reached or no more coins are available. The function returns
 * an object containing the collected coins and the cumulative sum of their values.
 *
 * @param inputs - An object containing the following properties:
 *    - walletAddress: The address of the wallet to fetch coins from.
 *    - coinType: The type of coin to filter for during retrieval.
 *    - coinAmount: The target coin amount to reach.
 *
 * @param suiClient - An instance of `SuiClient` used to interact with the Sui blockchain.
 *
 * @returns A Promise that resolves to an object containing:
 *    - coins: An array of CoinStruct objects representing the retrieved coins.
 *    - sum: The cumulative value of the retrieved coins.
 */
declare function fetchAllCoins(inputs: {
    walletAddress: string;
    coinType: string;
    coinAmount: bigint;
}, suiClient: SuiClient): Promise<{
    coins: CoinStruct[];
    sum: bigint;
}>;
/**
 * Fetches the latest Mayan Sui package ID from a shared state object on the Sui blockchain.
 *
 * By Mayan standards:
 * - The latest package ID is stored in a shared state object to avoid forced SDK updates during package upgrades.
 * - The shared state object ID is hardcoded in the SDK to ensure security.
 * - Upgrades to Mayan packages require multiple signatures to perform, enhancing governance and security.
 *
 * @param {string} stateObjectId - The ID of the shared state object containing the latest package ID.
 * @param {SuiClient} suiClient - An instance of the SuiClient used to interact with the Sui blockchain.
 * @returns {Promise<string>} - A promise that resolves to the latest Mayan Sui package ID.
 * @throws {Error} - Throws an error if the state object cannot be fetched or if the `latest_package_id` field is not found.
 */
declare function fetchMayanSuiPackageId(stateObjectId: string, suiClient: SuiClient): Promise<string>;
declare function resolveInputCoin(amount: bigint, owner: string, coinType: string, suiClient: SuiClient, tx: Transaction$1, preparedCoin?: SuiFunctionParameter | null): Promise<SuiFunctionNestedResult | TransactionResult | {
    $kind: "Input";
    Input: number;
    type?: "object";
}>;

declare function createMctpFromSuiMoveCalls(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, payload: Uint8Array | Buffer | null | undefined, suiClient: SuiClient, options?: ComposableSuiMoveCallsOptions): Promise<Transaction$1>;
declare function addBridgeWithFeeMoveCalls(quote: Quote, swapperAddress: string, destinationAddress: string, mctpPackageId: string, payload: Uint8Array | Buffer | null | undefined, suiClient: SuiClient, options?: ComposableSuiMoveCallsOptions): Promise<Transaction$1>;
declare function addBridgeLockedFeeMoveCalls(quote: Quote, swapperAddress: string, destinationAddress: string, mctpPackageId: string, suiClient: SuiClient, options?: ComposableSuiMoveCallsOptions): Promise<Transaction$1>;
declare function addInitOrderMoveCalls(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, mctpPackageId: string, feeManagerPackageId: string, suiClient: SuiClient, options?: ComposableSuiMoveCallsOptions): Promise<Transaction$1>;
declare function addBridgeWithFeeMoveCalls2(params: {
    swapperAddress: string;
    destinationAddress: string;
    toChain: ChainName;
    effectiveAmountIn64: string;
    minMiddleAmount?: number | null;
    mctpPackageId: string;
    fromToken: Token;
    mctpInputContract: string;
    gasDrop: number;
    redeemRelayerFee: number;
    mctpVerifiedInputAddress: string;
    mctpInputTreasury: string;
    bridgeFee: number;
    payload: Uint8Array | Buffer | null | undefined;
    suiClient: SuiClient;
    options?: ComposableSuiMoveCallsOptions;
}): Promise<Transaction$1>;

declare function createSwapFromSuiMoveCalls(quote: Quote, swapperWalletAddress: string, destinationAddress: string, referrerAddresses: ReferrerAddresses | null | undefined, payload: Uint8Array | Buffer | null | undefined, suiClient: SuiClient, options?: ComposableSuiMoveCallsOptions): Promise<Transaction$1>;

declare function createHyperCoreDepositFromSuiMoveCalls(quote: Quote, swapperAddress: string, destinationAddress: string, referrerAddress: string | null | undefined, suiClient: SuiClient, options?: ComposableSuiMoveCallsOptions): Promise<Transaction$1>;

declare const isValidAptosType: (str: string) => boolean;
declare function nativeAddressToHexString(address: string, wChainId: number): string;
declare function hexToUint8Array(input: string): Uint8Array;
declare function getAssociatedTokenAddress(mint: PublicKey, owner: PublicKey, allowOwnerOffCurve?: boolean, programId?: PublicKey, associatedTokenProgramId?: PublicKey): PublicKey;
declare function getAmountOfFractionalAmount(amount: string | number, decimals: string | number): bigint;
declare function getDisplayAmount(inputAmount: ethers.BigNumberish, decimals: string | ethers.BigNumberish): number;
declare function getWormholeChainIdByName(chain: ChainName): number;
declare function getEvmChainIdByName(chain: ChainName): number;
declare function getWormholeChainIdById(chainId: number): number | null;
declare function getSdkVersion(): string;
declare function checkSdkVersionSupport(minimumVersion: [number, number, number]): boolean;
declare function getGasDecimal(chain: ChainName): number;
declare function getGasDecimalsInSolana(chain: ChainName): number;
declare function getSafeU64Blob(value: bigint): Buffer;
declare const ZeroPermit: Erc20Permit;
declare function wait(time: number): Promise<void>;
declare function getQuoteSuitableReferrerAddress(quote: Quote, referrerAddresses?: ReferrerAddresses | null): string | null;
declare const MCTP_PAYLOAD_TYPE_DEFAULT = 1;
declare const MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD = 2;
declare const MCTP_INIT_ORDER_PAYLOAD_ID = 1;
declare const FAST_MCTP_PAYLOAD_TYPE_DEFAULT = 1;
declare const FAST_MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD = 2;
declare const FAST_MCTP_PAYLOAD_TYPE_ORDER = 3;
declare const SWIFT_PAYLOAD_TYPE_DEFAULT = 1;
declare const SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD = 2;
declare function getPermitDomain(token: Token, provider: JsonRpcProvider): Promise<PermitDomain>;
declare const PermitTypes: {
    Permit: {
        name: string;
        type: string;
    }[];
};
declare function getPermitParams(token: Token, walletAddress: string, spender: string, amount: bigint, provider: JsonRpcProvider, deadline: BigInt): Promise<{
    domain: PermitDomain;
    types: typeof PermitTypes;
    value: PermitValue;
}>;
declare function getHyperCoreUSDCDepositPermitParams(quote: Quote, userArbitrumAddress: string, arbProvider: JsonRpcProvider): Promise<{
    domain: PermitDomain;
    types: typeof PermitTypes;
    value: PermitValue;
}>;
declare function getHyperCoreUSDCDepositCustomPayload(quote: Quote, destinationAddress: string, usdcPermitSignature: string): Buffer;
declare function getSwiftToTokenHexString(quote: Quote): string;
declare function getNormalizeFactor(toChain: ChainName, quoteType: QuoteType): number;
declare function createSwiftRandomKey(quote: Quote): Buffer;

declare const _default: {
    MAYAN_FORWARDER_CONTRACT: string;
    MAYAN_PROGRAM_ID: string;
    AUCTION_PROGRAM_ID: string;
    MCTP_PROGRAM_ID: string;
    FAST_MCTP_PROGRAM_ID: string;
    SWIFT_PROGRAM_ID: string;
    SWIFT_V2_PROGRAM_ID: string;
    FEE_MANAGER_PROGRAM_ID: string;
    WORMHOLE_PROGRAM_ID: string;
    WORMHOLE_PROGRAM_ID_FOGO: string;
    WORMHOLE_SHIM_POST_MESSAGE_PROGRAM_ID: string;
    CCTP_CORE_PROGRAM_ID: string;
    CCTPV2_CORE_PROGRAM_ID: string;
    CCTP_TOKEN_PROGRAM_ID: string;
    CCTPV2_TOKEN_PROGRAM_ID: string;
    TOKEN_PROGRAM_ID: string;
    TOKEN_2022_PROGRAM_ID: string;
    ASSOCIATED_TOKEN_PROGRAM_ID: string;
    SPL_UTILS_PROGRAM_ID: string;
    LOOKUP_TABLE_SOLANA: string;
    LOOKUP_TABLE_FOGO: string;
    SUI_MCTP_STATE: string;
    SUI_MCTP_FEE_MANAGER_STATE: string;
    SUI_SWIFT_STATE: string;
    SUI_SWIFT_FEE_MANAGER_STATE: string;
    SUI_CCTP_CORE_PACKAGE_ID: string;
    SUI_CCTP_CORE_STATE: string;
    SUI_CCTP_TOKEN_PACKAGE_ID: string;
    SUI_CCTP_TOKEN_STATE: string;
    SUI_WORMHOLE_PACKAGE_ID: string;
    SUI_WORMHOLE_STATE: string;
    SUI_LOGGER_PACKAGE_ID: string;
    EXPLORER_URL: string;
    PRICE_URL: string;
    RELAYER_URL: string;
    SWIFT_RELAYER_URL: string;
    GAS_ESTIMATE_URL: string;
    HC_ARBITRUM_BRIDGE: string;
    HC_ARBITRUM_DEPOSIT_PROCESSOR: string;
    ARBITRUM_USDC_CONTRACT: string;
    PAYLOAD_WRITER_PROGRAM_ID: string;
    CPI_PROXY_PROGRAM_ID: string;
};

export { ChainName, ComposableSuiMoveCallsOptions, ContractRelayerFees, Criteria, Erc20Permit, EstimateGasEvmParams, EvmForwarderParams, EvmSwapParams, EvmSwiftParams, FAST_MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD, FAST_MCTP_PAYLOAD_TYPE_DEFAULT, FAST_MCTP_PAYLOAD_TYPE_ORDER, GetEvmSwapParams, GetSolanaSwapParams, GetSuiSwapParams, InstructionInfo, JitoBundleOptions, MCTP_INIT_ORDER_PAYLOAD_ID, MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD, MCTP_PAYLOAD_TYPE_DEFAULT, PermitDomain, PermitTypes, PermitValue, Quote, QuoteError, QuoteOptions, QuoteParams, QuoteType, Recipient, ReferrerAddresses, SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD, SWIFT_PAYLOAD_TYPE_DEFAULT, SolanaBridgeOptions, SolanaClientSwap, SolanaKeyInfo, SolanaTransactionSigner, SuiClientSwap, SuiFunctionNestedResult, SuiFunctionParameter, SwapMessageV0Params, SwiftEvmGasLessParams, SwiftEvmOrderTypedData, SwiftOrderParams, Token, TokenStandard, ZeroPermit, addBridgeLockedFeeMoveCalls, addBridgeWithFeeMoveCalls, addBridgeWithFeeMoveCalls2, addInitOrderMoveCalls, _default as addresses, assertArgumentIsImmutable, broadcastJitoBundleId, checkHyperCoreDeposit, checkSdkVersionSupport, confirmJitoBundleId, createApproveInstruction, createAssociatedTokenAccountInstruction, createCloseAccountInstruction, createHyperCoreDepositFromSolanaInstructions, createHyperCoreDepositFromSuiMoveCalls, createInitializeRandomTokenAccountInstructions, createMctpBridgeLedgerInstruction, createMctpBridgeWithFeeInstruction, createMctpFromSolanaInstructions, createMctpFromSuiMoveCalls, createMonoChainFromSolanaInstructions, createPayloadWriterCloseInstruction, createPayloadWriterCreateInstruction, createSplTransferInstruction, createSwapFromSolanaInstructions, createSwapFromSuiMoveCalls, createSwiftFromSolanaInstructions, createSwiftOrderHash, createSwiftRandomKey, createSyncNativeInstruction, createTransferAllAndCloseInstruction, decentralizeClientSwapInstructions, decideRelayer, deserializeInstructionInfo, estimateQuoteRequiredGas, estimateQuoteRequiredGasAprox, estimateQuoteRequiredGasAprox2, fetchAllCoins, fetchAllTokenList, fetchMayanSuiPackageId, fetchQuote, fetchTokenList, generateFetchQuoteUrl, getAddressLookupTableAccounts, getAmountOfFractionalAmount, getAnchorInstructionData, getAssociatedTokenAddress, getCurrentChainTime, getDisplayAmount, getEstimateGasEvm, getEvmChainIdByName, getEvmSwiftParams, getFastMctpFromEvmTxPayload, getGasDecimal, getGasDecimalsInSolana, getHyperCoreDepositFromEvmTxPayload, getHyperCoreUSDCDepositCustomPayload, getHyperCoreUSDCDepositPermitParams, getJitoTipTransfer, getLookupTableAddress, getMctpFromEvmTxPayload, getMonoChainFromEvmTxPayload, getNormalizeFactor, getPermitDomain, getPermitParams, getQuoteSuitableReferrerAddress, getSafeU64Blob, getSdkVersion, getSuggestedRelayer, getSvmDurableNonce, getSwapEvm, getSwapFromEvmTxPayload, getSwapSolana, getSwapSui, getSwiftFromEvmGasLessParams, getSwiftFromEvmTxPayload, getSwiftOrderTypeData, getSwiftToTokenHexString, getWormholeChainIdById, getWormholeChainIdByName, hexToUint8Array, isValidAptosType, nativeAddressToHexString, resolveInputCoin, sandwichInstructionInCpiProxy, sendJitoBundle, solMint, submitSwiftEvmSwap, submitSwiftSolanaSwap, submitTransactionWithRetry, swapFromEvm, swapFromSolana, unwrapSol, validateJupSwap, validateJupSwapInstructionData, wait, wrapSol };
