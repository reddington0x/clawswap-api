"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  FAST_MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD: () => FAST_MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD,
  FAST_MCTP_PAYLOAD_TYPE_DEFAULT: () => FAST_MCTP_PAYLOAD_TYPE_DEFAULT,
  FAST_MCTP_PAYLOAD_TYPE_ORDER: () => FAST_MCTP_PAYLOAD_TYPE_ORDER,
  MCTP_INIT_ORDER_PAYLOAD_ID: () => MCTP_INIT_ORDER_PAYLOAD_ID,
  MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD: () => MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD,
  MCTP_PAYLOAD_TYPE_DEFAULT: () => MCTP_PAYLOAD_TYPE_DEFAULT,
  PermitTypes: () => PermitTypes,
  SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD: () => SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD,
  SWIFT_PAYLOAD_TYPE_DEFAULT: () => SWIFT_PAYLOAD_TYPE_DEFAULT,
  ZeroPermit: () => ZeroPermit,
  addBridgeLockedFeeMoveCalls: () => addBridgeLockedFeeMoveCalls,
  addBridgeWithFeeMoveCalls: () => addBridgeWithFeeMoveCalls,
  addBridgeWithFeeMoveCalls2: () => addBridgeWithFeeMoveCalls2,
  addInitOrderMoveCalls: () => addInitOrderMoveCalls,
  addresses: () => addresses_default,
  assertArgumentIsImmutable: () => assertArgumentIsImmutable,
  broadcastJitoBundleId: () => broadcastJitoBundleId,
  checkHyperCoreDeposit: () => checkHyperCoreDeposit,
  checkSdkVersionSupport: () => checkSdkVersionSupport,
  confirmJitoBundleId: () => confirmJitoBundleId,
  createApproveInstruction: () => createApproveInstruction,
  createAssociatedTokenAccountInstruction: () => createAssociatedTokenAccountInstruction,
  createCloseAccountInstruction: () => createCloseAccountInstruction,
  createHyperCoreDepositFromSolanaInstructions: () => createHyperCoreDepositFromSolanaInstructions,
  createHyperCoreDepositFromSuiMoveCalls: () => createHyperCoreDepositFromSuiMoveCalls,
  createInitializeRandomTokenAccountInstructions: () => createInitializeRandomTokenAccountInstructions,
  createMctpBridgeLedgerInstruction: () => createMctpBridgeLedgerInstruction,
  createMctpBridgeWithFeeInstruction: () => createMctpBridgeWithFeeInstruction,
  createMctpFromSolanaInstructions: () => createMctpFromSolanaInstructions,
  createMctpFromSuiMoveCalls: () => createMctpFromSuiMoveCalls,
  createMonoChainFromSolanaInstructions: () => createMonoChainFromSolanaInstructions,
  createPayloadWriterCloseInstruction: () => createPayloadWriterCloseInstruction,
  createPayloadWriterCreateInstruction: () => createPayloadWriterCreateInstruction,
  createSplTransferInstruction: () => createSplTransferInstruction,
  createSwapFromSolanaInstructions: () => createSwapFromSolanaInstructions,
  createSwapFromSuiMoveCalls: () => createSwapFromSuiMoveCalls,
  createSwiftFromSolanaInstructions: () => createSwiftFromSolanaInstructions,
  createSwiftOrderHash: () => createSwiftOrderHash,
  createSwiftRandomKey: () => createSwiftRandomKey,
  createSyncNativeInstruction: () => createSyncNativeInstruction,
  createTransferAllAndCloseInstruction: () => createTransferAllAndCloseInstruction,
  decentralizeClientSwapInstructions: () => decentralizeClientSwapInstructions,
  decideRelayer: () => decideRelayer,
  deserializeInstructionInfo: () => deserializeInstructionInfo,
  estimateQuoteRequiredGas: () => estimateQuoteRequiredGas,
  estimateQuoteRequiredGasAprox: () => estimateQuoteRequiredGasAprox,
  estimateQuoteRequiredGasAprox2: () => estimateQuoteRequiredGasAprox2,
  fetchAllCoins: () => fetchAllCoins,
  fetchAllTokenList: () => fetchAllTokenList,
  fetchMayanSuiPackageId: () => fetchMayanSuiPackageId,
  fetchQuote: () => fetchQuote,
  fetchTokenList: () => fetchTokenList,
  generateFetchQuoteUrl: () => generateFetchQuoteUrl,
  getAddressLookupTableAccounts: () => getAddressLookupTableAccounts,
  getAmountOfFractionalAmount: () => getAmountOfFractionalAmount,
  getAnchorInstructionData: () => getAnchorInstructionData,
  getAssociatedTokenAddress: () => getAssociatedTokenAddress,
  getCurrentChainTime: () => getCurrentChainTime,
  getDisplayAmount: () => getDisplayAmount,
  getEstimateGasEvm: () => getEstimateGasEvm,
  getEvmChainIdByName: () => getEvmChainIdByName,
  getEvmSwiftParams: () => getEvmSwiftParams,
  getFastMctpFromEvmTxPayload: () => getFastMctpFromEvmTxPayload,
  getGasDecimal: () => getGasDecimal,
  getGasDecimalsInSolana: () => getGasDecimalsInSolana,
  getHyperCoreDepositFromEvmTxPayload: () => getHyperCoreDepositFromEvmTxPayload,
  getHyperCoreUSDCDepositCustomPayload: () => getHyperCoreUSDCDepositCustomPayload,
  getHyperCoreUSDCDepositPermitParams: () => getHyperCoreUSDCDepositPermitParams,
  getJitoTipTransfer: () => getJitoTipTransfer,
  getLookupTableAddress: () => getLookupTableAddress,
  getMctpFromEvmTxPayload: () => getMctpFromEvmTxPayload,
  getMonoChainFromEvmTxPayload: () => getMonoChainFromEvmTxPayload,
  getNormalizeFactor: () => getNormalizeFactor,
  getPermitDomain: () => getPermitDomain,
  getPermitParams: () => getPermitParams,
  getQuoteSuitableReferrerAddress: () => getQuoteSuitableReferrerAddress,
  getSafeU64Blob: () => getSafeU64Blob,
  getSdkVersion: () => getSdkVersion,
  getSuggestedRelayer: () => getSuggestedRelayer,
  getSvmDurableNonce: () => getSvmDurableNonce,
  getSwapEvm: () => getSwapEvm,
  getSwapFromEvmTxPayload: () => getSwapFromEvmTxPayload,
  getSwapSolana: () => getSwapSolana,
  getSwapSui: () => getSwapSui,
  getSwiftFromEvmGasLessParams: () => getSwiftFromEvmGasLessParams,
  getSwiftFromEvmTxPayload: () => getSwiftFromEvmTxPayload,
  getSwiftOrderTypeData: () => getSwiftOrderTypeData,
  getSwiftToTokenHexString: () => getSwiftToTokenHexString,
  getWormholeChainIdById: () => getWormholeChainIdById,
  getWormholeChainIdByName: () => getWormholeChainIdByName,
  hexToUint8Array: () => hexToUint8Array,
  isValidAptosType: () => isValidAptosType,
  nativeAddressToHexString: () => nativeAddressToHexString,
  resolveInputCoin: () => resolveInputCoin,
  sandwichInstructionInCpiProxy: () => sandwichInstructionInCpiProxy,
  sendJitoBundle: () => sendJitoBundle,
  solMint: () => solMint,
  submitSwiftEvmSwap: () => submitSwiftEvmSwap,
  submitSwiftSolanaSwap: () => submitSwiftSolanaSwap,
  submitTransactionWithRetry: () => submitTransactionWithRetry,
  swapFromEvm: () => swapFromEvm,
  swapFromSolana: () => swapFromSolana,
  unwrapSol: () => unwrapSol,
  validateJupSwap: () => validateJupSwap,
  validateJupSwapInstructionData: () => validateJupSwapInstructionData,
  wait: () => wait,
  wrapSol: () => wrapSol
});
module.exports = __toCommonJS(src_exports);

// src/api.ts
var import_cross_fetch = __toESM(require("cross-fetch"));

// src/addresses.ts
var addresses_default = {
  "MAYAN_FORWARDER_CONTRACT": "0x337685fdaB40D39bd02028545a4FfA7D287cC3E2",
  "MAYAN_PROGRAM_ID": "FC4eXxkyrMPTjiYUpp4EAnkmwMbQyZ6NDCh1kfLn6vsf",
  "AUCTION_PROGRAM_ID": "8QJmxZcEzwuYmCPy6XqgN2sHcYCcFq6AEfBMJZZuLo5a",
  "MCTP_PROGRAM_ID": "dkpZqrxHFrhziEMQ931GLtfy11nFkCsfMftH9u6QwBU",
  "FAST_MCTP_PROGRAM_ID": "Gx9rivpS3YR8pBFwMuP6omYqVxunpLvLkNn7ubNyuZZ5",
  "SWIFT_PROGRAM_ID": "BLZRi6frs4X4DNLw56V4EXai1b6QVESN1BhHBTYM9VcY",
  "SWIFT_V2_PROGRAM_ID": "92peaC8g5ANAxpK2aCfLTC12JgPncRKCGULQNB2DMvRH",
  "FEE_MANAGER_PROGRAM_ID": "5VtQHnhs2pfVEr68qQsbTRwKh4JV5GTu9mBHgHFxpHeQ",
  "WORMHOLE_PROGRAM_ID": "worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth",
  "WORMHOLE_PROGRAM_ID_FOGO": "worm2mrQkG1B1KTz37erMfWN8anHkSK24nzca7UD8BB",
  "WORMHOLE_SHIM_POST_MESSAGE_PROGRAM_ID": "EtZMZM22ViKMo4r5y4Anovs3wKQ2owUmDpjygnMMcdEX",
  "CCTP_CORE_PROGRAM_ID": "CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd",
  "CCTPV2_CORE_PROGRAM_ID": "CCTPV2Sm4AdWt5296sk4P66VBZ7bEhcARwFaaS9YPbeC",
  "CCTP_TOKEN_PROGRAM_ID": "CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3",
  "CCTPV2_TOKEN_PROGRAM_ID": "CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe",
  "TOKEN_PROGRAM_ID": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  "TOKEN_2022_PROGRAM_ID": "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",
  "ASSOCIATED_TOKEN_PROGRAM_ID": "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",
  "SPL_UTILS_PROGRAM_ID": "B96dV3Luxzo6SokJx3xt8i5y8Mb7HRR6Eec8hCjJDT69",
  "LOOKUP_TABLE_SOLANA": "Ff3yi1meWQQ19VPZMzGg6H8JQQeRudiV7QtVtyzJyoht",
  "LOOKUP_TABLE_FOGO": "ZnLmtY5qckPcBQfdD4uKh9GtiQTrzQfQXEX86U3aLq7",
  "SUI_MCTP_STATE": "0xb787fe0f7530b4fd2162fa0cc92f4f6c5a97c54b4c5c55eb04ab29f4b803ac9c",
  "SUI_MCTP_FEE_MANAGER_STATE": "0xa1b4a96ce93d36dd0bbce0adc39533a07d2f32928918c80cd6fe7868320978f2",
  "SUI_SWIFT_STATE": "0x7ac01a7c14c53098a41593c7623823bb677b5201fb3ee35b75b47cfc6c6c6f40",
  "SUI_SWIFT_FEE_MANAGER_STATE": "0xe42174b6d742f40bd2b67b967542b21e6d7433f2d277a80bb59866ac73ff3f52",
  "SUI_CCTP_CORE_PACKAGE_ID": "0x08d87d37ba49e785dde270a83f8e979605b03dc552b5548f26fdf2f49bf7ed1b",
  "SUI_CCTP_CORE_STATE": "0xf68268c3d9b1df3215f2439400c1c4ea08ac4ef4bb7d6f3ca6a2a239e17510af",
  "SUI_CCTP_TOKEN_PACKAGE_ID": "0x2aa6c5d56376c371f88a6cc42e852824994993cb9bab8d3e6450cbe3cb32b94e",
  "SUI_CCTP_TOKEN_STATE": "0x45993eecc0382f37419864992c12faee2238f5cfe22b98ad3bf455baf65c8a2f",
  "SUI_WORMHOLE_PACKAGE_ID": "0x5306f64e312b581766351c07af79c72fcb1cd25147157fdc2f8ad76de9a3fb6a",
  "SUI_WORMHOLE_STATE": "0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c",
  "SUI_LOGGER_PACKAGE_ID": "0x05680e9030c147b413a489f7891273acc221d49bd061c433e5771bc170fc37ac",
  "EXPLORER_URL": "https://explorer-api.mayan.finance/v3",
  "PRICE_URL": "https://price-api.mayan.finance/v3",
  "RELAYER_URL": "https://relayer-api.mayan.finance/v3",
  "SWIFT_RELAYER_URL": "https://swift-relayer-api.mayan.finance/v3",
  "GAS_ESTIMATE_URL": "https://gas-estimate.mayan.finance/v2",
  "HC_ARBITRUM_BRIDGE": "0x2df1c51e09aecf9cacb7bc98cb1742757f163df7",
  "HC_ARBITRUM_DEPOSIT_PROCESSOR": "0xdDd77e62C848C3334f1148d4F1457FC59ede4E4B",
  "ARBITRUM_USDC_CONTRACT": "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
  "PAYLOAD_WRITER_PROGRAM_ID": "DwMLtdtJqJQkHzNcrdTBuWHJByJfgpKBnvFvzyKdy3cU",
  "CPI_PROXY_PROGRAM_ID": "D8C8iW6zmoKg5TRr8nQ7h14TMWqQX8FiBdj2ju5MF3wa"
};

// src/utils.ts
var import_ethers = require("ethers");
var import_web3 = require("@solana/web3.js");
var import_buffer = require("buffer");

// src/evm/ERC20Artifact.ts
var ERC20Artifact_default = {
  "_format": "hh-sol-artifact-1",
  "contractName": "ERC20Permit",
  "sourceName": "contracts/token/ERC20/extensions/ERC20Permit.sol",
  "abi": [
    {
      "inputs": [],
      "name": "ECDSAInvalidSignature",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "ECDSAInvalidSignatureLength",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "ECDSAInvalidSignatureS",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "allowance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "needed",
          "type": "uint256"
        }
      ],
      "name": "ERC20InsufficientAllowance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "needed",
          "type": "uint256"
        }
      ],
      "name": "ERC20InsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "approver",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidApprover",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidReceiver",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidSender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidSpender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "ERC2612ExpiredSignature",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "signer",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "ERC2612InvalidSigner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "currentNonce",
          "type": "uint256"
        }
      ],
      "name": "InvalidAccountNonce",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidShortString",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "str",
          "type": "string"
        }
      ],
      "name": "StringTooLong",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "EIP712DomainChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DOMAIN_SEPARATOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "eip712Domain",
      "outputs": [
        {
          "internalType": "bytes1",
          "name": "fields",
          "type": "bytes1"
        },
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "version",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "verifyingContract",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "uint256[]",
          "name": "extensions",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "nonces",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "permit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "linkReferences": {},
  "deployedLinkReferences": {}
};

// src/utils.ts
var sha3 = __toESM(require("js-sha3"));
var sha3_2562 = sha3.sha3_256;
var isValidAptosType = (str) => /^(0x)?[0-9a-fA-F]+::\w+::\w+$/.test(str);
function nativeAddressToHexString(address, wChainId) {
  if (wChainId === chains.solana || wChainId === chains.fogo) {
    return (0, import_ethers.zeroPadValue)(new import_web3.PublicKey(address).toBytes(), 32);
  } else if (wChainId === chains.ethereum || wChainId === chains.bsc || wChainId === chains.polygon || wChainId === chains.avalanche || wChainId === chains.arbitrum || wChainId === chains.optimism || wChainId === chains.base || wChainId === chains.unichain || wChainId === chains.linea || wChainId === chains.sonic || wChainId === chains.hyperevm || wChainId === chains.monad) {
    return (0, import_ethers.zeroPadValue)(address, 32);
  } else if (wChainId === chains.aptos && isValidAptosType(address)) {
    return `0x${sha3_2562(address)}`;
  } else if (wChainId === chains.sui || wChainId === chains.ton) {
    let addressStr = address.startsWith("0x") ? address.substring(2) : address;
    if (import_buffer.Buffer.from(addressStr, "hex").length !== 32) {
      throw new Error(`Invalid address: ` + address);
    }
    return (0, import_ethers.zeroPadValue)(address, 32);
  } else {
    console.log(`Unsupported chain id: ${wChainId}`, address);
    throw new Error("Unsupported token chain");
  }
}
function hexToUint8Array(input) {
  return new Uint8Array(
    import_buffer.Buffer.from(
      input.startsWith("0x") ? input.substring(2) : input,
      "hex"
    )
  );
}
function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = new import_web3.PublicKey(addresses_default.TOKEN_PROGRAM_ID), associatedTokenProgramId = new import_web3.PublicKey(addresses_default.ASSOCIATED_TOKEN_PROGRAM_ID)) {
  if (!allowOwnerOffCurve && !import_web3.PublicKey.isOnCurve(owner.toBuffer())) {
    throw new Error("TokenOwnerOffCurveError");
  }
  const [address] = import_web3.PublicKey.findProgramAddressSync(
    [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],
    associatedTokenProgramId
  );
  return address;
}
function isValidNumericInput(value) {
  return (typeof value === "string" || typeof value === "number") && value !== "" && value !== null && !isNaN(Number(value)) && Number.isFinite(Number(value));
}
function getAmountOfFractionalAmount(amount, decimals) {
  if (amount === null || amount === void 0) {
    throw new Error("getAmountOfFractionalAmount: Amount is null or undefined");
  }
  if (typeof amount !== "string" && typeof amount !== "number") {
    throw new Error("getAmountOfFractionalAmount: Amount is not a string or number");
  }
  if (typeof amount === "string" && amount.length === 0) {
    throw new Error("getAmountOfFractionalAmount: Amount is empty");
  }
  if (!Number.isFinite(Number(amount))) {
    throw new Error("getAmountOfFractionalAmount: Amount is not a number");
  }
  if (!isValidNumericInput(decimals)) {
    throw new Error("getAmountOfFractionalAmount: decimals is not a number");
  }
  const cutFactor = Math.min(8, Number(decimals));
  const numStr = Number(amount).toFixed(cutFactor + 1);
  const reg = new RegExp(`^-?\\d+(?:\\.\\d{0,${cutFactor}})?`);
  const matchResult = numStr.match(reg);
  if (!matchResult) {
    throw new Error("getAmountOfFractionalAmount: fixedAmount is null");
  }
  const fixedAmount = matchResult[0];
  return (0, import_ethers.parseUnits)(fixedAmount, Number(decimals));
}
function getDisplayAmount(inputAmount, decimals) {
  return Number((0, import_ethers.formatUnits)(inputAmount, decimals));
}
var chains = {
  solana: 1,
  ethereum: 2,
  bsc: 4,
  polygon: 5,
  avalanche: 6,
  arbitrum: 23,
  optimism: 24,
  base: 30,
  aptos: 22,
  sui: 21,
  ton: 13,
  unichain: 44,
  linea: 38,
  hypercore: 65e3,
  sonic: 52,
  hyperevm: 47,
  fogo: 51,
  monad: 48
};
function getWormholeChainIdByName(chain) {
  const result = chains[chain];
  if (!result) {
    throw new Error(`Chain Id not found for chain: ${chain}`);
  }
  return result;
}
var evmChainIdMap = {
  [1]: 2,
  [56]: 4,
  [137]: 5,
  [43114]: 6,
  [42161]: 23,
  [10]: 24,
  [8453]: 30,
  [130]: 44,
  [59144]: 38,
  [146]: 52,
  [999]: 47,
  [143]: 48
};
function getEvmChainIdByName(chain) {
  const wormholeChainId = chains[chain];
  const evmIds = Object.keys(evmChainIdMap);
  for (const evmId of evmIds) {
    if (evmChainIdMap[evmId] === wormholeChainId) {
      return Number(evmId);
    }
  }
  throw new Error(`Unsupported chain: ${chain}`);
}
function getWormholeChainIdById(chainId) {
  return evmChainIdMap[chainId];
}
var sdkVersion = [12, 2, 5];
function getSdkVersion() {
  return sdkVersion.join("_");
}
function checkSdkVersionSupport(minimumVersion) {
  if (sdkVersion[0] < minimumVersion[0]) {
    return false;
  }
  if (sdkVersion[0] > minimumVersion[0]) {
    return true;
  }
  if (sdkVersion[1] < minimumVersion[1]) {
    return false;
  }
  if (sdkVersion[1] > minimumVersion[1]) {
    return true;
  }
  if (sdkVersion[2] >= minimumVersion[2]) {
    return true;
  }
  return false;
}
function getGasDecimal(chain) {
  if (chain === "solana" || chain === "sui" || chain === "ton") {
    return 9;
  }
  return 18;
}
function getGasDecimalsInSolana(chain) {
  if (chain === "solana") {
    return 9;
  }
  return 8;
}
var MAX_U64 = BigInt(2) ** BigInt(64) - BigInt(1);
function getSafeU64Blob(value) {
  if (value < BigInt(0) || value > MAX_U64) {
    throw new Error(`Invalid u64: ${value}`);
  }
  const buf = import_buffer.Buffer.alloc(8);
  buf.writeBigUInt64LE(value);
  return buf;
}
var ZeroPermit = {
  value: BigInt(0),
  deadline: 0,
  v: 0,
  r: `0x${import_web3.SystemProgram.programId.toBuffer().toString("hex")}`,
  s: `0x${import_web3.SystemProgram.programId.toBuffer().toString("hex")}`
};
function wait(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, time);
  });
}
function getQuoteSuitableReferrerAddress(quote, referrerAddresses) {
  if (!quote || !referrerAddresses) {
    return null;
  }
  if (quote.type === "WH") {
    return referrerAddresses?.solana || null;
  }
  if (quote.type === "MCTP") {
    if (quote.toChain === "solana") {
      return referrerAddresses?.solana || null;
    }
    if (quote.toChain === "sui") {
      return referrerAddresses?.sui || null;
    }
    return referrerAddresses?.evm || null;
  }
  if (quote.type === "SWIFT") {
    if (quote.swiftVersion === "V2") {
      if (quote.fromChain === "solana" || quote.fromChain === "fogo") {
        return referrerAddresses?.solana || null;
      }
      if (quote.fromChain === "sui") {
        return referrerAddresses?.sui || null;
      }
      return referrerAddresses?.evm || null;
    } else {
      if (quote.toChain === "solana") {
        return referrerAddresses?.solana || null;
      }
      if (quote.toChain === "sui") {
        throw new Error("Swift V1 does not support SUI");
      }
      return referrerAddresses?.evm || null;
    }
  }
  if (quote.type === "FAST_MCTP") {
    if (quote.toChain === "solana") {
      return referrerAddresses?.solana || null;
    }
    if (quote.toChain !== "sui") {
      return referrerAddresses?.evm || null;
    }
  }
  if (quote.type === "MONO_CHAIN") {
    if (quote.fromChain === "solana") {
      return referrerAddresses?.solana || null;
    } else if (quote.fromChain === "sui") {
      return referrerAddresses?.sui || null;
    }
    return referrerAddresses?.evm || null;
  }
  return null;
}
var MCTP_PAYLOAD_TYPE_DEFAULT = 1;
var MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD = 2;
var MCTP_INIT_ORDER_PAYLOAD_ID = 1;
var FAST_MCTP_PAYLOAD_TYPE_DEFAULT = 1;
var FAST_MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD = 2;
var FAST_MCTP_PAYLOAD_TYPE_ORDER = 3;
var SWIFT_PAYLOAD_TYPE_DEFAULT = 1;
var SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD = 2;
async function getPermitDomain(token, provider) {
  const contract = new import_ethers.ethers.Contract(
    token.contract,
    ERC20Artifact_default.abi,
    provider
  );
  let domainSeparator;
  let name;
  try {
    let [_domainSeparator, _name] = await Promise.all([
      contract.DOMAIN_SEPARATOR(),
      contract.name()
    ]);
    domainSeparator = _domainSeparator;
    name = _name;
  } catch (err) {
    throw {
      mayanError: {
        permitIssue: true
      }
    };
  }
  const domain = {
    name,
    version: "1",
    chainId: token.chainId,
    verifyingContract: token.contract
  };
  for (let i = 1; i < 11; i++) {
    domain.version = String(i);
    const hash = import_ethers.TypedDataEncoder.hashDomain(domain);
    if (hash.toLowerCase() === domainSeparator.toLowerCase()) {
      return domain;
    }
  }
  const salt = import_ethers.ethers.zeroPadValue(import_ethers.ethers.toBeHex(token.chainId), 32);
  const LEGACY_DOMAIN_TYPEHASH = import_ethers.ethers.keccak256(
    import_ethers.ethers.toUtf8Bytes(
      "EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)"
    )
  );
  if (token.realOriginChainId && token.realOriginContractAddress && token.wChainId !== token.realOriginChainId) {
    const whChainId2Bytes = new Uint8Array(2);
    whChainId2Bytes[0] = token.realOriginChainId >> 8 & 255;
    whChainId2Bytes[1] = token.realOriginChainId & 255;
    const packed = new Uint8Array(2 + 32);
    packed.set(whChainId2Bytes, 0);
    packed.set(
      import_ethers.ethers.getBytes(import_ethers.ethers.zeroPadValue(token.realOriginContractAddress, 32)),
      2
    );
    const salt2 = import_ethers.ethers.keccak256(packed);
    const DOMAIN_TYPEHASH = import_ethers.ethers.keccak256(
      import_ethers.ethers.toUtf8Bytes(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)"
      )
    );
    for (let i = 0; i < 11; i++) {
      const hash = import_ethers.ethers.keccak256(
        new import_ethers.ethers.AbiCoder().encode(
          ["bytes32", "bytes32", "bytes32", "uint256", "address", "bytes32"],
          [
            DOMAIN_TYPEHASH,
            import_ethers.ethers.keccak256(import_ethers.ethers.toUtf8Bytes(name)),
            import_ethers.ethers.keccak256(import_ethers.ethers.toUtf8Bytes(String(i))),
            token.chainId,
            token.contract,
            salt2
          ]
        )
      );
      if (hash.toLowerCase() === domainSeparator.toLowerCase()) {
        domain.version = String(i);
        domain.salt = salt2;
        return domain;
      }
    }
  }
  for (let i = 0; i < 11; i++) {
    const hash = import_ethers.ethers.keccak256(
      new import_ethers.ethers.AbiCoder().encode(
        ["bytes32", "bytes32", "bytes32", "address", "bytes32"],
        [
          LEGACY_DOMAIN_TYPEHASH,
          import_ethers.ethers.keccak256(import_ethers.ethers.toUtf8Bytes(name)),
          import_ethers.ethers.keccak256(import_ethers.ethers.toUtf8Bytes(String(i))),
          token.contract,
          salt
        ]
      )
    );
    if (hash.toLowerCase() === domainSeparator.toLowerCase()) {
      delete domain.chainId;
      domain.version = String(i);
      domain.salt = salt;
      return domain;
    }
  }
  throw {
    mayanError: {
      permitIssue: true
    }
  };
}
var PermitTypes = {
  Permit: [
    {
      name: "owner",
      type: "address"
    },
    {
      name: "spender",
      type: "address"
    },
    {
      name: "value",
      type: "uint256"
    },
    {
      name: "nonce",
      type: "uint256"
    },
    {
      name: "deadline",
      type: "uint256"
    }
  ]
};
async function getPermitParams(token, walletAddress, spender, amount, provider, deadline) {
  if (token.standard !== "erc20" && token.standard !== "hypertoken") {
    throw new Error("Token is not ERC20");
  }
  if (!token.supportsPermit) {
    throw new Error("Token does not support permit");
  }
  const contract = new import_ethers.ethers.Contract(token.contract, ERC20Artifact_default.abi, provider);
  const [domain, nonce] = await Promise.all([getPermitDomain(token, provider), contract.nonces(walletAddress)]);
  return {
    domain,
    types: PermitTypes,
    value: {
      owner: walletAddress,
      spender,
      nonce: String(nonce),
      value: String(amount),
      deadline: String(deadline)
    }
  };
}
async function getHyperCoreUSDCDepositPermitParams(quote, userArbitrumAddress, arbProvider) {
  if (!quote.hyperCoreParams) {
    throw new Error("Quote does not have hyperCoreParams");
  }
  if (quote.toChain !== "hypercore") {
    throw new Error("Quote toChain is not hypercore");
  }
  if (quote.toToken.contract.toLowerCase() !== addresses_default.ARBITRUM_USDC_CONTRACT.toLowerCase()) {
    throw new Error("Quote toToken is not USDC on Arbitrum");
  }
  const USDC_ARB_TOKEN = {
    name: "USDC",
    standard: "erc20",
    symbol: "USDC",
    mint: "CR4xnGrhsu1fWNPoX4KbTUUtqGMF3mzRLfj4S6YEs1Yo",
    verified: true,
    contract: "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
    chainId: 42161,
    wChainId: 23,
    decimals: 6,
    logoURI: "http://assets.coingecko.com/coins/images/6319/small/usdc.png?1696506694",
    coingeckoId: "usd-coin",
    realOriginContractAddress: "0xaf88d065e77c8cc2239327c5edb3a432268e5831",
    realOriginChainId: 23,
    supportsPermit: true,
    verifiedAddress: "0xaf88d065e77c8cc2239327c5edb3a432268e5831"
  };
  const [permitParams, isAllowed] = await Promise.all([
    getPermitParams(
      USDC_ARB_TOKEN,
      userArbitrumAddress,
      addresses_default.HC_ARBITRUM_BRIDGE,
      BigInt(quote.hyperCoreParams.depositAmountUSDC64),
      arbProvider,
      BigInt(quote.deadline64)
    ),
    checkHyperCoreDeposit(userArbitrumAddress, quote.toToken.contract)
  ]);
  if (!isAllowed) {
    throw new Error("Because of concurrency, deposit is not possible at the moment, please try again later");
  }
  return permitParams;
}
function getHyperCoreUSDCDepositCustomPayload(quote, destinationAddress, usdcPermitSignature) {
  const payload = import_buffer.Buffer.alloc(109);
  const destAddressBuf = import_buffer.Buffer.from(hexToUint8Array(destinationAddress));
  if (destAddressBuf.length !== 20) {
    throw new Error("Invalid destination address length, expected 20 bytes");
  }
  const permitSignatureBuf = import_buffer.Buffer.from(
    hexToUint8Array(usdcPermitSignature)
  );
  if (permitSignatureBuf.length !== 65) {
    throw new Error("Invalid USDC permit signature length, expected 65 bytes");
  }
  if (!quote.redeemRelayerFee64 || !quote.hyperCoreParams) {
    throw new Error("Invalid quote for HyperCore USDC deposit custom payload");
  }
  payload.writeBigUInt64BE(BigInt(quote.redeemRelayerFee64), 0);
  payload.set(destAddressBuf, 8);
  payload.writeBigUInt64BE(BigInt(quote.hyperCoreParams.depositAmountUSDC64), 28);
  payload.writeBigUInt64BE(BigInt(quote.deadline64), 36);
  payload.set(permitSignatureBuf, 44);
  return payload;
}
function getSwiftToTokenHexString(quote) {
  if (quote.toChain === "sui") {
    if (!quote.toToken.verifiedAddress) {
      throw new Error("To token verified address is required for SUI");
    }
    return nativeAddressToHexString(quote.toToken.verifiedAddress, getWormholeChainIdByName("sui"));
  } else if (quote.toChain === "ton") {
    if (quote.toToken.contract === import_ethers.ZeroAddress) {
      return nativeAddressToHexString(import_web3.SystemProgram.programId.toString(), getWormholeChainIdByName("solana"));
    } else {
      if (!quote.toToken.verifiedAddress) {
        throw new Error("To token verified address is required for Ton chain");
      }
      return quote.toToken.verifiedAddress;
    }
  } else {
    if (quote.toToken.contract === import_ethers.ZeroAddress) {
      return nativeAddressToHexString(import_web3.SystemProgram.programId.toString(), getWormholeChainIdByName("solana"));
    } else {
      return nativeAddressToHexString(quote.toToken.contract, getWormholeChainIdByName(quote.toChain));
    }
  }
}
function getNormalizeFactor(toChain, quoteType) {
  if (toChain === "ton") {
    if (quoteType !== "SWIFT") {
      throw new Error("Unsupported quote type for Tonchain destination");
    }
    return Infinity;
  }
  return 8;
}
function createSwiftRandomKey(quote) {
  try {
    const idBuf = import_buffer.Buffer.from(quote.quoteId.startsWith("0x") ? quote.quoteId.substring(2) : quote.quoteId, "hex");
    if (idBuf.length < 32) {
      const randomBuf = import_web3.Keypair.generate().publicKey.toBytes();
      return import_buffer.Buffer.concat([idBuf, randomBuf.slice(0, 32 - idBuf.length)]);
    }
    return idBuf.subarray(0, 32);
  } catch (err) {
  }
  return import_web3.Keypair.generate().publicKey.toBuffer();
}

// src/api.ts
function toQueryString(params) {
  return Object.entries(params).filter(([_, value]) => value !== void 0 && value !== null && !Array.isArray(value)).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
}
async function check5xxError(res) {
  if (res.status.toString().startsWith("5")) {
    let error = new Error("Internal server error");
    try {
      const err = await res.json();
      if ((err?.code || err?.statusCode) && (err?.message || err?.msg)) {
        error = {
          code: err?.code || err?.statusCode,
          message: err?.message || err?.msg
        };
      }
    } catch (err) {
      error = new Error("Internal server error");
    }
    throw error;
  }
}
async function fetchAllTokenList(tokenStandards) {
  const query = tokenStandards ? `?standard=${tokenStandards.join(",")}` : "";
  const res = await (0, import_cross_fetch.default)(`${addresses_default.PRICE_URL}/tokens${query}`, {
    method: "GET",
    redirect: "follow"
  });
  await check5xxError(res);
  if (res.status === 200) {
    const result = await res.json();
    return result;
  }
  throw new Error("Cannot fetch Mayan tokens!");
}
async function fetchTokenList(chain, nonPortal = false, tokenStandards) {
  const queryParams = {
    chain,
    nonPortal,
    standard: tokenStandards ? tokenStandards?.join(",") : void 0
  };
  const res = await (0, import_cross_fetch.default)(`${addresses_default.PRICE_URL}/tokens?${toQueryString(queryParams)}`);
  await check5xxError(res);
  if (res.status === 200) {
    const result = await res.json();
    return result[chain];
  }
  throw new Error("Cannot fetch Mayan tokens!");
}
function generateFetchQuoteUrl(params, quoteOptions = {
  wormhole: true,
  swift: true,
  mctp: true,
  shuttle: true,
  gasless: false,
  onlyDirect: false,
  fastMctp: true,
  fullList: false,
  payload: void 0,
  monoChain: true
}) {
  const { gasDrop, referrerBps } = params;
  let slippageBps = params.slippageBps;
  if (slippageBps !== "auto" && !Number.isFinite(slippageBps)) {
    if (params.slippage === void 0 || params.slippage === null || !Number.isFinite(params.slippage)) {
      throw new Error("Either slippageBps or slippage must be provided");
    }
    slippageBps = params.slippage * 100;
  }
  const _quoteOptions = {
    wormhole: quoteOptions.wormhole !== false,
    // default to true
    swift: quoteOptions.swift !== false,
    // default to true
    mctp: quoteOptions.mctp !== false,
    // default to true
    shuttle: quoteOptions.shuttle === true,
    // default to false
    fastMctp: quoteOptions.fastMctp !== false,
    // default to true
    gasless: quoteOptions.gasless === true,
    // default to false
    onlyDirect: quoteOptions.onlyDirect === true,
    // default to false
    fullList: quoteOptions.fullList === true,
    // default to false
    payload: typeof quoteOptions.payload === "string" ? quoteOptions.payload : void 0,
    monoChain: quoteOptions.monoChain !== false
    // default to true
  };
  const queryParams = {
    ..._quoteOptions,
    solanaProgram: addresses_default.MAYAN_PROGRAM_ID,
    forwarderAddress: addresses_default.MAYAN_FORWARDER_CONTRACT,
    amountIn: !params.amountIn64 && Number.isFinite(params.amount) ? params.amount : void 0,
    amountIn64: params.amountIn64,
    fromToken: params.fromToken,
    fromChain: params.fromChain,
    toToken: params.toToken,
    toChain: params.toChain,
    slippageBps,
    referrer: params.referrer,
    referrerBps: Number.isFinite(referrerBps) ? referrerBps : void 0,
    gasDrop: Number.isFinite(gasDrop) ? gasDrop : void 0,
    destinationAddress: params.destinationAddress ?? void 0,
    sdkVersion: getSdkVersion()
  };
  const baseUrl = `${addresses_default.PRICE_URL}/quote?`;
  const queryString = toQueryString(queryParams);
  return baseUrl + queryString;
}
async function fetchQuote(params, quoteOptions = {
  swift: true,
  mctp: true,
  gasless: false,
  onlyDirect: false
}) {
  const url = generateFetchQuoteUrl(params, quoteOptions);
  const res = await (0, import_cross_fetch.default)(url, {
    method: "GET",
    redirect: "follow"
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw {
      code: result?.code || 0,
      message: result?.msg || result?.message || "Route not found",
      data: result?.data
    };
  }
  if (!checkSdkVersionSupport(result.minimumSdkVersion)) {
    throw {
      code: 9999,
      message: "Swap SDK is outdated!"
    };
  }
  return result.quotes;
}
async function getCurrentChainTime(chain) {
  const res = await (0, import_cross_fetch.default)(`${addresses_default.PRICE_URL}/clock/${chain}`, {
    method: "GET",
    redirect: "follow"
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result.clock;
}
async function getSuggestedRelayer() {
  const res = await (0, import_cross_fetch.default)(`${addresses_default.RELAYER_URL}/active-relayers?solanaProgram=${addresses_default.MAYAN_PROGRAM_ID}`, {
    method: "GET",
    redirect: "follow"
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result.suggested;
}
async function getSwapSolana(params) {
  const query = toQueryString({
    ...params,
    sdkVersion: getSdkVersion()
  });
  const res = await (0, import_cross_fetch.default)(`${addresses_default.PRICE_URL}/get-swap/solana?${query}`, {
    method: "GET",
    redirect: "follow"
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result;
}
async function getSwapSui(params) {
  const requestBody = JSON.stringify({
    ...params,
    sdkVersion: getSdkVersion()
  });
  const requestUrl = `${addresses_default.PRICE_URL}/get-swap/sui`;
  const res = await (0, import_cross_fetch.default)(requestUrl, {
    method: "POST",
    redirect: "follow",
    body: requestBody,
    headers: {
      "Content-Type": "application/json"
    }
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result;
}
async function getSwapEvm(params) {
  const query = toQueryString({
    ...params,
    sdkVersion: getSdkVersion()
  });
  const res = await (0, import_cross_fetch.default)(`${addresses_default.PRICE_URL}/get-swap/evm?${query}`, {
    method: "GET",
    redirect: "follow"
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result;
}
async function submitSwiftEvmSwap(params, signature) {
  const res = await (0, import_cross_fetch.default)(`${addresses_default.EXPLORER_URL}/submit/evm`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      ...params,
      signature
    }, (_key, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    })
  });
  await check5xxError(res);
}
async function submitSwiftSolanaSwap(signedTx, chainName) {
  const res = await (0, import_cross_fetch.default)(`${addresses_default.EXPLORER_URL}/submit/v2/svm`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      signedTx,
      chainName
    })
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result;
}
async function checkHyperCoreDeposit(destinationAddress, tokenAddress) {
  const query = toQueryString({
    destWallet: destinationAddress,
    destToken: tokenAddress,
    sdkVersion: getSdkVersion()
  });
  const res = await (0, import_cross_fetch.default)(`${addresses_default.EXPLORER_URL}/hypercore/is-allowed?${query}`, {
    method: "GET",
    redirect: "follow"
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result.allowed === true;
}
async function getEstimateGasEvm(params) {
  const res = await (0, import_cross_fetch.default)(`${addresses_default.GAS_ESTIMATE_URL}/evm`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      ...params,
      sdkVersion: getSdkVersion()
    })
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return {
    estimatedGas: BigInt(result.estimatedGas),
    gasPrice: BigInt(result.gasPrice)
  };
}
async function getSvmDurableNonce(chainName, swapperAddress) {
  const res = await (0, import_cross_fetch.default)(`${addresses_default.SWIFT_RELAYER_URL}/nonces/assign`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      chainName,
      swapperAddress,
      sdkVersion: getSdkVersion()
    })
  });
  await check5xxError(res);
  const result = await res.json();
  if (res.status !== 200 && res.status !== 201) {
    throw result;
  }
  return result;
}

// src/evm/evmSwap.ts
var import_ethers10 = require("ethers");
var import_web315 = require("@solana/web3.js");

// src/evm/MayanSwapArtifact.ts
var MayanSwapArtifact_default = {
  "_format": "hh-sol-artifact-1",
  "contractName": "MayanSwap",
  "sourceName": "src/MayanSwap.sol",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_tokenBridge",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_weth",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint16",
          "name": "emitterChainId",
          "type": "uint16"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "emitterAddress",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "name": "Redeemed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newGuardian",
          "type": "address"
        }
      ],
      "name": "changeGuardian",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimGuardian",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "payloadId",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "tokenAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "tokenChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "sourceAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "sourceChainId",
              "type": "uint16"
            },
            {
              "internalType": "uint64",
              "name": "sequence",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "amountOutMin",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "deadline",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "swapFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "redeemFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            },
            {
              "internalType": "bytes32",
              "name": "auctionAddr",
              "type": "bytes32"
            },
            {
              "internalType": "bool",
              "name": "unwrapRedeem",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "unwrapRefund",
              "type": "bool"
            }
          ],
          "internalType": "struct MayanStructs.Swap",
          "name": "s",
          "type": "tuple"
        }
      ],
      "name": "encodeSwap",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "encoded",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getWeth",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isPaused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encoded",
          "type": "bytes"
        }
      ],
      "name": "parseRedeemPayload",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "payloadId",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "relayerFee",
              "type": "uint64"
            },
            {
              "internalType": "bool",
              "name": "unwrap",
              "type": "bool"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "customPayload",
              "type": "bytes"
            }
          ],
          "internalType": "struct MayanStructs.Redeem",
          "name": "r",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encodedVm",
          "type": "bytes"
        }
      ],
      "name": "redeem",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encodedVm",
          "type": "bytes"
        }
      ],
      "name": "redeemAndUnwrap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "_pause",
          "type": "bool"
        }
      ],
      "name": "setPause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "swapFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "redeemFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            }
          ],
          "internalType": "struct MayanSwap.RelayerFees",
          "name": "relayerFees",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "mayanAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "mayanChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "auctionAddr",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "referrer",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "refundAddr",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwap.Recepient",
          "name": "recipient",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "tokenOutAddr",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "tokenOutChainId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "transferDeadline",
              "type": "uint256"
            },
            {
              "internalType": "uint64",
              "name": "swapDeadline",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "amountOutMin",
              "type": "uint64"
            },
            {
              "internalType": "bool",
              "name": "unwrap",
              "type": "bool"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "customPayload",
              "type": "bytes"
            }
          ],
          "internalType": "struct MayanSwap.Criteria",
          "name": "criteria",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "name": "swap",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address payable",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "sweepEth",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "sweepToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "swapFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "redeemFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            }
          ],
          "internalType": "struct MayanSwap.RelayerFees",
          "name": "relayerFees",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "mayanAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "mayanChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "auctionAddr",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "referrer",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "refundAddr",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwap.Recepient",
          "name": "recipient",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "tokenOutAddr",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "tokenOutChainId",
          "type": "uint16"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "transferDeadline",
              "type": "uint256"
            },
            {
              "internalType": "uint64",
              "name": "swapDeadline",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "amountOutMin",
              "type": "uint64"
            },
            {
              "internalType": "bool",
              "name": "unwrap",
              "type": "bool"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "customPayload",
              "type": "bytes"
            }
          ],
          "internalType": "struct MayanSwap.Criteria",
          "name": "criteria",
          "type": "tuple"
        }
      ],
      "name": "wrapAndSwapETH",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ]
};

// src/evm/MayanForwarderArtifact.ts
var MayanForwarderArtifact_default = {
  "_format": "hh-sol-artifact-1",
  "contractName": "MayanForwarder",
  "sourceName": "src/MayanForwarder.sol",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_guardian",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "_swapProtocols",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "_mayanProtocols",
          "type": "address[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "UnsupportedProtocol",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "protocolData",
          "type": "bytes"
        }
      ],
      "name": "ForwardedERC20",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "protocolData",
          "type": "bytes"
        }
      ],
      "name": "ForwardedEth",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "SwapAndForwarded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "swapProtocol",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "middleToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "middleAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "mayanData",
          "type": "bytes"
        }
      ],
      "name": "SwapAndForwardedERC20",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "swapProtocol",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "middleToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "middleAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "mayanData",
          "type": "bytes"
        }
      ],
      "name": "SwapAndForwardedEth",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newGuardian",
          "type": "address"
        }
      ],
      "name": "changeGuardian",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimGuardian",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanForwarder.PermitParams",
          "name": "permitParams",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "protocolData",
          "type": "bytes"
        }
      ],
      "name": "forwardERC20",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "protocolData",
          "type": "bytes"
        }
      ],
      "name": "forwardEth",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "guardian",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "mayanProtocols",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextGuardian",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address payable",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "rescueEth",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "rescueToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "enabled",
          "type": "bool"
        }
      ],
      "name": "setMayanProtocol",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "swapProtocol",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "enabled",
          "type": "bool"
        }
      ],
      "name": "setSwapProtocol",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanForwarder.PermitParams",
          "name": "permitParams",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "swapProtocol",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "swapData",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "middleToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minMiddleAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "mayanData",
          "type": "bytes"
        }
      ],
      "name": "swapAndForwardERC20",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "swapProtocol",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "swapData",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "middleToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "minMiddleAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "mayanProtocol",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "mayanData",
          "type": "bytes"
        }
      ],
      "name": "swapAndForwardEth",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "swapProtocols",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "linkReferences": {},
  "deployedLinkReferences": {}
};

// src/evm/evmSwap.ts
var import_buffer15 = require("buffer");

// src/evm/evmMctp.ts
var import_ethers2 = require("ethers");
var import_web33 = require("@solana/web3.js");

// src/evm/MayanCircleArtifact.ts
var MayanCircleArtifact_default = {
  _format: "hh-sol-artifact-1",
  contractName: "MayanCircle",
  sourceName: "src/MayanCircle.sol",
  abi: [
    {
      inputs: [
        {
          internalType: "address",
          name: "_cctpTokenMessenger",
          type: "address"
        },
        {
          internalType: "address",
          name: "_wormhole",
          type: "address"
        },
        {
          internalType: "address",
          name: "_feeManager",
          type: "address"
        },
        {
          internalType: "uint16",
          name: "_auctionChainId",
          type: "uint16"
        },
        {
          internalType: "bytes32",
          name: "_auctionAddr",
          type: "bytes32"
        },
        {
          internalType: "uint8",
          name: "_consistencyLevel",
          type: "uint8"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      inputs: [],
      name: "CallerAlreadySet",
      type: "error"
    },
    {
      inputs: [],
      name: "CallerNotSet",
      type: "error"
    },
    {
      inputs: [],
      name: "CctpReceiveFailed",
      type: "error"
    },
    {
      inputs: [],
      name: "DeadlineViolation",
      type: "error"
    },
    {
      inputs: [],
      name: "DomainAlreadySet",
      type: "error"
    },
    {
      inputs: [],
      name: "DomainNotSet",
      type: "error"
    },
    {
      inputs: [],
      name: "EmitterAlreadySet",
      type: "error"
    },
    {
      inputs: [],
      name: "EthTransferFailed",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidAction",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidAddress",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidAmountOut",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidCaller",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidDestAddr",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidDomain",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidEmitter",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidGasDrop",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidMintRecipient",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidNonce",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidOrder",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidPayload",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidProtocolFee",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidRedeemFee",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidReferrerFee",
      type: "error"
    },
    {
      inputs: [],
      name: "MintRecipientAlreadySet",
      type: "error"
    },
    {
      inputs: [],
      name: "MintRecipientNotSet",
      type: "error"
    },
    {
      inputs: [],
      name: "Paused",
      type: "error"
    },
    {
      inputs: [],
      name: "Unauthorized",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint32",
          name: "sourceDomain",
          type: "uint32"
        },
        {
          indexed: false,
          internalType: "uint64",
          name: "sourceNonce",
          type: "uint64"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "OrderFulfilled",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint32",
          name: "sourceDomain",
          type: "uint32"
        },
        {
          indexed: false,
          internalType: "uint64",
          name: "sourceNonce",
          type: "uint64"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "OrderRefunded",
      type: "event"
    },
    {
      inputs: [],
      name: "auctionAddr",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "auctionChainId",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenIn",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amountIn",
          type: "uint256"
        },
        {
          internalType: "uint64",
          name: "redeemFee",
          type: "uint64"
        },
        {
          internalType: "uint64",
          name: "gasDrop",
          type: "uint64"
        },
        {
          internalType: "bytes32",
          name: "destAddr",
          type: "bytes32"
        },
        {
          internalType: "uint32",
          name: "destDomain",
          type: "uint32"
        },
        {
          internalType: "uint8",
          name: "payloadType",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "customPayload",
          type: "bytes"
        }
      ],
      name: "bridgeWithFee",
      outputs: [
        {
          internalType: "uint64",
          name: "sequence",
          type: "uint64"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenIn",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amountIn",
          type: "uint256"
        },
        {
          internalType: "uint64",
          name: "gasDrop",
          type: "uint64"
        },
        {
          internalType: "uint256",
          name: "redeemFee",
          type: "uint256"
        },
        {
          internalType: "uint32",
          name: "destDomain",
          type: "uint32"
        },
        {
          internalType: "bytes32",
          name: "destAddr",
          type: "bytes32"
        }
      ],
      name: "bridgeWithLockedFee",
      outputs: [
        {
          internalType: "uint64",
          name: "cctpNonce",
          type: "uint64"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "cctpTokenMessenger",
      outputs: [
        {
          internalType: "contract ITokenMessenger",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      name: "chainIdToEmitter",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newGuardian",
          type: "address"
        }
      ],
      name: "changeGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "claimGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "consistencyLevel",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "tokenIn",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amountIn",
              type: "uint256"
            },
            {
              internalType: "uint64",
              name: "gasDrop",
              type: "uint64"
            },
            {
              internalType: "bytes32",
              name: "destAddr",
              type: "bytes32"
            },
            {
              internalType: "uint16",
              name: "destChain",
              type: "uint16"
            },
            {
              internalType: "bytes32",
              name: "tokenOut",
              type: "bytes32"
            },
            {
              internalType: "uint64",
              name: "minAmountOut",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "deadline",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "redeemFee",
              type: "uint64"
            },
            {
              internalType: "bytes32",
              name: "referrerAddr",
              type: "bytes32"
            },
            {
              internalType: "uint8",
              name: "referrerBps",
              type: "uint8"
            }
          ],
          internalType: "struct MayanCircle.OrderParams",
          name: "params",
          type: "tuple"
        }
      ],
      name: "createOrder",
      outputs: [
        {
          internalType: "uint64",
          name: "sequence",
          type: "uint64"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint32",
          name: "",
          type: "uint32"
        }
      ],
      name: "domainToCaller",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "feeManager",
      outputs: [
        {
          internalType: "contract IFeeManager",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "",
          type: "uint64"
        }
      ],
      name: "feeStorage",
      outputs: [
        {
          internalType: "bytes32",
          name: "destAddr",
          type: "bytes32"
        },
        {
          internalType: "uint64",
          name: "gasDrop",
          type: "uint64"
        },
        {
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "redeemFee",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "cctpMsg",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "cctpSigs",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "encodedVm",
          type: "bytes"
        },
        {
          components: [
            {
              internalType: "bytes32",
              name: "destAddr",
              type: "bytes32"
            },
            {
              internalType: "uint16",
              name: "destChainId",
              type: "uint16"
            },
            {
              internalType: "bytes32",
              name: "tokenOut",
              type: "bytes32"
            },
            {
              internalType: "uint64",
              name: "promisedAmount",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "gasDrop",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "redeemFee",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "deadline",
              type: "uint64"
            },
            {
              internalType: "bytes32",
              name: "referrerAddr",
              type: "bytes32"
            },
            {
              internalType: "uint8",
              name: "referrerBps",
              type: "uint8"
            },
            {
              internalType: "uint8",
              name: "protocolBps",
              type: "uint8"
            },
            {
              internalType: "bytes32",
              name: "driver",
              type: "bytes32"
            }
          ],
          internalType: "struct MayanCircle.FulfillParams",
          name: "params",
          type: "tuple"
        },
        {
          internalType: "address",
          name: "swapProtocol",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "swapData",
          type: "bytes"
        }
      ],
      name: "fulfillOrder",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "chainId",
          type: "uint16"
        }
      ],
      name: "getDomain",
      outputs: [
        {
          internalType: "uint32",
          name: "domain",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "guardian",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "isPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      name: "keyToMintRecipient",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "localDomain",
      outputs: [
        {
          internalType: "uint32",
          name: "",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "paused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "cctpMsg",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "cctpSigs",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "encodedVm",
          type: "bytes"
        },
        {
          components: [
            {
              internalType: "uint8",
              name: "payloadType",
              type: "uint8"
            },
            {
              internalType: "bytes32",
              name: "destAddr",
              type: "bytes32"
            },
            {
              internalType: "uint64",
              name: "gasDrop",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "redeemFee",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "burnAmount",
              type: "uint64"
            },
            {
              internalType: "bytes32",
              name: "burnToken",
              type: "bytes32"
            },
            {
              internalType: "bytes32",
              name: "customPayload",
              type: "bytes32"
            }
          ],
          internalType: "struct MayanCircle.BridgeWithFeeParams",
          name: "bridgeParams",
          type: "tuple"
        }
      ],
      name: "redeemWithFee",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "cctpMsg",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "cctpSigs",
          type: "bytes"
        },
        {
          internalType: "bytes32",
          name: "unlockerAddr",
          type: "bytes32"
        }
      ],
      name: "redeemWithLockedFee",
      outputs: [
        {
          internalType: "uint64",
          name: "sequence",
          type: "uint64"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint32",
          name: "cctpNonce",
          type: "uint32"
        },
        {
          internalType: "uint32",
          name: "cctpDomain",
          type: "uint32"
        },
        {
          internalType: "bytes32",
          name: "destAddr",
          type: "bytes32"
        },
        {
          internalType: "bytes32",
          name: "unlockerAddr",
          type: "bytes32"
        }
      ],
      name: "refineFee",
      outputs: [
        {
          internalType: "uint64",
          name: "sequence",
          type: "uint64"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "encodedVm",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "cctpMsg",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "cctpSigs",
          type: "bytes"
        },
        {
          components: [
            {
              internalType: "address",
              name: "tokenIn",
              type: "address"
            },
            {
              internalType: "uint256",
              name: "amountIn",
              type: "uint256"
            },
            {
              internalType: "uint64",
              name: "gasDrop",
              type: "uint64"
            },
            {
              internalType: "bytes32",
              name: "destAddr",
              type: "bytes32"
            },
            {
              internalType: "uint16",
              name: "destChain",
              type: "uint16"
            },
            {
              internalType: "bytes32",
              name: "tokenOut",
              type: "bytes32"
            },
            {
              internalType: "uint64",
              name: "minAmountOut",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "deadline",
              type: "uint64"
            },
            {
              internalType: "uint64",
              name: "redeemFee",
              type: "uint64"
            },
            {
              internalType: "bytes32",
              name: "referrerAddr",
              type: "bytes32"
            },
            {
              internalType: "uint8",
              name: "referrerBps",
              type: "uint8"
            }
          ],
          internalType: "struct MayanCircle.OrderParams",
          name: "orderParams",
          type: "tuple"
        },
        {
          components: [
            {
              internalType: "bytes32",
              name: "trader",
              type: "bytes32"
            },
            {
              internalType: "uint16",
              name: "sourceChainId",
              type: "uint16"
            },
            {
              internalType: "uint8",
              name: "protocolBps",
              type: "uint8"
            }
          ],
          internalType: "struct MayanCircle.ExtraParams",
          name: "extraParams",
          type: "tuple"
        }
      ],
      name: "refund",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address payable",
          name: "to",
          type: "address"
        }
      ],
      name: "rescueEth",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        }
      ],
      name: "rescueToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint8",
          name: "_consistencyLevel",
          type: "uint8"
        }
      ],
      name: "setConsistencyLevel",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "chainId",
          type: "uint16"
        },
        {
          internalType: "uint32",
          name: "domain",
          type: "uint32"
        }
      ],
      name: "setDomain",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint32",
          name: "domain",
          type: "uint32"
        },
        {
          internalType: "bytes32",
          name: "caller",
          type: "bytes32"
        }
      ],
      name: "setDomainCaller",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "chainId",
          type: "uint16"
        },
        {
          internalType: "bytes32",
          name: "emitter",
          type: "bytes32"
        }
      ],
      name: "setEmitter",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_feeManager",
          type: "address"
        }
      ],
      name: "setFeeManager",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint32",
          name: "destDomain",
          type: "uint32"
        },
        {
          internalType: "address",
          name: "tokenIn",
          type: "address"
        },
        {
          internalType: "bytes32",
          name: "mintRecipient",
          type: "bytes32"
        }
      ],
      name: "setMintRecipient",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bool",
          name: "_pause",
          type: "bool"
        }
      ],
      name: "setPause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "encodedVm",
          type: "bytes"
        },
        {
          components: [
            {
              internalType: "uint8",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "uint8",
              name: "payloadType",
              type: "uint8"
            },
            {
              internalType: "uint64",
              name: "cctpNonce",
              type: "uint64"
            },
            {
              internalType: "uint32",
              name: "cctpDomain",
              type: "uint32"
            },
            {
              internalType: "bytes32",
              name: "unlockerAddr",
              type: "bytes32"
            },
            {
              internalType: "uint64",
              name: "gasDrop",
              type: "uint64"
            }
          ],
          internalType: "struct MayanCircle.UnlockFeeMsg",
          name: "unlockMsg",
          type: "tuple"
        }
      ],
      name: "unlockFee",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "encodedVm1",
          type: "bytes"
        },
        {
          internalType: "bytes",
          name: "encodedVm2",
          type: "bytes"
        },
        {
          components: [
            {
              internalType: "uint8",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "uint8",
              name: "payloadType",
              type: "uint8"
            },
            {
              internalType: "uint64",
              name: "cctpNonce",
              type: "uint64"
            },
            {
              internalType: "uint32",
              name: "cctpDomain",
              type: "uint32"
            },
            {
              internalType: "bytes32",
              name: "unlockerAddr",
              type: "bytes32"
            },
            {
              internalType: "uint64",
              name: "gasDrop",
              type: "uint64"
            }
          ],
          internalType: "struct MayanCircle.UnlockFeeMsg",
          name: "unlockMsg",
          type: "tuple"
        },
        {
          components: [
            {
              internalType: "uint8",
              name: "action",
              type: "uint8"
            },
            {
              internalType: "uint8",
              name: "payloadType",
              type: "uint8"
            },
            {
              internalType: "uint64",
              name: "cctpNonce",
              type: "uint64"
            },
            {
              internalType: "uint32",
              name: "cctpDomain",
              type: "uint32"
            },
            {
              internalType: "bytes32",
              name: "unlockerAddr",
              type: "bytes32"
            },
            {
              internalType: "uint64",
              name: "gasDrop",
              type: "uint64"
            },
            {
              internalType: "bytes32",
              name: "destAddr",
              type: "bytes32"
            }
          ],
          internalType: "struct MayanCircle.UnlockRefinedFeeMsg",
          name: "refinedMsg",
          type: "tuple"
        }
      ],
      name: "unlockFeeRefined",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "wormhole",
      outputs: [
        {
          internalType: "contract IWormhole",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      stateMutability: "payable",
      type: "receive"
    }
  ],
  linkReferences: {},
  deployedLinkReferences: {}
};

// src/evm/evmMctp.ts
var import_buffer3 = require("buffer");

// src/cctp.ts
var import_web32 = require("@solana/web3.js");
var import_buffer2 = require("buffer");
var CCTP_TOKEN_DECIMALS = 6;
function getCCTPDomain(chain) {
  switch (chain) {
    case "ethereum":
      return 0;
    case "avalanche":
      return 1;
    case "optimism":
      return 2;
    case "arbitrum":
      return 3;
    case "solana":
      return 5;
    case "base":
      return 6;
    case "polygon":
      return 7;
    case "sui":
      return 8;
    case "unichain":
      return 10;
    case "linea":
      return 11;
    case "sonic":
      return 13;
    case "hyperevm":
      return 19;
    case "monad":
      return 15;
    default:
      throw new Error("unsupported chain for cctp");
  }
}
function getCCTPBridgePDAs(mint, destinationChain) {
  const cctpCoreProgramId = new import_web32.PublicKey(addresses_default.CCTP_CORE_PROGRAM_ID);
  const cctpTokenProgramId = new import_web32.PublicKey(addresses_default.CCTP_TOKEN_PROGRAM_ID);
  const [messageTransmitter] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("message_transmitter")],
    cctpCoreProgramId
  );
  const [senderAuthority] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("sender_authority")],
    cctpTokenProgramId
  );
  const [localToken] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("local_token"), mint.toBytes()],
    cctpTokenProgramId
  );
  const [tokenMessenger] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("token_messenger")],
    cctpTokenProgramId
  );
  const [tokenMinter] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("token_minter")],
    cctpTokenProgramId
  );
  const destinationDomain = getCCTPDomain(destinationChain);
  const [remoteTokenMessengerKey] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("remote_token_messenger"), import_buffer2.Buffer.from(destinationDomain.toString())],
    cctpTokenProgramId
  );
  const [eventAuthCore] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("__event_authority")],
    cctpCoreProgramId
  );
  const [eventAuthToken] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("__event_authority")],
    cctpTokenProgramId
  );
  return {
    messageTransmitter,
    senderAuthority,
    remoteTokenMessengerKey,
    tokenMessenger,
    tokenMinter,
    eventAuthToken,
    eventAuthCore,
    localToken
  };
}
function getCCTPV2BridgePDAs(mint, destinationChain, ledger, trader) {
  const cctpV2CoreProgramId = new import_web32.PublicKey(addresses_default.CCTPV2_CORE_PROGRAM_ID);
  const cctpV2TokenProgramId = new import_web32.PublicKey(addresses_default.CCTPV2_TOKEN_PROGRAM_ID);
  const [messageTransmitter] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("message_transmitter")],
    cctpV2CoreProgramId
  );
  const [senderAuthority] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("sender_authority")],
    cctpV2TokenProgramId
  );
  const [localToken] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("local_token"), mint.toBytes()],
    cctpV2TokenProgramId
  );
  const [tokenMessenger] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("token_messenger")],
    cctpV2TokenProgramId
  );
  const [tokenMinter] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("token_minter")],
    cctpV2TokenProgramId
  );
  const destinationDomain = getCCTPDomain(destinationChain);
  const [remoteTokenMessengerKey] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("remote_token_messenger"), import_buffer2.Buffer.from(destinationDomain.toString())],
    cctpV2TokenProgramId
  );
  const [eventAuthCore] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("__event_authority")],
    cctpV2CoreProgramId
  );
  const [eventAuthToken] = import_web32.PublicKey.findProgramAddressSync(
    [import_buffer2.Buffer.from("__event_authority")],
    cctpV2TokenProgramId
  );
  const [cctpDenyListAccount] = import_web32.PublicKey.findProgramAddressSync(
    [
      import_buffer2.Buffer.from("denylist_account"),
      ledger.toBytes()
    ],
    cctpV2TokenProgramId
  );
  const [realDenyListAccount] = import_web32.PublicKey.findProgramAddressSync(
    [
      import_buffer2.Buffer.from("denylist_account"),
      trader.toBytes()
    ],
    cctpV2TokenProgramId
  );
  return {
    messageTransmitter,
    senderAuthority,
    remoteTokenMessengerKey,
    tokenMessenger,
    tokenMinter,
    eventAuthToken,
    eventAuthCore,
    localToken,
    cctpDenyListAccount,
    realDenyListAccount
  };
}

// src/evm/evmMctp.ts
function getEvmMctpBridgeParams(quote, destinationAddress, signerChainId, customPayload) {
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  const destChainId = getWormholeChainIdByName(quote.toChain);
  if (sourceChainId !== signerWormholeChainId) {
    throw new Error(`Signer chain id(${Number(signerChainId)}) and quote from chain are not same! ${sourceChainId} !== ${signerWormholeChainId}`);
  }
  const lockFee = quote.cheaperChain === quote.fromChain;
  if (lockFee && !!customPayload) {
    throw new Error("Bridge lock fee cannot have custom payload");
  }
  const destinationAddressHex = nativeAddressToHexString(destinationAddress, destChainId);
  const redeemFee = getAmountOfFractionalAmount(quote.redeemRelayerFee, CCTP_TOKEN_DECIMALS);
  const gasDrop = getAmountOfFractionalAmount(quote.gasDrop, Math.min(getGasDecimal(quote.toChain), 8));
  const amountIn = BigInt(quote.effectiveAmountIn64);
  const destDomain = getCCTPDomain(quote.toChain);
  if (!quote.mctpMayanContract) {
    throw new Error("MCTP contract address is missing");
  }
  const contractAddress = quote.mctpMayanContract;
  if (quote.toChain === "solana" && lockFee) {
    throw new Error("Cannot lock fee for transfer to solana");
  }
  let bridgeFee = getAmountOfFractionalAmount(
    quote.bridgeFee,
    getGasDecimal(quote.fromChain)
  );
  if (lockFee) {
    bridgeFee = BigInt(0);
  }
  return {
    lockFee,
    tokenIn: quote.mctpInputContract,
    amountIn,
    redeemFee,
    gasDrop,
    destAddr: destinationAddressHex,
    destDomain,
    payloadType: customPayload ? MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD : MCTP_PAYLOAD_TYPE_DEFAULT,
    customPayload: customPayload ? `0x${import_buffer3.Buffer.from(customPayload).toString("hex")}` : "0x",
    bridgeFee,
    contractAddress
  };
}
function getEvmMctpBridgeTxPayload(quote, destinationAddress, signerChainId, payload) {
  const params = getEvmMctpBridgeParams(
    quote,
    destinationAddress,
    signerChainId,
    payload
  );
  const {
    contractAddress,
    tokenIn,
    amountIn,
    destAddr,
    lockFee,
    redeemFee,
    gasDrop,
    destDomain,
    customPayload,
    payloadType,
    bridgeFee
  } = params;
  const mctpContract = new import_ethers2.Contract(contractAddress, MayanCircleArtifact_default.abi);
  let data;
  let value;
  if (lockFee) {
    data = mctpContract.interface.encodeFunctionData(
      "bridgeWithLockedFee",
      [tokenIn, amountIn, gasDrop, redeemFee, destDomain, destAddr]
    );
  } else {
    data = mctpContract.interface.encodeFunctionData(
      "bridgeWithFee",
      [tokenIn, amountIn, redeemFee, gasDrop, destAddr, destDomain, payloadType, customPayload]
    );
  }
  value = (0, import_ethers2.toBeHex)(bridgeFee);
  return {
    to: contractAddress,
    data,
    value,
    _params: params
  };
}
function getEvmMctpCreateOrderParams(quote, destinationAddress, referrerAddress, signerChainId) {
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  const destChainId = getWormholeChainIdByName(quote.toChain);
  if (sourceChainId !== signerWormholeChainId) {
    throw new Error(`Signer chain id(${Number(signerChainId)}) and quote from chain are not same! ${sourceChainId} !== ${signerWormholeChainId}`);
  }
  if (!quote.mctpMayanContract) {
    throw new Error("MCTP contract address is missing");
  }
  const contractAddress = quote.mctpMayanContract;
  const destinationAddressHex = nativeAddressToHexString(destinationAddress, destChainId);
  let referrerHex;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(
      referrerAddress,
      destChainId
    );
  } else {
    referrerHex = nativeAddressToHexString(
      import_web33.SystemProgram.programId.toString(),
      getWormholeChainIdByName("solana")
    );
  }
  const redeemFee = getAmountOfFractionalAmount(quote.redeemRelayerFee, CCTP_TOKEN_DECIMALS);
  const gasDrop = getAmountOfFractionalAmount(quote.gasDrop, Math.min(getGasDecimal(quote.toChain), 8));
  let amountIn = BigInt(quote.effectiveAmountIn64);
  const minAmountOut = getAmountOfFractionalAmount(
    quote.minAmountOut,
    Math.min(8, quote.toToken.decimals)
  );
  const deadline = BigInt(quote.deadline64);
  if (quote.toChain === "sui" && !quote.toToken.verifiedAddress) {
    throw new Error("To token verified address is missing for SUI");
  }
  const tokenOut = quote.toToken.contract === import_ethers2.ZeroAddress ? nativeAddressToHexString(import_web33.SystemProgram.programId.toString(), getWormholeChainIdByName("solana")) : nativeAddressToHexString(
    quote.toChain === "sui" ? quote.toToken.verifiedAddress : quote.toToken.contract,
    quote.toToken.wChainId
  );
  return {
    params: {
      tokenIn: quote.mctpInputContract,
      amountIn,
      gasDrop,
      destAddr: destinationAddressHex,
      destChain: destChainId,
      tokenOut,
      minAmountOut,
      deadline,
      redeemFee,
      referrerAddr: referrerHex,
      referrerBps: quote.referrerBps || 0
    },
    bridgeFee: getAmountOfFractionalAmount(quote.bridgeFee, getGasDecimal(quote.fromChain)),
    contractAddress
  };
}
function getEvmMctpCreateOrderTxPayload(quote, destinationAddress, referrerAddress, signerChainId) {
  const orderParams = getEvmMctpCreateOrderParams(
    quote,
    destinationAddress,
    referrerAddress,
    signerChainId
  );
  const {
    contractAddress,
    params,
    bridgeFee
  } = orderParams;
  const mctpContract = new import_ethers2.Contract(contractAddress, MayanCircleArtifact_default.abi);
  const data = mctpContract.interface.encodeFunctionData(
    "createOrder",
    [params]
  );
  const value = (0, import_ethers2.toBeHex)(bridgeFee);
  return {
    to: contractAddress,
    data,
    value,
    _params: orderParams
  };
}
async function getMctpFromEvmTxPayload(quote, destinationAddress, referrerAddress, signerChainId, permit, payload) {
  if (quote.type !== "MCTP") {
    throw new Error("Quote type is not MCTP");
  }
  if (!Number.isFinite(Number(signerChainId))) {
    throw new Error("Invalid signer chain id");
  }
  signerChainId = Number(signerChainId);
  const _permit = permit || ZeroPermit;
  const forwarder = new import_ethers2.Contract(addresses_default.MAYAN_FORWARDER_CONTRACT, MayanForwarderArtifact_default.abi);
  const bridgeFee = getAmountOfFractionalAmount(
    quote.bridgeFee,
    getGasDecimal(quote.fromChain)
  );
  let value = (0, import_ethers2.toBeHex)(bridgeFee);
  if (quote.fromToken.contract === quote.mctpInputContract) {
    if (quote.hasAuction) {
      if (!Number(quote.deadline64)) {
        throw new Error("MCTP order requires timeout");
      }
      const mctpPayloadIx = getEvmMctpCreateOrderTxPayload(
        quote,
        destinationAddress,
        referrerAddress,
        signerChainId
      );
      const forwarderMethod = "forwardERC20";
      const forwarderParams = [
        quote.fromToken.contract,
        mctpPayloadIx._params.params.amountIn,
        _permit,
        mctpPayloadIx._params.contractAddress,
        mctpPayloadIx.data
      ];
      const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
      return {
        data,
        to: addresses_default.MAYAN_FORWARDER_CONTRACT,
        value: (0, import_ethers2.toBeHex)(value),
        chainId: signerChainId,
        _forwarder: {
          method: forwarderMethod,
          params: forwarderParams
        }
      };
    } else {
      const mctpPayloadIx = getEvmMctpBridgeTxPayload(
        quote,
        destinationAddress,
        signerChainId,
        payload
      );
      const forwarderMethod = "forwardERC20";
      const forwarderParams = [
        quote.fromToken.contract,
        mctpPayloadIx._params.amountIn,
        _permit,
        mctpPayloadIx._params.contractAddress,
        mctpPayloadIx.data
      ];
      const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
      return {
        data,
        to: addresses_default.MAYAN_FORWARDER_CONTRACT,
        value: (0, import_ethers2.toBeHex)(value),
        chainId: signerChainId,
        _forwarder: {
          method: forwarderMethod,
          params: forwarderParams
        }
      };
    }
  } else {
    const { minMiddleAmount } = quote;
    const { swapRouterCalldata, swapRouterAddress } = await getSwapEvm({
      referrerAddress: referrerAddress || void 0,
      fromToken: quote.fromToken.contract,
      slippageBps: quote.slippageBps,
      forwarderAddress: addresses_default.MAYAN_FORWARDER_CONTRACT,
      amountIn64: quote.effectiveAmountIn64,
      chainName: quote.fromChain,
      middleToken: quote.mctpInputContract
    });
    if (!minMiddleAmount) {
      throw new Error("MCTP swap requires middle amount, router address and calldata");
    }
    if (quote.hasAuction) {
      if (!Number(quote.deadline64)) {
        throw new Error("MCTP order requires timeout");
      }
      const mctpPayloadIx = getEvmMctpCreateOrderTxPayload(
        quote,
        destinationAddress,
        referrerAddress,
        signerChainId
      );
      if (!quote.minMiddleAmount) {
        throw new Error("MCTP swap requires middle amount");
      }
      const minMiddleAmount2 = getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS);
      if (quote.fromToken.contract === import_ethers2.ZeroAddress) {
        let amountIn = mctpPayloadIx._params.params.amountIn;
        if (amountIn <= bridgeFee) {
          throw new Error("Amount in is less than bridge fee");
        }
        if (bridgeFee !== BigInt(0)) {
          amountIn -= bridgeFee;
        }
        value = (0, import_ethers2.toBeHex)(mctpPayloadIx._params.params.amountIn);
        const forwarderMethod = "swapAndForwardEth";
        const forwarderParams = [
          amountIn,
          swapRouterAddress,
          swapRouterCalldata,
          quote.mctpInputContract,
          minMiddleAmount2,
          mctpPayloadIx._params.contractAddress,
          mctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers2.toBeHex)(value),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      } else {
        const forwarderMethod = "swapAndForwardERC20";
        const forwarderParams = [
          quote.fromToken.contract,
          mctpPayloadIx._params.params.amountIn,
          _permit,
          swapRouterAddress,
          swapRouterCalldata,
          quote.mctpInputContract,
          minMiddleAmount2,
          mctpPayloadIx._params.contractAddress,
          mctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers2.toBeHex)(value),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      }
    } else {
      const mctpPayloadIx = getEvmMctpBridgeTxPayload(
        quote,
        destinationAddress,
        signerChainId,
        payload
      );
      if (!quote.minMiddleAmount) {
        throw new Error("MCTP swap requires middle amount");
      }
      const minMiddleAmount2 = getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS);
      if (quote.fromToken.contract === import_ethers2.ZeroAddress) {
        let amountIn = mctpPayloadIx._params.amountIn;
        if (amountIn <= bridgeFee) {
          throw new Error("Amount in is less than bridge fee");
        }
        if (bridgeFee !== BigInt(0)) {
          amountIn -= bridgeFee;
        }
        value = (0, import_ethers2.toBeHex)(mctpPayloadIx._params.amountIn);
        const forwarderMethod = "swapAndForwardEth";
        const forwarderParams = [
          amountIn,
          swapRouterAddress,
          swapRouterCalldata,
          quote.mctpInputContract,
          minMiddleAmount2,
          mctpPayloadIx._params.contractAddress,
          mctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers2.toBeHex)(value),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      } else {
        const forwarderMethod = "swapAndForwardERC20";
        const forwarderParams = [
          quote.fromToken.contract,
          mctpPayloadIx._params.amountIn,
          _permit,
          swapRouterAddress,
          swapRouterCalldata,
          quote.mctpInputContract,
          minMiddleAmount2,
          mctpPayloadIx._params.contractAddress,
          mctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers2.toBeHex)(value),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      }
    }
  }
}

// src/evm/evmSwift.ts
var import_ethers6 = require("ethers");
var import_web312 = require("@solana/web3.js");

// src/evm/MayanSwiftV2Artifact.ts
var MayanSwiftV2Artifact_default = {
  "_format": "hh-sol-artifact-1",
  "contractName": "MayanSwift",
  "sourceName": "src/MayanSwift.sol",
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_wormhole",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_refundVerifier",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_refundEmitterChainId",
          "type": "uint16",
          "internalType": "uint16"
        },
        {
          "name": "_refundEmitterAddr",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "_feeManager",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_rescueVault",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "receive",
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "changeGuardian",
      "inputs": [
        {
          "name": "newGuardian",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "claimGuardian",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "createOrderWithEth",
      "inputs": [
        {
          "name": "params",
          "type": "tuple",
          "internalType": "struct OrderParams",
          "components": [
            {
              "name": "payloadType",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "trader",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "destAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "destChainId",
              "type": "uint16",
              "internalType": "uint16"
            },
            {
              "name": "referrerAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "tokenOut",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "minAmountOut",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "gasDrop",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "cancelFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "refundFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "deadline",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "referrerBps",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "auctionMode",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "random",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "name": "customPayload",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "orderHash",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "createOrderWithSig",
      "inputs": [
        {
          "name": "tokenIn",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amountIn",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "params",
          "type": "tuple",
          "internalType": "struct OrderParams",
          "components": [
            {
              "name": "payloadType",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "trader",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "destAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "destChainId",
              "type": "uint16",
              "internalType": "uint16"
            },
            {
              "name": "referrerAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "tokenOut",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "minAmountOut",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "gasDrop",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "cancelFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "refundFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "deadline",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "referrerBps",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "auctionMode",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "random",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "name": "customPayload",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "submissionFee",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "signedOrderHash",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "permitParams",
          "type": "tuple",
          "internalType": "struct PermitParams",
          "components": [
            {
              "name": "value",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "deadline",
              "type": "uint256",
              "internalType": "uint256"
            },
            {
              "name": "v",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "r",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "s",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "orderHash",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "createOrderWithToken",
      "inputs": [
        {
          "name": "tokenIn",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amountIn",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "params",
          "type": "tuple",
          "internalType": "struct OrderParams",
          "components": [
            {
              "name": "payloadType",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "trader",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "destAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "destChainId",
              "type": "uint16",
              "internalType": "uint16"
            },
            {
              "name": "referrerAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "tokenOut",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "minAmountOut",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "gasDrop",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "cancelFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "refundFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "deadline",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "referrerBps",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "auctionMode",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "random",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        },
        {
          "name": "customPayload",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "orderHash",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "emitters",
      "inputs": [
        {
          "name": "",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "feeManager",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IFeeManager"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getOrders",
      "inputs": [
        {
          "name": "orderHashes",
          "type": "bytes32[]",
          "internalType": "bytes32[]"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "tuple[]",
          "internalType": "struct Order[]",
          "components": [
            {
              "name": "status",
              "type": "uint8",
              "internalType": "enum Status"
            },
            {
              "name": "amountIn",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "destChainId",
              "type": "uint16",
              "internalType": "uint16"
            }
          ]
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "guardian",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "nextGuardian",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "orders",
      "inputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "outputs": [
        {
          "name": "status",
          "type": "uint8",
          "internalType": "enum Status"
        },
        {
          "name": "amountIn",
          "type": "uint64",
          "internalType": "uint64"
        },
        {
          "name": "destChainId",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "parseFulfillPayload",
      "inputs": [
        {
          "name": "encoded",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "fulfillMsg",
          "type": "tuple",
          "internalType": "struct FulfillMsg",
          "components": [
            {
              "name": "action",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "orderHash",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "driver",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "promisedAmount",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "penaltyPeriod",
              "type": "uint16",
              "internalType": "uint16"
            }
          ]
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "parseRefundPayload",
      "inputs": [
        {
          "name": "encoded",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "refundMsg",
          "type": "tuple",
          "internalType": "struct RefundMsg",
          "components": [
            {
              "name": "action",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "orderHash",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "srcChainId",
              "type": "uint16",
              "internalType": "uint16"
            },
            {
              "name": "tokenIn",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "trader",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "canceler",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "cancelFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "refundFee",
              "type": "uint64",
              "internalType": "uint64"
            }
          ]
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "parseRefundVerifierPayload",
      "inputs": [
        {
          "name": "encoded",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "verifier",
          "type": "tuple",
          "internalType": "struct RefundVerifier",
          "components": [
            {
              "name": "action",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "verifier",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "emitterChainId",
              "type": "uint16",
              "internalType": "uint16"
            },
            {
              "name": "emitterAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            }
          ]
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "parseRescuePayload",
      "inputs": [
        {
          "name": "encoded",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "rescueMsg",
          "type": "tuple",
          "internalType": "struct RescueMsg",
          "components": [
            {
              "name": "action",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "orderHash",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "orderStatus",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "token",
              "type": "address",
              "internalType": "address"
            },
            {
              "name": "amount",
              "type": "uint64",
              "internalType": "uint64"
            }
          ]
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "parseUnlockPayload",
      "inputs": [
        {
          "name": "encoded",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [
        {
          "name": "unlockMsg",
          "type": "tuple",
          "internalType": "struct UnlockMsg",
          "components": [
            {
              "name": "action",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "orderHash",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "srcChainId",
              "type": "uint16",
              "internalType": "uint16"
            },
            {
              "name": "tokenIn",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "referrerAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "referrerBps",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "protocolBps",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "unlockReceiver",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "driver",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "fulfillTime",
              "type": "uint64",
              "internalType": "uint64"
            }
          ]
        }
      ],
      "stateMutability": "pure"
    },
    {
      "type": "function",
      "name": "paused",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "refundEmitterAddr",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "refundEmitterChainId",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint16",
          "internalType": "uint16"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "refundOrder",
      "inputs": [
        {
          "name": "encodedVm",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "fast",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "refundVerifier",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IWormhole"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "rescue",
      "inputs": [
        {
          "name": "encodedVm",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "rescueVault",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "setEmitters",
      "inputs": [
        {
          "name": "chainIds",
          "type": "uint16[]",
          "internalType": "uint16[]"
        },
        {
          "name": "addresses",
          "type": "bytes32[]",
          "internalType": "bytes32[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setFeeManager",
      "inputs": [
        {
          "name": "_feeManager",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setPause",
      "inputs": [
        {
          "name": "_pause",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setRefundVerifier",
      "inputs": [
        {
          "name": "encodedVm",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unlockBatch",
      "inputs": [
        {
          "name": "encodedVm",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "indexes",
          "type": "uint16[]",
          "internalType": "uint16[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unlockCompressedBatch",
      "inputs": [
        {
          "name": "encodedVm",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "encodedPayload",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "indexes",
          "type": "uint16[]",
          "internalType": "uint16[]"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "unlockSingle",
      "inputs": [
        {
          "name": "encodedVm",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "wormhole",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract IWormhole"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "event",
      "name": "OrderCanceled",
      "inputs": [
        {
          "name": "key",
          "type": "bytes32",
          "indexed": false,
          "internalType": "bytes32"
        },
        {
          "name": "sequence",
          "type": "uint64",
          "indexed": false,
          "internalType": "uint64"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OrderCreated",
      "inputs": [
        {
          "name": "key",
          "type": "bytes32",
          "indexed": false,
          "internalType": "bytes32"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OrderFulfilled",
      "inputs": [
        {
          "name": "key",
          "type": "bytes32",
          "indexed": false,
          "internalType": "bytes32"
        },
        {
          "name": "sequence",
          "type": "uint64",
          "indexed": false,
          "internalType": "uint64"
        },
        {
          "name": "netAmount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OrderRefunded",
      "inputs": [
        {
          "name": "key",
          "type": "bytes32",
          "indexed": false,
          "internalType": "bytes32"
        },
        {
          "name": "netAmount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OrderUnlocked",
      "inputs": [
        {
          "name": "key",
          "type": "bytes32",
          "indexed": false,
          "internalType": "bytes32"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "DuplicateOrder",
      "inputs": []
    },
    {
      "type": "error",
      "name": "EmitterAddressExists",
      "inputs": []
    },
    {
      "type": "error",
      "name": "FeesTooHigh",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidAction",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidBatchIndex",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidBpsFee",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidDestChain",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidEmitterAddress",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidEmitterChain",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidEvmAddr",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidGasDrop",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidOrderStatus",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidPayload",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidPayloadLength",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidSrcChain",
      "inputs": []
    },
    {
      "type": "error",
      "name": "OrderNotExists",
      "inputs": [
        {
          "name": "orderHash",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ]
    },
    {
      "type": "error",
      "name": "Paused",
      "inputs": []
    },
    {
      "type": "error",
      "name": "SmallAmountIn",
      "inputs": []
    },
    {
      "type": "error",
      "name": "Unauthorized",
      "inputs": []
    }
  ],
  "linkReferences": {},
  "deployedLinkReferences": {}
};

// src/evm/MayanSwiftArtifact.ts
var MayanSwiftArtifact_default = {
  "_format": "hh-sol-artifact-1",
  "contractName": "MayanSwift",
  "sourceName": "src/MayanSwift.sol",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_wormhole",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_feeManager",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "_auctionChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "_auctionAddr",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_solanaEmitter",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "_consistencyLevel",
          "type": "uint8"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "DeadlineViolation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DuplicateOrder",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FeesTooHigh",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAction",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAuctionMode",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBpsFee",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidContractSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidDestChain",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEmitterAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEmitterChain",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEvmAddr",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidGasDrop",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidOrderHash",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidOrderStatus",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignatureLength",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSigner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSrcChain",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidWormholeFee",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OrderNotExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Paused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SmallAmountIn",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "name": "OrderCanceled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "OrderCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "netAmount",
          "type": "uint256"
        }
      ],
      "name": "OrderFulfilled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "netAmount",
          "type": "uint256"
        }
      ],
      "name": "OrderRefunded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "OrderUnlocked",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "auctionAddr",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "auctionChainId",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "tokenIn",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "trader",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "tokenOut",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "minAmountOut",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "cancelFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "deadline",
              "type": "uint64"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "referrerAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "referrerBps",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "auctionMode",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "random",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwift.OrderParams",
          "name": "params",
          "type": "tuple"
        },
        {
          "internalType": "uint16",
          "name": "srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "uint8",
          "name": "protocolBps",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "canceler",
          "type": "bytes32"
        }
      ],
      "name": "cancelOrder",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newGuardian",
          "type": "address"
        }
      ],
      "name": "changeGuardian",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimGuardian",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "consistencyLevel",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "trader",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "tokenOut",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "minAmountOut",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "cancelFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "deadline",
              "type": "uint64"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "referrerAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "referrerBps",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "auctionMode",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "random",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwift.OrderParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "createOrderWithEth",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "trader",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "tokenOut",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "minAmountOut",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "cancelFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "deadline",
              "type": "uint64"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "referrerAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "referrerBps",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "auctionMode",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "random",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwift.OrderParams",
          "name": "params",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signedOrderHash",
          "type": "bytes"
        }
      ],
      "name": "createOrderWithSig",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "trader",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "tokenOut",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "minAmountOut",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "cancelFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "deadline",
              "type": "uint64"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "referrerAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "referrerBps",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "auctionMode",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "random",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwift.OrderParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "createOrderWithToken",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeManager",
      "outputs": [
        {
          "internalType": "contract IFeeManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fulfillAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "encodedVm",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "recepient",
          "type": "bytes32"
        },
        {
          "internalType": "bool",
          "name": "batch",
          "type": "bool"
        }
      ],
      "name": "fulfillOrder",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fulfillAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "tokenIn",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "protocolBps",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "trader",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "tokenOut",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "minAmountOut",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "cancelFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "deadline",
              "type": "uint64"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "referrerAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "referrerBps",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "auctionMode",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "random",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwift.OrderParams",
          "name": "params",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "recepient",
          "type": "bytes32"
        },
        {
          "internalType": "bool",
          "name": "batch",
          "type": "bool"
        }
      ],
      "name": "fulfillSimple",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "guardian",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextGuardian",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "orders",
      "outputs": [
        {
          "internalType": "enum MayanSwift.Status",
          "name": "status",
          "type": "uint8"
        },
        {
          "internalType": "uint64",
          "name": "amountIn",
          "type": "uint64"
        },
        {
          "internalType": "uint16",
          "name": "destChainId",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encoded",
          "type": "bytes"
        }
      ],
      "name": "parseFulfillPayload",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "orderHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "destChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "destAddr",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "driver",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "tokenOut",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "promisedAmount",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "gasDrop",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "deadline",
              "type": "uint64"
            },
            {
              "internalType": "bytes32",
              "name": "referrerAddr",
              "type": "bytes32"
            },
            {
              "internalType": "uint8",
              "name": "referrerBps",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "protocolBps",
              "type": "uint8"
            },
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "tokenIn",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwift.FulfillMsg",
          "name": "fulfillMsg",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encoded",
          "type": "bytes"
        }
      ],
      "name": "parseRefundPayload",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "orderHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "tokenIn",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "canceler",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "cancelFee",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "refundFee",
              "type": "uint64"
            }
          ],
          "internalType": "struct MayanSwift.RefundMsg",
          "name": "refundMsg",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encoded",
          "type": "bytes"
        }
      ],
      "name": "parseUnlockPayload",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "orderHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint16",
              "name": "srcChainId",
              "type": "uint16"
            },
            {
              "internalType": "bytes32",
              "name": "tokenIn",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "recipient",
              "type": "bytes32"
            }
          ],
          "internalType": "struct MayanSwift.UnlockMsg",
          "name": "unlockMsg",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "orderHashes",
          "type": "bytes32[]"
        }
      ],
      "name": "postBatch",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encodedVm",
          "type": "bytes"
        }
      ],
      "name": "refundOrder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "_consistencyLevel",
          "type": "uint8"
        }
      ],
      "name": "setConsistencyLevel",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_feeManager",
          "type": "address"
        }
      ],
      "name": "setFeeManager",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "_pause",
          "type": "bool"
        }
      ],
      "name": "setPause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "solanaEmitter",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encodedVm",
          "type": "bytes"
        }
      ],
      "name": "unlockBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "unlockMsgs",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "action",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "orderHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "srcChainId",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "tokenIn",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "recipient",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "encodedVm",
          "type": "bytes"
        }
      ],
      "name": "unlockSingle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wormhole",
      "outputs": [
        {
          "internalType": "contract IWormhole",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "linkReferences": {},
  "deployedLinkReferences": {}
};

// src/solana/utils.ts
var import_web34 = require("@solana/web3.js");
var import_buffer5 = require("buffer");
var import_buffer_layout = require("@solana/buffer-layout");
var import_sha2 = require("@noble/hashes/sha2");
var import_bs58 = __toESM(require("bs58"));

// src/solana/jupiter.ts
var import_buffer4 = require("buffer");
function decodeJupiterV6InsArgs(args) {
  console.log("new decodeJupiterV6InsArgs called");
  const routeV2DiscHex = "bb64facc31c4af14";
  const sharedAccountsRouteV2DiscHex = "d19853937cfed8e9";
  const discHex = import_buffer4.Buffer.from(args.subarray(0, 8)).toString("hex").toLowerCase();
  const data = import_buffer4.Buffer.from(args.subarray(8));
  if (discHex === routeV2DiscHex) {
    const in_amount = data.readBigUInt64LE(0);
    const quoted_out_amount = data.readBigUInt64LE(8);
    const slippage_bps = data.readUInt16LE(16);
    const platform_fee_bps = data.readUInt16LE(18);
    return {
      in_amount,
      quoted_out_amount,
      slippage_bps,
      platform_fee_bps
    };
  } else if (discHex === sharedAccountsRouteV2DiscHex) {
    const in_amount = data.readBigUInt64LE(1);
    const quoted_out_amount = data.readBigUInt64LE(9);
    const slippage_bps = data.readUInt16LE(17);
    const platform_fee_bps = data.readUInt16LE(19);
    return {
      in_amount,
      quoted_out_amount,
      slippage_bps,
      platform_fee_bps
    };
  } else {
    throw new Error(`Unsupported Jupiter V6 instruction discriminator: ${discHex}`);
  }
}

// src/solana/utils.ts
var cachedConnections = {};
function getConnection(rpcUrl) {
  cachedConnections[rpcUrl] ??= new import_web34.Connection(rpcUrl);
  return new import_web34.Connection(rpcUrl);
}
async function submitTransactionWithRetry({
  trx,
  connection,
  errorChance,
  extraRpcs,
  options,
  rate = 4
}) {
  let signature = null;
  let errorNumber = 0;
  let latestError;
  const connections = [connection].concat(extraRpcs.map(getConnection));
  for (let i = 0; i < rate; i++) {
    if (signature) {
      try {
        const status = await Promise.any(connections.map((c) => c.getSignatureStatus(signature)));
        console.log("Transaction status check attempt", i, status?.value);
        if (status && status.value) {
          if (status.value.err) {
            if (errorNumber >= errorChance) {
              return {
                signature,
                serializedTrx: trx
              };
            }
            errorNumber++;
          } else if (status.value.confirmationStatus === "confirmed" || status.value.confirmationStatus === "finalized") {
            return {
              signature,
              serializedTrx: trx
            };
          }
        }
      } catch (err) {
        console.error(err);
      }
    }
    const sendRequests = connections.map((c) => c.sendRawTransaction(trx, options));
    console.log("Submitting transaction, attempt", i + 1);
    if (!signature) {
      try {
        signature = await Promise.any(sendRequests);
        console.log("Transaction submitted to fetch signature, signature:", signature);
      } catch (err) {
        console.error("Transaction not submitted to fetch signature, remaining attempts:", rate - i - 1);
        latestError = err;
        try {
          console.log("now trying to send to individual connections");
          const simulated = await connection.sendRawTransaction(trx);
        } catch (err2) {
          console.error("Simulation individual connections failed", err2);
          console.error("Transaction not submitted, remaining attempts:", rate - i - 1);
          console.error(err2);
          if (err2 && typeof err2 === "object" && "transactionMessage" in err2 && typeof err2.transactionMessage === "string" && err2.transactionMessage.indexOf("transaction has already been processed")) {
            if (signature) {
              return {
                signature,
                serializedTrx: trx
              };
            } else {
              throw new Error("Transaction has already been processed, but no signature found");
            }
          }
          latestError = err2;
        }
      }
    }
    await wait(3e3);
  }
  if (!signature) {
    if (latestError) {
      console.error("Failed to submit transaction");
      throw latestError;
    } else {
      throw new Error("Failed to submit transaction, not landed on any signature");
    }
  }
  return {
    signature,
    serializedTrx: trx
  };
}
function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID), associatedTokenProgramId = new import_web34.PublicKey(addresses_default.ASSOCIATED_TOKEN_PROGRAM_ID)) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedToken, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: import_web34.SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: programId, isSigner: false, isWritable: false },
    { pubkey: import_web34.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  return new import_web34.TransactionInstruction({
    keys,
    programId: associatedTokenProgramId,
    data: import_buffer5.Buffer.from([1])
  });
}
var TOKEN_ACCOUNT_LEN = 165;
async function createInitializeRandomTokenAccountInstructions(connection, payer, mint, owner, keyPair, programId = new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID)) {
  const instructions = [];
  const rentLamports = await connection.getMinimumBalanceForRentExemption(TOKEN_ACCOUNT_LEN);
  instructions.push(import_web34.SystemProgram.createAccount({
    fromPubkey: payer,
    newAccountPubkey: keyPair.publicKey,
    lamports: rentLamports,
    space: TOKEN_ACCOUNT_LEN,
    programId
  }));
  instructions.push(new import_web34.TransactionInstruction({
    keys: [
      { pubkey: keyPair.publicKey, isWritable: true, isSigner: false },
      { pubkey: mint, isWritable: false, isSigner: false },
      { pubkey: owner, isWritable: false, isSigner: false },
      { pubkey: import_web34.SYSVAR_RENT_PUBKEY, isWritable: false, isSigner: false }
    ],
    programId,
    data: import_buffer5.Buffer.from([1])
  }));
  return instructions;
}
var ApproveInstructionData = (0, import_buffer_layout.struct)([
  (0, import_buffer_layout.u8)("instruction"),
  (0, import_buffer_layout.blob)(8, "amount")
]);
function createApproveInstruction(account, delegate, owner, amount, programId = new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID)) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: delegate, isSigner: false, isWritable: false },
    { pubkey: owner, isSigner: true, isWritable: false }
  ];
  const data = import_buffer5.Buffer.alloc(ApproveInstructionData.span);
  ApproveInstructionData.encode(
    {
      instruction: 4,
      amount: getSafeU64Blob(amount)
    },
    data
  );
  return new import_web34.TransactionInstruction({ keys, programId, data });
}
var SyncNativeInstructionData = (0, import_buffer_layout.struct)([(0, import_buffer_layout.u8)("instruction")]);
function createSyncNativeInstruction(account) {
  const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
  const data = import_buffer5.Buffer.alloc(SyncNativeInstructionData.span);
  SyncNativeInstructionData.encode({ instruction: 17 }, data);
  return new import_web34.TransactionInstruction({
    keys,
    programId: new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID),
    data
  });
}
var CloseAccountInstructionData = (0, import_buffer_layout.struct)([
  (0, import_buffer_layout.u8)("instruction")
]);
function createCloseAccountInstruction(account, destination, owner, programId = new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID)) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: true, isWritable: false }
  ];
  const data = import_buffer5.Buffer.alloc(CloseAccountInstructionData.span);
  CloseAccountInstructionData.encode(
    {
      instruction: 9
    },
    data
  );
  return new import_web34.TransactionInstruction({ keys, programId, data });
}
var SplTransferInstructionData = (0, import_buffer_layout.struct)([
  (0, import_buffer_layout.u8)("instruction"),
  (0, import_buffer_layout.blob)(8, "amount")
]);
function createSplTransferInstruction(source, destination, owner, amount, programId = new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID)) {
  const keys = [
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: true, isWritable: false }
  ];
  const data = import_buffer5.Buffer.alloc(SplTransferInstructionData.span);
  SplTransferInstructionData.encode(
    {
      instruction: 3,
      amount: getSafeU64Blob(amount)
    },
    data
  );
  return new import_web34.TransactionInstruction({ keys, programId, data });
}
var solMint = new import_web34.PublicKey("So11111111111111111111111111111111111111112");
async function wrapSol(owner, amount, signTransaction, connection) {
  const solanaConnection = connection ?? new import_web34.Connection("https://rpc.ankr.com/solana");
  const toAccount = getAssociatedTokenAddress(solMint, owner, false);
  const {
    blockhash,
    lastValidBlockHeight
  } = await solanaConnection.getLatestBlockhash();
  const trx = new import_web34.Transaction({
    feePayer: owner,
    blockhash,
    lastValidBlockHeight
  });
  const toAccountData = await solanaConnection.getAccountInfo(toAccount, "finalized");
  if (!toAccountData || toAccountData.data.length === 0) {
    trx.add(createAssociatedTokenAccountInstruction(
      owner,
      toAccount,
      owner,
      solMint
    ));
  }
  trx.add(import_web34.SystemProgram.transfer({
    fromPubkey: owner,
    toPubkey: toAccount,
    lamports: getAmountOfFractionalAmount(amount, 9)
  }));
  trx.add(createSyncNativeInstruction(toAccount));
  const signedTrx = await signTransaction(trx);
  return await submitTransactionWithRetry({
    trx: signedTrx.serialize(),
    connection: solanaConnection,
    errorChance: 1,
    extraRpcs: []
  });
}
async function unwrapSol(owner, amount, signTransaction, connection) {
  const solanaConnection = connection ?? new import_web34.Connection("https://rpc.ankr.com/solana");
  const fromAccount = getAssociatedTokenAddress(solMint, owner, false);
  const delegate = import_web34.Keypair.generate();
  const {
    blockhash,
    lastValidBlockHeight
  } = await solanaConnection.getLatestBlockhash();
  const trx = new import_web34.Transaction({
    feePayer: owner,
    blockhash,
    lastValidBlockHeight
  });
  const toAccount = getAssociatedTokenAddress(
    solMint,
    delegate.publicKey,
    false
  );
  trx.add(createAssociatedTokenAccountInstruction(
    owner,
    toAccount,
    delegate.publicKey,
    solMint
  ));
  trx.add(createSplTransferInstruction(
    fromAccount,
    toAccount,
    owner,
    getAmountOfFractionalAmount(amount, 9)
  ));
  trx.add(createCloseAccountInstruction(
    toAccount,
    owner,
    delegate.publicKey
  ));
  trx.partialSign(delegate);
  const signedTrx = await signTransaction(trx);
  return await submitTransactionWithRetry({
    trx: signedTrx.serialize(),
    connection: solanaConnection,
    errorChance: 1,
    extraRpcs: []
  });
}
function deserializeInstructionInfo(instruction) {
  return new import_web34.TransactionInstruction({
    programId: new import_web34.PublicKey(instruction.programId),
    keys: instruction.accounts.map((key) => ({
      pubkey: new import_web34.PublicKey(key.pubkey),
      isSigner: key.isSigner,
      isWritable: key.isWritable
    })),
    data: import_buffer5.Buffer.from(instruction.data, "base64")
  });
}
async function getAddressLookupTableAccounts(keys, connection) {
  const addressLookupTableAccountInfos = await connection.getMultipleAccountsInfo(
    keys.map((key) => new import_web34.PublicKey(key))
  );
  return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
    const addressLookupTableAddress = keys[index];
    if (accountInfo) {
      const addressLookupTableAccount = new import_web34.AddressLookupTableAccount({
        key: new import_web34.PublicKey(addressLookupTableAddress),
        state: import_web34.AddressLookupTableAccount.deserialize(accountInfo.data)
      });
      acc.push(addressLookupTableAccount);
    }
    return acc;
  }, new Array());
}
function decentralizeClientSwapInstructions(params, connection, relayer) {
  const swapInstruction = deserializeInstructionInfo(params.swapInstruction);
  const cleanupInstruction = params.cleanupInstruction ? deserializeInstructionInfo(params.cleanupInstruction) : null;
  const computeBudgetInstructions = params.computeBudgetInstructions ? params.computeBudgetInstructions.map(deserializeInstructionInfo) : [];
  const setupInstructions = params.setupInstructions ? overrideInstructionsPayer(params.setupInstructions, relayer).map(deserializeInstructionInfo) : [];
  return {
    swapInstruction,
    cleanupInstruction,
    computeBudgetInstructions,
    setupInstructions,
    addressLookupTableAddresses: params.addressLookupTableAddresses
  };
}
var payerAccountsLocation = [
  {
    // System program create account
    programId: import_web34.SystemProgram.programId.toString(),
    instructionDataHex: "00000000",
    discriminatorLength: 4,
    accountIndex: 0
  },
  {
    // ATA create idempotent
    programId: addresses_default.ASSOCIATED_TOKEN_PROGRAM_ID,
    instructionDataHex: "01",
    discriminatorLength: 1,
    accountIndex: 0
  },
  {
    // ATA create
    programId: addresses_default.ASSOCIATED_TOKEN_PROGRAM_ID,
    instructionDataHex: "",
    discriminatorLength: 0,
    accountIndex: 0
  }
];
function overrideInstructionsPayer(instructions, relayer) {
  if (!relayer) {
    return instructions;
  }
  return instructions.map((instruction) => {
    const override = payerAccountsLocation.find(
      (item) => item.programId === instruction.programId && item.instructionDataHex === import_buffer5.Buffer.from(instruction.data, "base64").subarray(0, item.discriminatorLength).toString("hex") && instruction.accounts.length > item.accountIndex
    );
    if (override) {
      const newAccounts = [...instruction.accounts];
      newAccounts[override.accountIndex] = {
        ...newAccounts[override.accountIndex],
        pubkey: relayer.toString()
      };
      return {
        ...instruction,
        accounts: newAccounts
      };
    } else {
      return instruction;
    }
  });
}
function getAnchorInstructionData(name) {
  let preimage = `global:${name}`;
  return import_buffer5.Buffer.from((0, import_sha2.sha256)(preimage)).subarray(0, 8);
}
async function decideRelayer() {
  let relayer;
  try {
    const suggestedRelayer = await getSuggestedRelayer();
    relayer = new import_web34.PublicKey(suggestedRelayer);
  } catch (err) {
    console.log("Relayer not found, using system program");
    relayer = import_web34.SystemProgram.programId;
  }
  return relayer;
}
function getJitoTipTransfer(swapper, blockhash, lastValidBlockHeight, options) {
  const jitoAccount = options.jitoAccount || "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY";
  return new import_web34.Transaction({
    feePayer: new import_web34.PublicKey(swapper),
    blockhash,
    lastValidBlockHeight
  }).add(import_web34.SystemProgram.transfer({
    fromPubkey: new import_web34.PublicKey(swapper),
    toPubkey: new import_web34.PublicKey(jitoAccount),
    lamports: options.tipLamports
  }));
}
var defaultJitoSendBundleUrls = [
  "https://mayan-jito.mayan.finance/v1/bundles"
];
async function postJitoBundle(url, body) {
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body
  });
  if (res.status !== 200 && res.status !== 201) {
    console.error("Post Jito bundle failed", url, res.status, res.statusText);
    throw new Error("Send Jito bundle failed: " + res.status + " " + res.statusText);
  } else {
    const result = await res.json();
    console.log("Post Jito bundle result", url, result.result);
    return result.result;
  }
}
async function sendJitoBundle(singedTrxs, options, forceToBeSubmitted = false) {
  try {
    let signedTrxs = [];
    for (let trx of singedTrxs) {
      signedTrxs.push(trx.serialize());
    }
    const bundle = {
      jsonrpc: "2.0",
      id: 1,
      method: "sendBundle",
      params: [signedTrxs.map((trx) => import_bs58.default.encode(trx))]
    };
    const urls = options.jitoSendUrl ? [options.jitoSendUrl] : defaultJitoSendBundleUrls;
    const body = JSON.stringify(bundle);
    const result = await Promise.any(urls.map((url) => postJitoBundle(url, body)));
    return result;
  } catch (err) {
    console.error("Send Jito bundle failed", err);
    if (forceToBeSubmitted) {
      throw new Error(`Send Jito bundle failed`);
    }
  }
}
async function getJitoBundleStatuses(bundleIds, jitoApiUrl) {
  const maxRetries = 5;
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      const response = await fetch(jitoApiUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jsonrpc: "2.0",
          id: 1,
          method: "getBundleStatuses",
          params: [bundleIds]
        })
      });
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      const data = await response.json();
      if (data.error) {
        throw new Error(`Error getting bundle statuses: ${JSON.stringify(data.error, null, 2)}`);
      }
      return data.result;
    } catch (error) {
      attempt++;
      await wait(1e3);
      if (attempt >= maxRetries) {
        throw new Error(`Failed to fetch bundle statuses after ${maxRetries} attempts: ${error.message}`);
      }
    }
  }
}
async function confirmJitoBundleId(bundleId, options, lastValidBlockHeight, mayanTxSignature, connection) {
  const timeout = 30 * 3e3;
  const startTime = Date.now();
  while (Date.now() - startTime < timeout && await connection.getBlockHeight() <= lastValidBlockHeight) {
    await wait(2050);
    const urls = options.jitoSendUrl ? [options.jitoSendUrl] : defaultJitoSendBundleUrls;
    const bundleStatuses = await Promise.any(urls.map((url) => getJitoBundleStatuses([bundleId], url)));
    if (bundleStatuses && bundleStatuses.value && bundleStatuses.value.length > 0 && bundleStatuses.value[0]) {
      console.log("===>", bundleStatuses.value[0]);
      const status = bundleStatuses.value[0].confirmation_status;
      if (status === "confirmed" || status === "finalized") {
        const tx = await connection.getSignatureStatus(mayanTxSignature);
        if (!tx || !tx.value) {
          continue;
        }
        if (tx.value?.err) {
          throw new Error(`Bundle failed with error: ${tx.value.err}`);
        }
        return;
      }
    }
  }
  throw new Error("Bundle not confirmed, timeout");
}
async function broadcastJitoBundleId(bundleId) {
  try {
    await fetch("https://explorer-api.mayan.finance/v3/submit/jito-bundle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ bundleId })
    });
  } catch {
  }
}
function validateJupCleanupInstruction(instruction, validCleanReceiverAddress) {
  if (!instruction) {
    return;
  }
  if (!instruction.programId.equals(new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID)) && !instruction.programId.equals(new import_web34.PublicKey(addresses_default.TOKEN_2022_PROGRAM_ID))) {
    throw new Error("Invalid cleanup instruction:: programId");
  }
  if (Uint8Array.from(instruction.data).length !== 1) {
    throw new Error("Invalid cleanup instruction:: data");
  }
  if (Uint8Array.from(instruction.data)[0] !== 9) {
    throw new Error("Invalid cleanup instruction:: data");
  }
  if (validCleanReceiverAddress) {
    if (!instruction.keys[1].pubkey.equals(validCleanReceiverAddress)) {
      throw new Error("Invalid cleanup instruction:: dest account");
    }
  }
}
function validateJupSetupInstructions(instructions, owner) {
  if (instructions.length < 1) {
    return;
  }
  if (instructions.length > 6) {
    throw new Error("Invalid setup instruction:: too many instructions");
  }
  instructions.forEach((instruction) => {
    if (!instruction.programId.equals(new import_web34.PublicKey(addresses_default.ASSOCIATED_TOKEN_PROGRAM_ID)) && !instruction.programId.equals(import_web34.SystemProgram.programId) && !instruction.programId.equals(new import_web34.PublicKey(addresses_default.TOKEN_PROGRAM_ID)) && !instruction.programId.equals(new import_web34.PublicKey(addresses_default.TOKEN_2022_PROGRAM_ID))) {
      throw new Error("Invalid setup instruction:: programId");
    }
    if (instruction.programId.equals(new import_web34.PublicKey(addresses_default.ASSOCIATED_TOKEN_PROGRAM_ID))) {
      if (Uint8Array.from(instruction.data).length === 1) {
        if (Uint8Array.from(instruction.data)[0] !== 1) {
          throw new Error("Invalid setup instruction:: data");
        }
      } else if (Uint8Array.from(instruction.data).length !== 0) {
        throw new Error("Invalid setup instruction:: data");
      }
    } else if (instruction.programId.equals(import_web34.SystemProgram.programId)) {
      if (!owner) {
        throw new Error("Invalid setup instruction:: unknown transfer");
      }
      const wSolAccount = getAssociatedTokenAddress(solMint, owner, true);
      if (instruction.data.readUint32LE() !== 2) {
        throw new Error("Invalid setup instruction:: invalid system program instruction");
      }
      if (!instruction.keys[1].pubkey.equals(wSolAccount)) {
        throw new Error("Invalid setup instruction:: invalid wrap transfer dest");
      }
    } else {
      if (instruction.data.toString("base64") !== "EQ==") {
        throw new Error("Invalid setup instruction:: invalid token program instruction");
      }
    }
  });
}
function validateJupSwapInstruction(instruction, validDestAccount, sameSourceAndDestWallet = false) {
  const JUP_PROGRAM_ID = new import_web34.PublicKey("JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4");
  if (!instruction.programId.equals(JUP_PROGRAM_ID)) {
    throw new Error("Invalid swap instruction:: programId");
  }
  if (instruction.data.subarray(0, 8).toString("hex") === getAnchorInstructionData("shared_accounts_route").toString("hex")) {
    if (!instruction.keys[6].pubkey.equals(validDestAccount)) {
      throw new Error(`Invalid swap instruction shared_accounts_route:: dest account`);
    }
  } else if (instruction.data.subarray(0, 8).toString("hex") === getAnchorInstructionData("shared_accounts_route_v2").toString("hex")) {
    if (!instruction.keys[5].pubkey.equals(validDestAccount)) {
      throw new Error(`Invalid swap instruction shared_accounts_route_v2:: dest account`);
    }
  } else if (instruction.data.subarray(0, 8).toString("hex") === getAnchorInstructionData("route").toString("hex")) {
    if (sameSourceAndDestWallet) {
      if (!instruction.keys[4].pubkey.equals(JUP_PROGRAM_ID) || !instruction.keys[3].pubkey.equals(validDestAccount)) {
        throw new Error("Invalid swap instruction route:: dest account");
      }
    } else {
      if (!instruction.keys[4].pubkey.equals(validDestAccount)) {
        throw new Error("Invalid swap instruction route:: dest account");
      }
    }
  } else if (instruction.data.subarray(0, 8).toString("hex") === getAnchorInstructionData("route_v2").toString("hex")) {
    if (sameSourceAndDestWallet) {
      if (!instruction.keys[7].pubkey.equals(JUP_PROGRAM_ID) || !instruction.keys[2].pubkey.equals(validDestAccount)) {
        throw new Error("Invalid swap instruction route_v2:: dest account");
      }
    } else {
      if (!instruction.keys[7].pubkey.equals(validDestAccount)) {
        throw new Error("Invalid swap instruction route_v2:: dest account");
      }
    }
  } else {
    throw new Error("Invalid swap instruction:: ix id");
  }
}
function validateJupSwapInstructionData(instruction, quote) {
  const args = decodeJupiterV6InsArgs(Uint8Array.from(instruction.data));
  if (args.in_amount > BigInt(quote.effectiveAmountIn64)) {
    throw new Error("Invalid swap instruction:: amount in");
  }
  const minAmountOut64 = getAmountOfFractionalAmount(quote.minAmountOut, quote.toToken.decimals);
  const calculatedMinAmountOut = args.quoted_out_amount - args.quoted_out_amount * BigInt(args.slippage_bps) / 10000n;
  if (calculatedMinAmountOut < minAmountOut64) {
    throw new Error("Invalid swap instruction:: quote expired");
  }
  if (args.platform_fee_bps !== quote.referrerBps) {
    throw new Error("Invalid swap instruction:: platform fee");
  }
}
function validateJupComputeBudgetInstructions(instructions) {
  instructions.forEach((instruction) => {
    if (!instruction.programId.equals(import_web34.ComputeBudgetProgram.programId)) {
      throw new Error("Invalid compute budget instruction:: programId");
    }
    if (Uint8Array.from(instruction.data)[0] === 3 && instruction.data.readBigUInt64LE(1) > 100000000n) {
      throw new Error("Invalid compute budget instruction:: to high tx fee");
    }
  });
}
function validateJupSwap(swap, validDestAccount, validWrapOwner, validCleanReceiverAddress, sameSourceAndDestWallet = false) {
  validateJupComputeBudgetInstructions(swap.computeBudgetInstructions);
  validateJupSetupInstructions(swap.setupInstructions, validWrapOwner);
  validateJupSwapInstruction(swap.swapInstruction, validDestAccount, sameSourceAndDestWallet);
  validateJupCleanupInstruction(swap.cleanupInstruction, validCleanReceiverAddress);
}
function createTransferAllAndCloseInstruction(owner, mint, tokenAccount, transferDestination, closeDestination, tokenProgramId = new import_web34.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")) {
  return new import_web34.TransactionInstruction({
    keys: [
      { pubkey: owner, isSigner: true, isWritable: false },
      { pubkey: tokenAccount, isSigner: false, isWritable: true },
      { pubkey: transferDestination, isSigner: false, isWritable: true },
      { pubkey: mint, isSigner: false, isWritable: false },
      { pubkey: closeDestination, isSigner: false, isWritable: true },
      { pubkey: tokenProgramId, isSigner: false, isWritable: false }
    ],
    programId: new import_web34.PublicKey("B96dV3Luxzo6SokJx3xt8i5y8Mb7HRR6Eec8hCjJDT69"),
    data: getAnchorInstructionData("transfer_all_and_close")
  });
}
function createPayloadWriterCreateInstruction(payer, payloadAccount, payload, nonce) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: payloadAccount, isSigner: false, isWritable: true },
    { pubkey: import_web34.SystemProgram.programId, isSigner: false, isWritable: false }
  ];
  const dataLength = 8 + // instruction discriminator
  2 + // nonce
  4 + // payload vector length
  payload.length;
  const insData = import_buffer5.Buffer.alloc(dataLength);
  insData.set(getAnchorInstructionData("create_simple"), 0);
  insData.writeUint16LE(nonce, 8);
  insData.writeUint32LE(payload.length, 10);
  insData.set(payload, 14);
  return new import_web34.TransactionInstruction({
    keys,
    programId: new import_web34.PublicKey(addresses_default.PAYLOAD_WRITER_PROGRAM_ID),
    data: insData
  });
}
function createPayloadWriterCloseInstruction(payer, payloadAccount, nonce) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: payloadAccount, isSigner: false, isWritable: true }
  ];
  const dataLength = 8 + // instruction discriminator
  2;
  const insData = import_buffer5.Buffer.alloc(dataLength);
  insData.set(getAnchorInstructionData("close"), 0);
  insData.writeUint16LE(nonce, 8);
  return new import_web34.TransactionInstruction({
    keys,
    programId: new import_web34.PublicKey(addresses_default.PAYLOAD_WRITER_PROGRAM_ID),
    data: insData
  });
}
function sandwichInstructionInCpiProxy(instruction, skipProxy = false) {
  if (skipProxy) {
    return instruction;
  }
  return new import_web34.TransactionInstruction({
    keys: [{ pubkey: instruction.programId, isSigner: false, isWritable: false }].concat(instruction.keys),
    programId: new import_web34.PublicKey(addresses_default.CPI_PROXY_PROGRAM_ID),
    data: instruction.data
  });
}
function getLookupTableAddress(chainName) {
  if (chainName === "solana") {
    return addresses_default.LOOKUP_TABLE_SOLANA;
  } else if (chainName === "fogo") {
    return addresses_default.LOOKUP_TABLE_FOGO;
  }
  throw new Error(`Unsupported chain name for lookup table: ${chainName}`);
}

// src/solana/solanaSwap.ts
var import_web311 = require("@solana/web3.js");
var import_buffer_layout5 = require("@solana/buffer-layout");
var import_buffer11 = require("buffer");
var import_ethers5 = require("ethers");

// src/solana/solanaMctp.ts
var import_web36 = require("@solana/web3.js");
var import_buffer_layout2 = require("@solana/buffer-layout");
var import_buffer7 = require("buffer");

// src/wormhole.ts
var import_web35 = require("@solana/web3.js");
var import_buffer6 = require("buffer");
function getWormholePDAs(supplierProgram, chainName) {
  let wormholeProgramId;
  let wormholeShimProgramId;
  if (chainName === "solana") {
    wormholeProgramId = new import_web35.PublicKey(addresses_default.WORMHOLE_PROGRAM_ID);
    wormholeShimProgramId = new import_web35.PublicKey(addresses_default.WORMHOLE_SHIM_POST_MESSAGE_PROGRAM_ID);
  } else if (chainName === "fogo") {
    wormholeProgramId = new import_web35.PublicKey(addresses_default.WORMHOLE_PROGRAM_ID_FOGO);
    wormholeShimProgramId = new import_web35.PublicKey(addresses_default.WORMHOLE_SHIM_POST_MESSAGE_PROGRAM_ID);
  } else {
    throw new Error("Unsupported chain for wormhole PDAs: " + chainName);
  }
  const programId = new import_web35.PublicKey(supplierProgram);
  const [bridgeConfig] = import_web35.PublicKey.findProgramAddressSync(
    [import_buffer6.Buffer.from("Bridge")],
    wormholeProgramId
  );
  const [emitter] = import_web35.PublicKey.findProgramAddressSync(
    [import_buffer6.Buffer.from("emitter")],
    programId
  );
  const [sequenceKey] = import_web35.PublicKey.findProgramAddressSync(
    [import_buffer6.Buffer.from("Sequence"), emitter.toBuffer()],
    wormholeProgramId
  );
  const [feeCollector] = import_web35.PublicKey.findProgramAddressSync(
    [import_buffer6.Buffer.from("fee_collector")],
    wormholeProgramId
  );
  const [shimMessage] = import_web35.PublicKey.findProgramAddressSync(
    [emitter.toBuffer()],
    wormholeShimProgramId
  );
  const [shimEventAuth] = import_web35.PublicKey.findProgramAddressSync(
    [import_buffer6.Buffer.from("__event_authority")],
    wormholeShimProgramId
  );
  return {
    bridgeConfig,
    sequenceKey,
    feeCollector,
    emitter,
    shimEventAuth,
    shimMessage
  };
}

// src/solana/solanaMctp.ts
var MCTPBridgeWithFeeLayout = (0, import_buffer_layout2.struct)([
  (0, import_buffer_layout2.blob)(8, "instruction")
]);
function createMctpBridgeWithFeeInstruction(ledger, toChain, mintAddress, relayerAddress, feeSolana, fromChain) {
  const wormholeProgramId = new import_web36.PublicKey(addresses_default.WORMHOLE_PROGRAM_ID);
  const wormholeShimProgramId = new import_web36.PublicKey(addresses_default.WORMHOLE_SHIM_POST_MESSAGE_PROGRAM_ID);
  const TOKEN_PROGRAM_ID = new import_web36.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  const cctpCoreProgramId = new import_web36.PublicKey(addresses_default.CCTP_CORE_PROGRAM_ID);
  const cctpTokenProgramId = new import_web36.PublicKey(addresses_default.CCTP_TOKEN_PROGRAM_ID);
  const mctpProgram = new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  const relayer = new import_web36.PublicKey(relayerAddress);
  const mint = new import_web36.PublicKey(mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(
    mint,
    ledger,
    true
  );
  let relayerAccount;
  if (feeSolana && feeSolana > BigInt(0)) {
    relayerAccount = getAssociatedTokenAddress(mint, relayer, false);
  } else {
    relayerAccount = new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  }
  const cctpBridgePdas = getCCTPBridgePDAs(mint, toChain);
  const wormholePDAs = getWormholePDAs(addresses_default.MCTP_PROGRAM_ID, fromChain);
  const cctpMessage = import_web36.Keypair.generate();
  const accounts = [
    { pubkey: ledger, isWritable: true, isSigner: false },
    { pubkey: ledgerAccount, isWritable: true, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: relayerAccount, isWritable: true, isSigner: false },
    { pubkey: mint, isWritable: true, isSigner: false },
    { pubkey: cctpBridgePdas.senderAuthority, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.tokenMessenger, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.remoteTokenMessengerKey, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.tokenMinter, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.localToken, isWritable: true, isSigner: false },
    { pubkey: cctpBridgePdas.eventAuthToken, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.messageTransmitter, isWritable: true, isSigner: false },
    { pubkey: cctpMessage.publicKey, isWritable: true, isSigner: true },
    { pubkey: cctpTokenProgramId, isWritable: false, isSigner: false },
    { pubkey: cctpCoreProgramId, isWritable: false, isSigner: false },
    { pubkey: wormholePDAs.emitter, isWritable: false, isSigner: false },
    { pubkey: wormholePDAs.bridgeConfig, isWritable: true, isSigner: false },
    { pubkey: wormholePDAs.sequenceKey, isWritable: true, isSigner: false },
    { pubkey: wormholePDAs.feeCollector, isWritable: true, isSigner: false },
    { pubkey: wormholePDAs.shimMessage, isWritable: true, isSigner: false },
    { pubkey: wormholeProgramId, isWritable: false, isSigner: false },
    { pubkey: import_web36.SYSVAR_CLOCK_PUBKEY, isWritable: false, isSigner: false },
    { pubkey: wormholePDAs.shimEventAuth, isWritable: false, isSigner: false },
    { pubkey: wormholeShimProgramId, isWritable: false, isSigner: false },
    { pubkey: TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
    { pubkey: import_web36.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const data = import_buffer7.Buffer.alloc(MCTPBridgeWithFeeLayout.span);
  MCTPBridgeWithFeeLayout.encode(
    {
      instruction: getAnchorInstructionData("bridge_with_fee_shim")
    },
    data
  );
  const bridgeIns = new import_web36.TransactionInstruction({
    keys: accounts,
    data,
    programId: mctpProgram
  });
  return { instruction: bridgeIns, signers: [cctpMessage] };
}
var MctpBridgeLockFeeLayout = (0, import_buffer_layout2.struct)([
  (0, import_buffer_layout2.blob)(8, "instruction")
]);
function createMctpBridgeLockFeeInstruction(ledger, toChain, mintAddress, relayerAddress, feeSolana) {
  const instructions = [null, null];
  const TOKEN_PROGRAM_ID = new import_web36.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  const ASSOCIATED_TOKEN_PROGRAM_ID = new import_web36.PublicKey(addresses_default.ASSOCIATED_TOKEN_PROGRAM_ID);
  const cctpCoreProgramId = new import_web36.PublicKey(addresses_default.CCTP_CORE_PROGRAM_ID);
  const cctpTokenProgramId = new import_web36.PublicKey(addresses_default.CCTP_TOKEN_PROGRAM_ID);
  const mctpProgram = new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  const relayer = new import_web36.PublicKey(relayerAddress);
  const mint = new import_web36.PublicKey(mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(
    mint,
    ledger,
    true
  );
  const cctpBridgePdas = getCCTPBridgePDAs(mint, toChain);
  const cctpMessage = import_web36.Keypair.generate();
  const [feeState] = import_web36.PublicKey.findProgramAddressSync(
    [import_buffer7.Buffer.from("LOCKED_FEE"), mint.toBuffer(), cctpMessage.publicKey.toBytes()],
    mctpProgram
  );
  let relayerAccount;
  if (feeSolana && feeSolana > BigInt(0)) {
    relayerAccount = getAssociatedTokenAddress(mint, relayer, false);
  } else {
    relayerAccount = new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  }
  const feeStateAccount = getAssociatedTokenAddress(
    mint,
    feeState,
    true
  );
  instructions[0] = createAssociatedTokenAccountInstruction(
    relayer,
    feeStateAccount,
    feeState,
    mint
  );
  const accounts = [
    { pubkey: ledger, isWritable: true, isSigner: false },
    { pubkey: ledgerAccount, isWritable: true, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: relayerAccount, isWritable: true, isSigner: false },
    { pubkey: feeState, isWritable: true, isSigner: false },
    { pubkey: feeStateAccount, isWritable: true, isSigner: false },
    { pubkey: mint, isWritable: true, isSigner: false },
    { pubkey: cctpBridgePdas.senderAuthority, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.tokenMessenger, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.remoteTokenMessengerKey, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.tokenMinter, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.localToken, isWritable: true, isSigner: false },
    { pubkey: cctpBridgePdas.eventAuthToken, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.messageTransmitter, isWritable: true, isSigner: false },
    { pubkey: cctpMessage.publicKey, isWritable: true, isSigner: true },
    { pubkey: cctpTokenProgramId, isWritable: false, isSigner: false },
    { pubkey: cctpCoreProgramId, isWritable: false, isSigner: false },
    { pubkey: TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
    { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
    { pubkey: import_web36.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const data = import_buffer7.Buffer.alloc(MctpBridgeLockFeeLayout.span);
  MctpBridgeLockFeeLayout.encode(
    {
      instruction: getAnchorInstructionData("bridge_locked_fee")
    },
    data
  );
  const bridgeIns = new import_web36.TransactionInstruction({
    keys: accounts,
    data,
    programId: mctpProgram
  });
  instructions[1] = bridgeIns;
  return {
    instructions,
    signer: cctpMessage
  };
}
var MctpInitSwapLayout = (0, import_buffer_layout2.struct)([
  (0, import_buffer_layout2.blob)(8, "instruction")
]);
function createMctpInitSwapInstruction(ledger, toChain, mintAddress, relayerAddress, feeSolana) {
  const TOKEN_PROGRAM_ID = new import_web36.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  const cctpCoreProgramId = new import_web36.PublicKey(addresses_default.CCTP_CORE_PROGRAM_ID);
  const cctpTokenProgramId = new import_web36.PublicKey(addresses_default.CCTP_TOKEN_PROGRAM_ID);
  const mctpProgram = new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  const relayer = new import_web36.PublicKey(relayerAddress);
  const mint = new import_web36.PublicKey(mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(
    mint,
    ledger,
    true
  );
  const cctpBridgePdas = getCCTPBridgePDAs(mint, toChain);
  const cctpMessage = import_web36.Keypair.generate();
  const [swapState] = import_web36.PublicKey.findProgramAddressSync(
    [import_buffer7.Buffer.from("ORDER_SOLANA_SOURCE"), ledger.toBuffer()],
    mctpProgram
  );
  let relayerAccount;
  if (feeSolana && feeSolana > BigInt(0)) {
    relayerAccount = getAssociatedTokenAddress(mint, relayer, false);
  } else {
    relayerAccount = new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  }
  const accounts = [
    { pubkey: ledger, isWritable: false, isSigner: false },
    { pubkey: ledgerAccount, isWritable: true, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: relayerAccount, isWritable: true, isSigner: false },
    { pubkey: mint, isWritable: true, isSigner: false },
    { pubkey: swapState, isWritable: true, isSigner: false },
    { pubkey: cctpBridgePdas.senderAuthority, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.tokenMessenger, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.remoteTokenMessengerKey, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.tokenMinter, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.localToken, isWritable: true, isSigner: false },
    { pubkey: cctpBridgePdas.eventAuthToken, isWritable: false, isSigner: false },
    { pubkey: cctpBridgePdas.messageTransmitter, isWritable: true, isSigner: false },
    { pubkey: cctpMessage.publicKey, isWritable: true, isSigner: true },
    { pubkey: cctpTokenProgramId, isWritable: false, isSigner: false },
    { pubkey: cctpCoreProgramId, isWritable: false, isSigner: false },
    { pubkey: new import_web36.PublicKey(addresses_default.FEE_MANAGER_PROGRAM_ID), isWritable: false, isSigner: false },
    { pubkey: TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
    { pubkey: import_web36.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const data = import_buffer7.Buffer.alloc(MctpInitSwapLayout.span);
  MctpInitSwapLayout.encode(
    {
      instruction: getAnchorInstructionData("create_order")
    },
    data
  );
  const initSwapIns = new import_web36.TransactionInstruction({
    keys: accounts,
    data,
    programId: mctpProgram
  });
  return { instruction: initSwapIns, signer: cctpMessage };
}
var MctpBridgeLedgerLayout = (0, import_buffer_layout2.struct)([
  (0, import_buffer_layout2.blob)(8, "instruction"),
  (0, import_buffer_layout2.blob)(32, "destAddress"),
  (0, import_buffer_layout2.blob)(8, "amountInMin"),
  (0, import_buffer_layout2.blob)(8, "gasDrop"),
  (0, import_buffer_layout2.blob)(8, "feeRedeem"),
  (0, import_buffer_layout2.blob)(8, "feeSolana"),
  (0, import_buffer_layout2.u16)("destinationChain"),
  (0, import_buffer_layout2.blob)(32, "keyRnd"),
  (0, import_buffer_layout2.u8)("mode")
]);
function createMctpBridgeLedgerInstruction(params) {
  if (params.mode !== "WITH_FEE" && params.mode !== "LOCK_FEE") {
    throw new Error("Invalid mode: " + params.mode);
  }
  if (params.customPayload && params.mode !== "WITH_FEE") {
    throw new Error("Custom payload is only supported in WITH_FEE mode");
  }
  const user = new import_web36.PublicKey(params.swapperAddress);
  const relayer = new import_web36.PublicKey(params.relayerAddress);
  const mint = new import_web36.PublicKey(params.mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(mint, params.ledger, true);
  const destinationChainId = getWormholeChainIdByName(params.toChain);
  const destAddress = import_buffer7.Buffer.from(
    hexToUint8Array(
      nativeAddressToHexString(params.destinationAddress, destinationChainId)
    )
  );
  const amountInMin = getSafeU64Blob(params.amountInMin64);
  const gasDrop = getSafeU64Blob(
    getAmountOfFractionalAmount(params.gasDrop, Math.min(getGasDecimal(params.toChain), 8))
  );
  const feeRedeem = getSafeU64Blob(
    getAmountOfFractionalAmount(params.feeRedeem, CCTP_TOKEN_DECIMALS)
  );
  const feeSolana = getSafeU64Blob(params.feeSolana);
  const refAddress = params.referrerAddress ? import_buffer7.Buffer.from(hexToUint8Array(
    nativeAddressToHexString(params.referrerAddress, destinationChainId)
  )) : import_web36.SystemProgram.programId.toBuffer();
  const accounts = [
    { pubkey: user, isWritable: true, isSigner: true },
    { pubkey: params.ledger, isWritable: true, isSigner: false },
    { pubkey: ledgerAccount, isWritable: false, isSigner: false },
    { pubkey: params.customPayload || new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID), isWritable: false, isSigner: false },
    { pubkey: mint, isWritable: false, isSigner: false },
    { pubkey: import_web36.SystemProgram.programId, isWritable: false, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: new import_web36.PublicKey(refAddress), isWritable: false, isSigner: false }
  ];
  const data = import_buffer7.Buffer.alloc(MctpBridgeLedgerLayout.span);
  MctpBridgeLedgerLayout.encode(
    {
      instruction: getAnchorInstructionData("init_bridge_ledger_gasless"),
      destAddress,
      amountInMin,
      gasDrop,
      feeRedeem,
      feeSolana,
      destinationChain: destinationChainId,
      keyRnd: params.randomKey.toBuffer(),
      mode: params.mode === "WITH_FEE" ? 1 : 2
    },
    data
  );
  return new import_web36.TransactionInstruction({
    keys: accounts,
    data,
    programId: new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID)
  });
}
var MctpSwapLedgerLayout = (0, import_buffer_layout2.struct)([
  (0, import_buffer_layout2.blob)(8, "instruction"),
  (0, import_buffer_layout2.blob)(32, "destAddress"),
  (0, import_buffer_layout2.blob)(8, "amountInMin"),
  (0, import_buffer_layout2.blob)(8, "gasDrop"),
  (0, import_buffer_layout2.blob)(8, "feeRedeem"),
  (0, import_buffer_layout2.blob)(8, "feeSolana"),
  (0, import_buffer_layout2.u16)("destinationChain"),
  (0, import_buffer_layout2.blob)(32, "keyRnd"),
  (0, import_buffer_layout2.u8)("mode"),
  (0, import_buffer_layout2.blob)(32, "tokenOut"),
  (0, import_buffer_layout2.blob)(8, "amountOutMin"),
  (0, import_buffer_layout2.blob)(8, "deadline"),
  (0, import_buffer_layout2.blob)(32, "refAddress"),
  (0, import_buffer_layout2.u8)("feeRateRef")
]);
function createMctpSwapLedgerInstruction(params) {
  const user = new import_web36.PublicKey(params.swapperAddress);
  const relayer = new import_web36.PublicKey(params.relayerAddress);
  const mint = new import_web36.PublicKey(params.mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(mint, params.ledger, true);
  const destinationChainId = getWormholeChainIdByName(params.toChain);
  const destAddress = import_buffer7.Buffer.from(
    hexToUint8Array(
      nativeAddressToHexString(params.destinationAddress, destinationChainId)
    )
  );
  const amountInMin = getSafeU64Blob(params.amountInMin64);
  const gasDrop = getSafeU64Blob(
    getAmountOfFractionalAmount(params.gasDrop, Math.min(getGasDecimal(params.toChain), 8))
  );
  const feeRedeem = getSafeU64Blob(
    getAmountOfFractionalAmount(params.feeRedeem, CCTP_TOKEN_DECIMALS)
  );
  const feeSolana = getSafeU64Blob(params.feeSolana);
  const tokenOut = import_buffer7.Buffer.from(hexToUint8Array(
    nativeAddressToHexString(params.tokenOut, destinationChainId)
  ));
  const refAddress = params.referrerAddress ? import_buffer7.Buffer.from(hexToUint8Array(
    nativeAddressToHexString(params.referrerAddress, destinationChainId)
  )) : import_web36.SystemProgram.programId.toBuffer();
  const amountOutMin = getSafeU64Blob(
    getAmountOfFractionalAmount(params.amountOutMin, Math.min(8, params.tokenOutDecimals))
  );
  const deadline = getSafeU64Blob(params.deadline);
  const accounts = [
    { pubkey: user, isWritable: true, isSigner: true },
    { pubkey: params.ledger, isWritable: true, isSigner: false },
    { pubkey: ledgerAccount, isWritable: false, isSigner: false },
    { pubkey: mint, isWritable: false, isSigner: false },
    { pubkey: import_web36.SystemProgram.programId, isWritable: false, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true }
  ];
  const data = import_buffer7.Buffer.alloc(MctpSwapLedgerLayout.span);
  MctpSwapLedgerLayout.encode(
    {
      instruction: getAnchorInstructionData("init_order_ledger_gasless"),
      destAddress,
      amountInMin,
      gasDrop,
      feeRedeem,
      feeSolana,
      destinationChain: destinationChainId,
      keyRnd: params.randomKey.toBuffer(),
      mode: 3,
      tokenOut,
      refAddress,
      amountOutMin,
      deadline,
      feeRateRef: params.feeRateRef
    },
    data
  );
  return new import_web36.TransactionInstruction({
    keys: accounts,
    data,
    programId: new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID)
  });
}
async function createMctpFromSolanaInstructions(quote, swapperAddress, destinationAddress, referrerAddress, connection, options = {}) {
  const forceSkipCctpInstructions = options?.forceSkipCctpInstructions || false;
  const allowSwapperOffCurve = options?.allowSwapperOffCurve || false;
  if (quote.toChain === "solana") {
    throw new Error("Unsupported destination chain: " + quote.toChain);
  }
  const relayerAddress = quote.relayer || swapperAddress;
  let _lookupTablesAddress = [];
  let instructions = [];
  let signers = [];
  let lookupTables = [];
  let _swapAddressLookupTables = [];
  let swapInstructions = [];
  let createSwapTpmTokenAccountInstructions = [];
  const tmpSwapTokenAccount = import_web36.Keypair.generate();
  let swapMessageV0Params = null;
  _lookupTablesAddress.push(getLookupTableAddress(quote.fromChain));
  const mctpProgram = new import_web36.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  const user = new import_web36.PublicKey(swapperAddress);
  const relayer = new import_web36.PublicKey(relayerAddress);
  const randomKey = import_web36.Keypair.generate();
  const deadline = quote.deadline64 ? BigInt(quote.deadline64) : BigInt(0);
  if (quote.hasAuction && !Number(quote.deadline64)) {
    throw new Error("Swap mode requires a timeout");
  }
  const ledgerSeedPrefix = quote.hasAuction ? "LEDGER_ORDER" : "LEDGER_BRIDGE";
  const [ledger] = import_web36.PublicKey.findProgramAddressSync(
    [import_buffer7.Buffer.from(ledgerSeedPrefix), user.toBytes(), randomKey.publicKey.toBytes()],
    mctpProgram
  );
  const ledgerAccount = getAssociatedTokenAddress(
    new import_web36.PublicKey(quote.mctpInputContract),
    ledger,
    true
  );
  const mode = quote.cheaperChain === "solana" ? "LOCK_FEE" : "WITH_FEE";
  if (quote.toChain === "sui" && !quote.toToken.verifiedAddress) {
    throw new Error("Missing verified address for SUI coin");
  }
  const tokenOut = quote.toChain === "sui" ? quote.toToken.verifiedAddress : quote.toToken.contract;
  if (!tokenOut) {
    throw new Error("Missing token out address");
  }
  if (options.customPayload && quote.hasAuction) {
    throw new Error("Cannot use customPayload with create Mctp swap");
  }
  let customPayloadAccount = null;
  const customPayloadNonce = Math.floor(Math.random() * 65e3);
  if (options.customPayload) {
    customPayloadAccount = import_web36.PublicKey.findProgramAddressSync(
      [
        import_buffer7.Buffer.from("PAYLOAD"),
        relayer.toBuffer(),
        (() => {
          const buf = import_buffer7.Buffer.alloc(2);
          buf.writeUInt16LE(customPayloadNonce, 0);
          return buf;
        })()
      ],
      new import_web36.PublicKey(addresses_default.PAYLOAD_WRITER_PROGRAM_ID)
    )[0];
    instructions.push(
      sandwichInstructionInCpiProxy(createPayloadWriterCreateInstruction(
        relayer,
        customPayloadAccount,
        import_buffer7.Buffer.from(options.customPayload),
        customPayloadNonce
      ))
    );
  }
  if (quote.fromToken.contract === quote.mctpInputContract) {
    const feeSolana = forceSkipCctpInstructions ? BigInt(quote.solanaRelayerFee64) : BigInt(0);
    if (quote.suggestedPriorityFee > 0) {
      instructions.push(import_web36.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: quote.suggestedPriorityFee
      }));
    }
    instructions.push(
      sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(relayer, ledgerAccount, ledger, new import_web36.PublicKey(quote.mctpInputContract)))
    );
    instructions.push(
      sandwichInstructionInCpiProxy(createSplTransferInstruction(
        getAssociatedTokenAddress(
          new import_web36.PublicKey(quote.mctpInputContract),
          user,
          allowSwapperOffCurve
        ),
        ledgerAccount,
        user,
        BigInt(quote.effectiveAmountIn64)
      ))
    );
    if (quote.hasAuction) {
      instructions.push(sandwichInstructionInCpiProxy(createMctpSwapLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.mctpInputContract,
        randomKey: randomKey.publicKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: quote.redeemRelayerFee,
        gasDrop: quote.gasDrop,
        amountInMin64: BigInt(quote.effectiveAmountIn64),
        tokenOut,
        tokenOutDecimals: quote.toToken.decimals,
        referrerAddress,
        amountOutMin: quote.minAmountOut,
        deadline,
        feeRateRef: quote.referrerBps || 0,
        relayerAddress
      }), options.skipProxyMayanInstructions));
      if (!forceSkipCctpInstructions) {
        const {
          instruction: _instruction,
          signer: _signer
        } = createMctpInitSwapInstruction(
          ledger,
          quote.toChain,
          quote.mctpInputContract,
          relayerAddress,
          feeSolana
        );
        instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
        signers.push(_signer);
      }
    } else {
      instructions.push(sandwichInstructionInCpiProxy(createMctpBridgeLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.mctpInputContract,
        randomKey: randomKey.publicKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: quote.redeemRelayerFee,
        gasDrop: quote.gasDrop,
        amountInMin64: BigInt(quote.effectiveAmountIn64),
        mode,
        referrerAddress,
        relayerAddress,
        customPayload: customPayloadAccount
      }), options.skipProxyMayanInstructions));
      if (!forceSkipCctpInstructions) {
        if (mode === "WITH_FEE") {
          const {
            instruction: _instruction,
            signers: _signers
          } = createMctpBridgeWithFeeInstruction(
            ledger,
            quote.toChain,
            quote.mctpInputContract,
            relayerAddress,
            feeSolana,
            quote.fromChain
          );
          instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
          signers.push(..._signers);
        } else {
          const {
            instructions: _instructions,
            signer: _signer
          } = createMctpBridgeLockFeeInstruction(
            ledger,
            quote.toChain,
            quote.mctpInputContract,
            relayerAddress,
            feeSolana
          );
          instructions.push(sandwichInstructionInCpiProxy(_instructions[0]));
          instructions.push(sandwichInstructionInCpiProxy(_instructions[1], options.skipProxyMayanInstructions));
          signers.push(_signer);
        }
      }
    }
  } else {
    if (!quote.minMiddleAmount) {
      throw new Error("Missing minMiddleAmount for swap");
    }
    const clientSwapRaw = await getSwapSolana({
      minMiddleAmount: quote.minMiddleAmount,
      middleToken: quote.mctpInputContract,
      userWallet: swapperAddress,
      userLedger: ledger.toString(),
      slippageBps: quote.slippageBps,
      fromToken: quote.fromToken.contract,
      amountIn64: quote.effectiveAmountIn64,
      depositMode: quote.hasAuction ? "SWAP" : mode,
      fillMaxAccounts: options?.separateSwapTx || false,
      tpmTokenAccount: options?.separateSwapTx ? tmpSwapTokenAccount.publicKey.toString() : null,
      referrerAddress: referrerAddress || null,
      chainName: quote.fromChain
    });
    const clientSwap = decentralizeClientSwapInstructions(clientSwapRaw, connection, relayer);
    if (options?.separateSwapTx && clientSwapRaw.maxAccountsFilled) {
      validateJupSwap(clientSwap, tmpSwapTokenAccount.publicKey, user);
      createSwapTpmTokenAccountInstructions = await createInitializeRandomTokenAccountInstructions(
        connection,
        relayer,
        new import_web36.PublicKey(quote.mctpInputContract),
        user,
        tmpSwapTokenAccount
      );
      swapInstructions.push(...clientSwap.computeBudgetInstructions);
      if (clientSwap.setupInstructions) {
        swapInstructions.push(...clientSwap.setupInstructions);
      }
      swapInstructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        swapInstructions.push(clientSwap.cleanupInstruction);
      }
      _swapAddressLookupTables.push(...clientSwap.addressLookupTableAddresses);
      instructions.push(sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(
        relayer,
        ledgerAccount,
        ledger,
        new import_web36.PublicKey(quote.mctpInputContract)
      )));
      instructions.push(sandwichInstructionInCpiProxy(createTransferAllAndCloseInstruction(
        user,
        new import_web36.PublicKey(quote.mctpInputContract),
        tmpSwapTokenAccount.publicKey,
        ledgerAccount,
        relayer
      )));
    } else {
      validateJupSwap(clientSwap, ledgerAccount, user);
      instructions.push(...clientSwap.computeBudgetInstructions);
      if (clientSwap.setupInstructions) {
        instructions.push(...clientSwap.setupInstructions.map((ins) => sandwichInstructionInCpiProxy(ins)));
      }
      instructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        instructions.push(sandwichInstructionInCpiProxy(clientSwap.cleanupInstruction));
      }
      _lookupTablesAddress.push(...clientSwap.addressLookupTableAddresses);
    }
    const feeSolana = swapInstructions.length > 0 ? BigInt(0) : BigInt(quote.solanaRelayerFee64);
    if (quote.hasAuction) {
      instructions.push(sandwichInstructionInCpiProxy(createMctpSwapLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.mctpInputContract,
        randomKey: randomKey.publicKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: quote.redeemRelayerFee,
        gasDrop: quote.gasDrop,
        amountInMin64: getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS),
        tokenOut,
        tokenOutDecimals: quote.toToken.decimals,
        referrerAddress,
        amountOutMin: quote.minAmountOut,
        deadline,
        feeRateRef: quote.referrerBps || 0,
        relayerAddress
      }), options.skipProxyMayanInstructions));
      if (swapInstructions.length > 0) {
        const {
          instruction: _instruction,
          signer: _signer
        } = createMctpInitSwapInstruction(
          ledger,
          quote.toChain,
          quote.mctpInputContract,
          relayerAddress,
          feeSolana
        );
        instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
        signers.push(_signer);
      }
    } else {
      instructions.push(sandwichInstructionInCpiProxy(createMctpBridgeLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.mctpInputContract,
        randomKey: randomKey.publicKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: quote.redeemRelayerFee,
        gasDrop: quote.gasDrop,
        amountInMin64: getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS),
        mode,
        referrerAddress,
        relayerAddress,
        customPayload: customPayloadAccount
      }), options.skipProxyMayanInstructions));
      if (swapInstructions.length > 0) {
        if (mode === "WITH_FEE") {
          const {
            instruction: _instruction,
            signers: _signers
          } = createMctpBridgeWithFeeInstruction(
            ledger,
            quote.toChain,
            quote.mctpInputContract,
            relayerAddress,
            feeSolana,
            quote.fromChain
          );
          instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
          signers.push(..._signers);
        } else {
          const {
            instructions: _instructions,
            signer: _signer
          } = createMctpBridgeLockFeeInstruction(
            ledger,
            quote.toChain,
            quote.mctpInputContract,
            relayerAddress,
            feeSolana
          );
          instructions.push(sandwichInstructionInCpiProxy(_instructions[0]));
          instructions.push(sandwichInstructionInCpiProxy(_instructions[1], options.skipProxyMayanInstructions));
          signers.push(_signer);
        }
      }
    }
  }
  if (customPayloadAccount) {
    instructions.push(sandwichInstructionInCpiProxy(createPayloadWriterCloseInstruction(
      relayer,
      customPayloadAccount,
      customPayloadNonce
    )));
  }
  const totalLookupTables = await getAddressLookupTableAccounts(_lookupTablesAddress.concat(_swapAddressLookupTables), connection);
  lookupTables = totalLookupTables.slice(0, _lookupTablesAddress.length);
  if (swapInstructions.length > 0) {
    const swapLookupTables = totalLookupTables.slice(_lookupTablesAddress.length);
    swapMessageV0Params = {
      messageV0: {
        payerKey: user,
        instructions: swapInstructions,
        addressLookupTableAccounts: swapLookupTables
      },
      createTmpTokenAccountIxs: createSwapTpmTokenAccountInstructions,
      tmpTokenAccount: tmpSwapTokenAccount
    };
  }
  return { instructions, signers, lookupTables, swapMessageV0Params };
}

// src/solana/solanaSwift.ts
var import_web37 = require("@solana/web3.js");
var import_buffer_layout3 = require("@solana/buffer-layout");
var import_buffer8 = require("buffer");
var import_ethers3 = require("ethers");
function createSwiftOrderHash(quote, swapperAddress, destinationAddress, referrerAddress, randomKeyHex, customPayload) {
  const orderDataSize = quote.swiftVersion === "V2" ? 272 : 239;
  const data = import_buffer8.Buffer.alloc(orderDataSize);
  let offset = 0;
  if (quote.swiftVersion === "V2") {
    const payload_type = customPayload ? SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD : SWIFT_PAYLOAD_TYPE_DEFAULT;
    data.writeUInt8(payload_type, offset);
    offset += 1;
  }
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  const trader = import_buffer8.Buffer.from(hexToUint8Array(nativeAddressToHexString(swapperAddress, sourceChainId)));
  data.set(trader, offset);
  offset += 32;
  data.writeUInt16BE(sourceChainId, offset);
  offset += 2;
  const fromTokenContract = quote.fromChain === "sui" ? quote.swiftVerifiedInputAddress : quote.swiftInputContract;
  const _tokenIn = fromTokenContract === import_ethers3.ZeroAddress ? nativeAddressToHexString(import_web37.SystemProgram.programId.toString(), getWormholeChainIdByName("solana")) : nativeAddressToHexString(fromTokenContract, sourceChainId);
  const tokenIn = import_buffer8.Buffer.from(hexToUint8Array(_tokenIn));
  data.set(tokenIn, offset);
  offset += 32;
  const destinationChainId = getWormholeChainIdByName(quote.toChain);
  const destAddress = import_buffer8.Buffer.from(hexToUint8Array(nativeAddressToHexString(destinationAddress, destinationChainId)));
  data.set(destAddress, offset);
  offset += 32;
  data.writeUInt16BE(destinationChainId, offset);
  offset += 2;
  if (quote.toChain === "sui" && !quote.toToken.verifiedAddress) {
    throw new Error("Missing verified address for SUI coin");
  }
  const _tokenOut = getSwiftToTokenHexString(quote);
  const tokenOut = import_buffer8.Buffer.from(hexToUint8Array(_tokenOut));
  data.set(tokenOut, offset);
  offset += 32;
  data.writeBigUInt64BE(getAmountOfFractionalAmount(
    quote.minAmountOut,
    Math.min(
      quote.toToken.decimals,
      getNormalizeFactor(quote.toChain, quote.type)
    )
  ), offset);
  offset += 8;
  data.writeBigUInt64BE(getAmountOfFractionalAmount(
    quote.gasDrop,
    Math.min(
      getGasDecimal(quote.toChain),
      getNormalizeFactor(quote.toChain, quote.type)
    )
  ), offset);
  offset += 8;
  if (!quote.cancelRelayerFee64 || !quote.refundRelayerFee64) {
    throw new Error("Missing relayer fees");
  }
  data.writeBigUInt64BE(BigInt(quote.cancelRelayerFee64), offset);
  offset += 8;
  data.writeBigUInt64BE(BigInt(quote.refundRelayerFee64), offset);
  offset += 8;
  data.writeBigUInt64BE(BigInt(quote.deadline64), offset);
  offset += 8;
  const referrerChainId = quote.swiftVersion === "V2" ? sourceChainId : destinationChainId;
  const refAddress = referrerAddress ? import_buffer8.Buffer.from(hexToUint8Array(nativeAddressToHexString(referrerAddress, referrerChainId))) : import_web37.SystemProgram.programId.toBuffer();
  data.set(refAddress, offset);
  offset += 32;
  data.writeUInt8(quote.referrerBps || 0, offset);
  offset += 1;
  const feeRateMayan = quote.protocolBps || 0;
  data.writeUInt8(feeRateMayan, offset);
  offset += 1;
  if (!quote.swiftAuctionMode) {
    throw new Error("Missing swift auction mode");
  }
  data.writeUInt8(quote.swiftAuctionMode, offset);
  offset += 1;
  const _randomKey = import_buffer8.Buffer.from(hexToUint8Array(randomKeyHex));
  if (_randomKey.length !== 32) {
    throw new Error("Invalid random key length");
  }
  data.set(_randomKey, offset);
  offset += 32;
  if (quote.swiftVersion === "V2") {
    let customPayloadHash;
    if (customPayload) {
      customPayloadHash = import_buffer8.Buffer.from(hexToUint8Array(import_ethers3.ethers.keccak256(import_buffer8.Buffer.from(customPayload))));
    } else {
      customPayloadHash = import_web37.SystemProgram.programId.toBuffer();
    }
    data.set(customPayloadHash, offset);
    offset += 32;
  }
  if (offset !== orderDataSize) {
    throw new Error(`Invalid order data size: ${offset}`);
  }
  const hash = import_ethers3.ethers.keccak256(data);
  return import_buffer8.Buffer.from(hexToUint8Array(hash));
}
var InitSwiftLayout = (0, import_buffer_layout3.struct)([
  (0, import_buffer_layout3.blob)(8, "instruction"),
  (0, import_buffer_layout3.blob)(8, "amountInMin"),
  (0, import_buffer_layout3.u8)("nativeInput"),
  (0, import_buffer_layout3.blob)(8, "feeSubmit"),
  (0, import_buffer_layout3.blob)(32, "destAddress"),
  (0, import_buffer_layout3.u16)("destinationChain"),
  (0, import_buffer_layout3.blob)(32, "tokenOut"),
  (0, import_buffer_layout3.blob)(8, "amountOutMin"),
  (0, import_buffer_layout3.blob)(8, "gasDrop"),
  (0, import_buffer_layout3.blob)(8, "feeCancel"),
  (0, import_buffer_layout3.blob)(8, "feeRefund"),
  (0, import_buffer_layout3.blob)(8, "deadline"),
  (0, import_buffer_layout3.blob)(32, "refAddress"),
  (0, import_buffer_layout3.u8)("feeRateRef"),
  (0, import_buffer_layout3.u8)("feeRateMayan"),
  (0, import_buffer_layout3.u8)("auctionMode"),
  (0, import_buffer_layout3.blob)(32, "randomKey")
]);
function createSwiftInitInstruction(params) {
  const { quote } = params;
  const mint = quote.swiftInputContract === import_ethers3.ZeroAddress ? solMint : new import_web37.PublicKey(quote.swiftInputContract);
  const destinationChainId = getWormholeChainIdByName(quote.toChain);
  if (destinationChainId !== quote.toToken.wChainId) {
    throw new Error(`Destination chain ID mismatch: ${destinationChainId} != ${quote.toToken.wChainId}`);
  }
  if (params.customPayload && !params.customPayloadAccount) {
    throw new Error("Custom payload account is required when custom payload is provided");
  }
  const accounts = quote.swiftVersion === "V2" ? [
    { pubkey: params.trader, isWritable: false, isSigner: false },
    { pubkey: params.relayer, isWritable: true, isSigner: true },
    { pubkey: params.state, isWritable: true, isSigner: false },
    { pubkey: params.stateAccount, isWritable: true, isSigner: false },
    { pubkey: params.relayerAccount, isWritable: true, isSigner: false },
    {
      pubkey: params.customPayloadAccount || new import_web37.PublicKey(addresses_default.SWIFT_V2_PROGRAM_ID),
      isWritable: false,
      isSigner: false
    },
    { pubkey: mint, isWritable: false, isSigner: false },
    { pubkey: new import_web37.PublicKey(addresses_default.FEE_MANAGER_PROGRAM_ID), isWritable: false, isSigner: false },
    { pubkey: params.tokenProgramId, isWritable: false, isSigner: false },
    { pubkey: import_web37.SystemProgram.programId, isWritable: false, isSigner: false }
  ] : [
    { pubkey: params.trader, isWritable: false, isSigner: true },
    { pubkey: params.relayer, isWritable: true, isSigner: true },
    { pubkey: params.state, isWritable: true, isSigner: false },
    { pubkey: params.stateAccount, isWritable: true, isSigner: false },
    { pubkey: params.relayerAccount, isWritable: true, isSigner: false },
    { pubkey: mint, isWritable: false, isSigner: false },
    { pubkey: new import_web37.PublicKey(addresses_default.FEE_MANAGER_PROGRAM_ID), isWritable: false, isSigner: false },
    { pubkey: new import_web37.PublicKey(addresses_default.TOKEN_PROGRAM_ID), isWritable: false, isSigner: false },
    { pubkey: import_web37.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  accounts.forEach((account, index) => {
    console.log(index, account.pubkey);
  });
  const data = import_buffer8.Buffer.alloc(InitSwiftLayout.span);
  const referrerChainId = quote.swiftVersion === "V2" ? getWormholeChainIdByName("solana") : destinationChainId;
  const refAddress = params.referrerAddress ? import_buffer8.Buffer.from(hexToUint8Array(nativeAddressToHexString(params.referrerAddress, referrerChainId))) : import_web37.SystemProgram.programId.toBuffer();
  let minMiddleAmount;
  if (quote.fromToken.contract === quote.swiftInputContract) {
    minMiddleAmount = BigInt(quote.effectiveAmountIn64);
  } else {
    if (!quote.minMiddleAmount) {
      throw new Error("Missing min middle amount");
    }
    minMiddleAmount = getAmountOfFractionalAmount(quote.minMiddleAmount, quote.swiftInputDecimals);
  }
  if (quote.toChain === "sui" && !quote.toToken.verifiedAddress) {
    throw new Error("Missing verified address for SUI coin");
  }
  if (!quote.cancelRelayerFee64 || !quote.refundRelayerFee64) {
    throw new Error("Missing relayer fees");
  }
  const _tokenOut = getSwiftToTokenHexString(quote);
  if (!quote.submitRelayerFee64) {
    throw new Error("Missing submit relayer fee");
  }
  InitSwiftLayout.encode({
    instruction: getAnchorInstructionData("init_order"),
    amountInMin: getSafeU64Blob(minMiddleAmount),
    nativeInput: quote.swiftInputContract === import_ethers3.ZeroAddress ? 1 : 0,
    feeSubmit: getSafeU64Blob(BigInt(quote.submitRelayerFee64)),
    destAddress: import_buffer8.Buffer.from(hexToUint8Array(nativeAddressToHexString(params.destinationAddress, destinationChainId))),
    destinationChain: destinationChainId,
    tokenOut: import_buffer8.Buffer.from(hexToUint8Array(_tokenOut)),
    amountOutMin: getSafeU64Blob(getAmountOfFractionalAmount(
      quote.minAmountOut,
      Math.min(quote.toToken.decimals, getNormalizeFactor(quote.toChain, quote.type))
    )),
    gasDrop: getSafeU64Blob(getAmountOfFractionalAmount(
      quote.gasDrop,
      Math.min(getGasDecimal(quote.toChain), getNormalizeFactor(quote.toChain, quote.type))
    )),
    feeCancel: getSafeU64Blob(BigInt(quote.cancelRelayerFee64)),
    feeRefund: getSafeU64Blob(BigInt(quote.refundRelayerFee64)),
    deadline: getSafeU64Blob(params.deadline),
    refAddress,
    feeRateRef: quote.referrerBps,
    feeRateMayan: quote.protocolBps,
    auctionMode: quote.swiftAuctionMode,
    randomKey: params.randomKey.toBuffer()
  }, data);
  return new import_web37.TransactionInstruction({
    keys: accounts,
    data,
    programId: new import_web37.PublicKey(quote.swiftVersion === "V2" ? addresses_default.SWIFT_V2_PROGRAM_ID : addresses_default.SWIFT_PROGRAM_ID)
  });
}
async function createSwiftFromSolanaInstructions(quote, swapperAddress, destinationAddress, referrerAddress, connection, options = {}, customPayload, customPayloadAccount) {
  if (quote.type !== "SWIFT") {
    throw new Error("Unsupported quote type for Swift: " + quote.type);
  }
  if (quote.toChain === quote.fromChain) {
    throw new Error("Unsupported same chains: " + quote.toChain);
  }
  if (quote.swiftVersion !== "V2" && (quote.toChain === "sui" || quote.toChain === "ton" || quote.toChain === "fogo")) {
    throw new Error("Swift V2 is required for" + quote.toChain);
  }
  const quoteSwiftVersion = quote.swiftVersion;
  const allowSwapperOffCurve = options.allowSwapperOffCurve || false;
  let instructions = [];
  let lookupTables = [];
  let _lookupTablesAddress = [];
  _lookupTablesAddress.push(getLookupTableAddress(quote.fromChain));
  let _swapAddressLookupTables = [];
  let swapInstructions = [];
  let createSwapTpmTokenAccountInstructions = [];
  const tmpSwapTokenAccount = import_web37.Keypair.generate();
  let swapMessageV0Params = null;
  const trader = new import_web37.PublicKey(swapperAddress);
  const randomKey = new import_web37.PublicKey(createSwiftRandomKey(quote));
  if (!Number(quote.deadline64)) {
    throw new Error("Swift mode requires a timeout");
  }
  const deadline = BigInt(quote.deadline64);
  if (customPayload && !customPayloadAccount) {
    throw new Error("Custom payload account is required when custom payload is provided");
  }
  const hash = createSwiftOrderHash(
    quote,
    swapperAddress,
    destinationAddress,
    referrerAddress,
    randomKey.toBuffer().toString("hex"),
    customPayload
  );
  const chainDestBuffer = import_buffer8.Buffer.alloc(2);
  chainDestBuffer.writeUInt16LE(getWormholeChainIdByName(quote.toChain));
  const [state] = quote.swiftVersion === "V2" ? import_web37.PublicKey.findProgramAddressSync(
    [import_buffer8.Buffer.from("STATE_SOURCE"), hash, chainDestBuffer],
    new import_web37.PublicKey(addresses_default.SWIFT_V2_PROGRAM_ID)
  ) : import_web37.PublicKey.findProgramAddressSync(
    [import_buffer8.Buffer.from("STATE_SOURCE"), hash],
    new import_web37.PublicKey(addresses_default.SWIFT_PROGRAM_ID)
  );
  let tokenProgramId;
  if (quote.swiftVersion === "V2") {
    tokenProgramId = quote.swiftInputContractStandard === "spl2022" ? new import_web37.PublicKey(addresses_default.TOKEN_2022_PROGRAM_ID) : new import_web37.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  } else {
    tokenProgramId = new import_web37.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  }
  console.log({ tokenProgramId });
  const swiftInputMint = quote.swiftInputContract === import_ethers3.ZeroAddress ? solMint : new import_web37.PublicKey(quote.swiftInputContract);
  const stateAccount = getAssociatedTokenAddress(
    swiftInputMint,
    state,
    true,
    tokenProgramId
  );
  const relayer = quote.gasless ? new import_web37.PublicKey(quote.relayer) : trader;
  const relayerAccount = getAssociatedTokenAddress(swiftInputMint, relayer, false, tokenProgramId);
  if (quote.fromToken.contract === quote.swiftInputContract) {
    if (quote.suggestedPriorityFee > 0) {
      instructions.push(import_web37.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: quote.suggestedPriorityFee
      }));
    }
    instructions.push(
      sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(relayer, stateAccount, state, swiftInputMint, tokenProgramId))
    );
    if (quote.swiftInputContract === import_ethers3.ZeroAddress) {
      instructions.push(
        sandwichInstructionInCpiProxy(import_web37.SystemProgram.transfer({
          fromPubkey: trader,
          toPubkey: stateAccount,
          lamports: BigInt(quote.effectiveAmountIn64)
        })),
        sandwichInstructionInCpiProxy(createSyncNativeInstruction(stateAccount))
      );
    } else {
      instructions.push(
        sandwichInstructionInCpiProxy(createSplTransferInstruction(
          getAssociatedTokenAddress(
            swiftInputMint,
            trader,
            allowSwapperOffCurve,
            tokenProgramId
          ),
          stateAccount,
          trader,
          BigInt(quote.effectiveAmountIn64),
          tokenProgramId
        ))
      );
    }
  } else {
    if (!quote.minMiddleAmount) {
      throw new Error("Missing min middle amount for swap");
    }
    const clientSwapRaw = await getSwapSolana({
      minMiddleAmount: quote.minMiddleAmount,
      middleToken: quote.swiftInputContract,
      userWallet: swapperAddress,
      slippageBps: quote.slippageBps,
      fromToken: quote.fromToken.contract,
      amountIn64: quote.effectiveAmountIn64,
      depositMode: quote.gasless ? "SWIFT_GASLESS" : "SWIFT",
      fillMaxAccounts: options?.separateSwapTx || false,
      tpmTokenAccount: options?.separateSwapTx ? tmpSwapTokenAccount.publicKey.toString() : null,
      referrerAddress: referrerAddress || void 0,
      chainName: quote.fromChain,
      userLedger: state.toString()
    });
    if (quote.swiftVersion !== quoteSwiftVersion) {
      throw new Error("Quote mutation is not allowed");
    }
    const clientSwap = decentralizeClientSwapInstructions(clientSwapRaw, connection, relayer);
    if (options?.separateSwapTx && clientSwapRaw.maxAccountsFilled) {
      validateJupSwap(clientSwap, tmpSwapTokenAccount.publicKey, trader);
      createSwapTpmTokenAccountInstructions = await createInitializeRandomTokenAccountInstructions(
        connection,
        relayer,
        swiftInputMint,
        trader,
        tmpSwapTokenAccount,
        tokenProgramId
      );
      if (quote.swiftVersion !== quoteSwiftVersion) {
        throw new Error("Quote mutation is not allowed");
      }
      swapInstructions.push(...clientSwap.computeBudgetInstructions);
      if (clientSwap.setupInstructions) {
        swapInstructions.push(...clientSwap.setupInstructions);
      }
      swapInstructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        swapInstructions.push(clientSwap.cleanupInstruction);
      }
      _swapAddressLookupTables.push(...clientSwap.addressLookupTableAddresses);
      instructions.push(sandwichInstructionInCpiProxy(
        createAssociatedTokenAccountInstruction(relayer, stateAccount, state, swiftInputMint, tokenProgramId)
      ));
      instructions.push(sandwichInstructionInCpiProxy(createTransferAllAndCloseInstruction(
        trader,
        swiftInputMint,
        tmpSwapTokenAccount.publicKey,
        stateAccount,
        relayer,
        tokenProgramId
      )));
    } else {
      validateJupSwap(clientSwap, stateAccount, trader);
      instructions.push(...clientSwap.computeBudgetInstructions);
      if (clientSwap.setupInstructions) {
        instructions.push(...clientSwap.setupInstructions.map((ins) => sandwichInstructionInCpiProxy(ins)));
      }
      instructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        instructions.push(sandwichInstructionInCpiProxy(clientSwap.cleanupInstruction));
      }
      _lookupTablesAddress.push(...clientSwap.addressLookupTableAddresses);
    }
  }
  instructions.push(sandwichInstructionInCpiProxy(createSwiftInitInstruction({
    quote,
    state,
    trader,
    stateAccount,
    randomKey,
    relayerAccount,
    relayer,
    destinationAddress,
    deadline,
    referrerAddress,
    tokenProgramId,
    customPayload,
    customPayloadAccount: customPayloadAccount ? new import_web37.PublicKey(customPayloadAccount) : void 0
  }), options.skipProxyMayanInstructions));
  const totalLookupTables = await getAddressLookupTableAccounts(_lookupTablesAddress.concat(_swapAddressLookupTables), connection);
  lookupTables = totalLookupTables.slice(0, _lookupTablesAddress.length);
  if (swapInstructions.length > 0) {
    const swapLookupTables = totalLookupTables.slice(_lookupTablesAddress.length);
    swapMessageV0Params = {
      messageV0: {
        payerKey: relayer,
        instructions: swapInstructions,
        addressLookupTableAccounts: swapLookupTables
      },
      createTmpTokenAccountIxs: createSwapTpmTokenAccountInstructions,
      tmpTokenAccount: tmpSwapTokenAccount
    };
  }
  console.log({
    randomKey: randomKey.toBuffer().toString("hex"),
    hash: hash.toString("hex")
  });
  if (quote.swiftVersion !== quoteSwiftVersion) {
    throw new Error("Quote mutation is not allowed");
  }
  return { instructions, signers: [], lookupTables, swapMessageV0Params };
}

// src/solana/solanaSwap.ts
var import_bs582 = __toESM(require("bs58"));

// src/solana/solanaHyperCore.ts
var import_web39 = require("@solana/web3.js");
var import_buffer10 = require("buffer");

// src/solana/solanaFastMctp.ts
var import_web38 = require("@solana/web3.js");
var import_buffer_layout4 = require("@solana/buffer-layout");
var import_buffer9 = require("buffer");
var FastMctpBridgeLayout = (0, import_buffer_layout4.struct)([
  (0, import_buffer_layout4.blob)(8, "instruction")
]);
function createFastMctpBridgeInstruction(ledger, trader, toChain, mintAddress, relayerAddress, feeSolana) {
  const TOKEN_PROGRAM_ID = new import_web38.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  const cctpCoreProgramId = new import_web38.PublicKey(addresses_default.CCTPV2_CORE_PROGRAM_ID);
  const cctpTokenProgramId = new import_web38.PublicKey(addresses_default.CCTPV2_TOKEN_PROGRAM_ID);
  const fastMctpProgram = new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID);
  const relayer = new import_web38.PublicKey(relayerAddress);
  const mint = new import_web38.PublicKey(mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(
    mint,
    ledger,
    true
  );
  let relayerAccount;
  if (feeSolana && feeSolana > BigInt(0)) {
    relayerAccount = getAssociatedTokenAddress(mint, relayer, false);
  } else {
    relayerAccount = new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID);
  }
  const cctpV2BridgePdas = getCCTPV2BridgePDAs(
    mint,
    toChain,
    ledger,
    trader
  );
  const cctpMessage = import_web38.Keypair.generate();
  const accounts = [
    { pubkey: ledger, isWritable: true, isSigner: false },
    { pubkey: ledgerAccount, isWritable: true, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: relayerAccount, isWritable: true, isSigner: false },
    { pubkey: mint, isWritable: true, isSigner: false },
    { pubkey: cctpV2BridgePdas.realDenyListAccount, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.senderAuthority, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.cctpDenyListAccount, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.tokenMessenger, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.remoteTokenMessengerKey, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.tokenMinter, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.localToken, isWritable: true, isSigner: false },
    { pubkey: cctpV2BridgePdas.eventAuthToken, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.messageTransmitter, isWritable: true, isSigner: false },
    { pubkey: cctpMessage.publicKey, isWritable: true, isSigner: true },
    { pubkey: cctpCoreProgramId, isWritable: false, isSigner: false },
    { pubkey: cctpTokenProgramId, isWritable: false, isSigner: false },
    { pubkey: TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
    { pubkey: import_web38.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const data = import_buffer9.Buffer.alloc(FastMctpBridgeLayout.span);
  FastMctpBridgeLayout.encode(
    {
      instruction: getAnchorInstructionData("bridge")
    },
    data
  );
  const bridgeIns = new import_web38.TransactionInstruction({
    keys: accounts,
    data,
    programId: fastMctpProgram
  });
  return { instruction: bridgeIns, signers: [cctpMessage] };
}
var FastMctpInitOrderLayout = (0, import_buffer_layout4.struct)([
  (0, import_buffer_layout4.blob)(8, "instruction")
]);
function createFastMctpInitOrderInstruction(ledger, trader, toChain, mintAddress, relayerAddress, feeSolana) {
  const TOKEN_PROGRAM_ID = new import_web38.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  const cctpCoreProgramId = new import_web38.PublicKey(addresses_default.CCTPV2_CORE_PROGRAM_ID);
  const cctpTokenProgramId = new import_web38.PublicKey(addresses_default.CCTPV2_TOKEN_PROGRAM_ID);
  const fastMctpProgram = new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID);
  const relayer = new import_web38.PublicKey(relayerAddress);
  const mint = new import_web38.PublicKey(mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(
    mint,
    ledger,
    true
  );
  const cctpV2BridgePdas = getCCTPV2BridgePDAs(
    mint,
    toChain,
    ledger,
    trader
  );
  const cctpMessage = import_web38.Keypair.generate();
  let relayerAccount;
  if (feeSolana && feeSolana > BigInt(0)) {
    relayerAccount = getAssociatedTokenAddress(mint, relayer, false);
  } else {
    relayerAccount = new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID);
  }
  const accounts = [
    { pubkey: ledger, isWritable: false, isSigner: false },
    { pubkey: ledgerAccount, isWritable: true, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: relayerAccount, isWritable: true, isSigner: false },
    { pubkey: mint, isWritable: true, isSigner: false },
    { pubkey: cctpV2BridgePdas.realDenyListAccount, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.senderAuthority, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.cctpDenyListAccount, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.tokenMessenger, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.remoteTokenMessengerKey, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.tokenMinter, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.localToken, isWritable: true, isSigner: false },
    { pubkey: cctpV2BridgePdas.eventAuthToken, isWritable: false, isSigner: false },
    { pubkey: cctpV2BridgePdas.messageTransmitter, isWritable: true, isSigner: false },
    { pubkey: cctpMessage.publicKey, isWritable: true, isSigner: true },
    { pubkey: cctpCoreProgramId, isWritable: false, isSigner: false },
    { pubkey: cctpTokenProgramId, isWritable: false, isSigner: false },
    { pubkey: TOKEN_PROGRAM_ID, isWritable: false, isSigner: false },
    { pubkey: import_web38.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const data = import_buffer9.Buffer.alloc(FastMctpInitOrderLayout.span);
  FastMctpInitOrderLayout.encode(
    {
      instruction: getAnchorInstructionData("create_order")
    },
    data
  );
  const initOrderIns = new import_web38.TransactionInstruction({
    keys: accounts,
    data,
    programId: fastMctpProgram
  });
  return { instruction: initOrderIns, signer: cctpMessage };
}
var FastMctpBridgeLedgerLayout = (0, import_buffer_layout4.struct)([
  (0, import_buffer_layout4.blob)(8, "instruction"),
  (0, import_buffer_layout4.blob)(32, "destAddress"),
  (0, import_buffer_layout4.blob)(8, "amountInMin"),
  (0, import_buffer_layout4.blob)(8, "gasDrop"),
  (0, import_buffer_layout4.blob)(8, "feeRedeem"),
  (0, import_buffer_layout4.blob)(8, "feeSolana"),
  (0, import_buffer_layout4.u32)("destDomain"),
  (0, import_buffer_layout4.blob)(32, "refAddress"),
  (0, import_buffer_layout4.u8)("feeRateRef"),
  (0, import_buffer_layout4.u16)("keyRnd"),
  (0, import_buffer_layout4.blob)(8, "maxCircleFee"),
  (0, import_buffer_layout4.u32)("minFinalityThreshold"),
  (0, import_buffer_layout4.u8)("mode")
]);
function createFastMctpBridgeLedgerInstruction(params) {
  const user = new import_web38.PublicKey(params.swapperAddress);
  const relayer = new import_web38.PublicKey(params.relayerAddress);
  const mint = new import_web38.PublicKey(params.mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(mint, params.ledger, true);
  const destinationChainId = getWormholeChainIdByName(params.toChain);
  const destAddress = import_buffer9.Buffer.from(
    hexToUint8Array(
      nativeAddressToHexString(params.destinationAddress, destinationChainId)
    )
  );
  const amountInMin = getSafeU64Blob(params.amountInMin64);
  const gasDrop = getSafeU64Blob(
    getAmountOfFractionalAmount(params.gasDrop, Math.min(getGasDecimal(params.toChain), 8))
  );
  const feeRedeem = getSafeU64Blob(params.feeRedeem);
  const feeSolana = getSafeU64Blob(params.feeSolana);
  const maxCircleFee = getSafeU64Blob(params.maxCircleFee);
  const refAddress = params.referrerAddress ? import_buffer9.Buffer.from(hexToUint8Array(
    nativeAddressToHexString(params.referrerAddress, destinationChainId)
  )) : import_web38.SystemProgram.programId.toBuffer();
  const destinationChainDomain = getCCTPDomain(params.toChain);
  const accounts = [
    { pubkey: user, isWritable: true, isSigner: true },
    { pubkey: params.ledger, isWritable: true, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: ledgerAccount, isWritable: false, isSigner: false },
    { pubkey: params.customPayload || new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID), isWritable: false, isSigner: false },
    { pubkey: mint, isWritable: false, isSigner: false },
    { pubkey: import_web38.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const data = import_buffer9.Buffer.alloc(FastMctpBridgeLedgerLayout.span);
  FastMctpBridgeLedgerLayout.encode(
    {
      instruction: getAnchorInstructionData("init_bridge_ledger"),
      destAddress,
      amountInMin,
      gasDrop,
      feeRedeem,
      feeSolana,
      destDomain: destinationChainDomain,
      refAddress,
      feeRateRef: params.feeRateRef ?? 0,
      keyRnd: params.randomKey,
      maxCircleFee,
      minFinalityThreshold: params.minFinalityThreshold,
      mode: 1
      // Bridge Mode
    },
    data
  );
  return new import_web38.TransactionInstruction({
    keys: accounts,
    data,
    programId: new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID)
  });
}
var FastMctpOrderLedgerLayout = (0, import_buffer_layout4.struct)([
  (0, import_buffer_layout4.blob)(8, "instruction"),
  (0, import_buffer_layout4.blob)(32, "destAddress"),
  (0, import_buffer_layout4.blob)(8, "amountInMin"),
  (0, import_buffer_layout4.blob)(8, "gasDrop"),
  (0, import_buffer_layout4.blob)(8, "feeRedeem"),
  (0, import_buffer_layout4.blob)(8, "feeRefund"),
  (0, import_buffer_layout4.blob)(8, "feeSolana"),
  (0, import_buffer_layout4.u32)("destDomain"),
  (0, import_buffer_layout4.u16)("keyRnd"),
  (0, import_buffer_layout4.u8)("mode"),
  (0, import_buffer_layout4.blob)(32, "tokenOut"),
  (0, import_buffer_layout4.blob)(8, "amountOutMin"),
  (0, import_buffer_layout4.blob)(8, "deadline"),
  (0, import_buffer_layout4.blob)(32, "refAddress"),
  (0, import_buffer_layout4.u8)("feeRateRef"),
  (0, import_buffer_layout4.blob)(8, "maxCircleFee"),
  (0, import_buffer_layout4.u32)("minFinalityThreshold")
]);
function createFastMctpOrderLedgerInstruction(params) {
  const user = new import_web38.PublicKey(params.swapperAddress);
  const relayer = new import_web38.PublicKey(params.relayerAddress);
  const mint = new import_web38.PublicKey(params.mintAddress);
  const ledgerAccount = getAssociatedTokenAddress(mint, params.ledger, true);
  const destinationChainId = getWormholeChainIdByName(params.toChain);
  const destinationChainDomain = getCCTPDomain(params.toChain);
  const destAddress = import_buffer9.Buffer.from(
    hexToUint8Array(
      nativeAddressToHexString(params.destinationAddress, destinationChainId)
    )
  );
  const amountInMin = getSafeU64Blob(params.amountInMin64);
  const gasDrop = getSafeU64Blob(
    getAmountOfFractionalAmount(params.gasDrop, Math.min(getGasDecimal(params.toChain), 8))
  );
  const feeRedeem = getSafeU64Blob(params.feeRedeem);
  const feeRefund = getSafeU64Blob(params.feeRefund);
  const feeSolana = getSafeU64Blob(params.feeSolana);
  const maxCircleFee = getSafeU64Blob(params.maxCircleFee);
  const tokenOut = import_buffer9.Buffer.from(hexToUint8Array(
    nativeAddressToHexString(params.tokenOut, destinationChainId)
  ));
  const refAddress = params.referrerAddress ? import_buffer9.Buffer.from(hexToUint8Array(
    nativeAddressToHexString(params.referrerAddress, destinationChainId)
  )) : import_web38.SystemProgram.programId.toBuffer();
  const amountOutMin = getSafeU64Blob(
    getAmountOfFractionalAmount(params.amountOutMin, Math.min(8, params.tokenOutDecimals))
  );
  const deadline = getSafeU64Blob(params.deadline);
  const accounts = [
    { pubkey: user, isWritable: true, isSigner: true },
    { pubkey: params.ledger, isWritable: true, isSigner: false },
    { pubkey: relayer, isWritable: true, isSigner: true },
    { pubkey: ledgerAccount, isWritable: false, isSigner: false },
    { pubkey: mint, isWritable: false, isSigner: false },
    { pubkey: import_web38.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const data = import_buffer9.Buffer.alloc(FastMctpOrderLedgerLayout.span);
  FastMctpOrderLedgerLayout.encode(
    {
      instruction: getAnchorInstructionData("init_order_ledger"),
      destAddress,
      amountInMin,
      gasDrop,
      feeRedeem,
      feeRefund,
      feeSolana,
      destDomain: destinationChainDomain,
      keyRnd: params.randomKey,
      maxCircleFee,
      minFinalityThreshold: params.minFinalityThreshold,
      mode: 2,
      // Order Mode
      tokenOut,
      amountOutMin,
      deadline,
      refAddress,
      feeRateRef: params.feeRateRef
    },
    data
  );
  return new import_web38.TransactionInstruction({
    keys: accounts,
    data,
    programId: new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID)
  });
}
async function createFastMctpFromSolanaInstructions(quote, swapperAddress, destinationAddress, referrerAddress, connection, options = {}) {
  const forceSkipCctpInstructions = options?.forceSkipCctpInstructions || false;
  const allowSwapperOffCurve = options?.allowSwapperOffCurve || false;
  if (quote.toChain === "solana") {
    throw new Error("Unsupported destination chain: " + quote.toChain);
  }
  const relayerAddress = quote.relayer || swapperAddress;
  let _lookupTablesAddress = [];
  let instructions = [];
  let signers = [];
  let lookupTables = [];
  let _swapAddressLookupTables = [];
  let swapInstructions = [];
  let createSwapTpmTokenAccountInstructions = [];
  const tmpSwapTokenAccount = import_web38.Keypair.generate();
  let swapMessageV0Params = null;
  _lookupTablesAddress.push(getLookupTableAddress(quote.fromChain));
  const fastMctpProgram = new import_web38.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID);
  const user = new import_web38.PublicKey(swapperAddress);
  const relayer = new import_web38.PublicKey(relayerAddress);
  const randomKey = Math.floor(Math.random() * 65e3);
  const deadline = quote.deadline64 ? BigInt(quote.deadline64) : BigInt(0);
  if (quote.hasAuction && !Number(quote.deadline64)) {
    throw new Error("Swap mode requires a timeout");
  }
  const ledgerSeedPrefix = quote.hasAuction ? "LEDGER_ORDER" : "LEDGER_BRIDGE";
  const [ledger] = import_web38.PublicKey.findProgramAddressSync(
    [
      import_buffer9.Buffer.from(ledgerSeedPrefix),
      user.toBytes(),
      (() => {
        const buf = import_buffer9.Buffer.alloc(2);
        buf.writeUInt16LE(randomKey, 0);
        return buf;
      })()
    ],
    fastMctpProgram
  );
  const ledgerAccount = getAssociatedTokenAddress(
    new import_web38.PublicKey(quote.fastMctpInputContract),
    ledger,
    true
  );
  if (quote.toChain === "sui" && !quote.toToken.verifiedAddress) {
    throw new Error("Missing verified address for SUI coin");
  }
  const tokenOut = quote.toChain === "sui" ? quote.toToken.verifiedAddress : quote.toToken.contract;
  if (!tokenOut) {
    throw new Error("Missing tokenOut address in quote");
  }
  if (quote.toChain === "sui") {
    throw new Error("Fast MCTP does not support SUI as destination chain");
  }
  if (options.customPayload && quote.hasAuction) {
    throw new Error("Cannot use customPayload with create Fast Mctp swap");
  }
  let customPayloadAccount = null;
  const customPayloadNonce = Math.floor(Math.random() * 65e3);
  if (options.customPayload) {
    customPayloadAccount = import_web38.PublicKey.findProgramAddressSync(
      [
        import_buffer9.Buffer.from("PAYLOAD"),
        relayer.toBuffer(),
        (() => {
          const buf = import_buffer9.Buffer.alloc(2);
          buf.writeUInt16LE(customPayloadNonce, 0);
          return buf;
        })()
      ],
      new import_web38.PublicKey(addresses_default.PAYLOAD_WRITER_PROGRAM_ID)
    )[0];
    instructions.push(
      sandwichInstructionInCpiProxy(createPayloadWriterCreateInstruction(
        relayer,
        customPayloadAccount,
        import_buffer9.Buffer.from(options.customPayload),
        customPayloadNonce
      ))
    );
  }
  if (!quote.redeemRelayerFee64) {
    throw new Error("Missing redeem relayer fee in quote");
  }
  if (quote.fromToken.contract === quote.fastMctpInputContract) {
    const feeSolana = forceSkipCctpInstructions ? BigInt(quote.solanaRelayerFee64) : BigInt(0);
    if (quote.suggestedPriorityFee > 0) {
      instructions.push(import_web38.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: quote.suggestedPriorityFee
      }));
    }
    instructions.push(
      sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(relayer, ledgerAccount, ledger, new import_web38.PublicKey(quote.fastMctpInputContract)))
    );
    instructions.push(
      sandwichInstructionInCpiProxy(createSplTransferInstruction(
        getAssociatedTokenAddress(
          new import_web38.PublicKey(quote.fastMctpInputContract),
          user,
          allowSwapperOffCurve
        ),
        ledgerAccount,
        user,
        BigInt(quote.effectiveAmountIn64)
      ))
    );
    if (quote.hasAuction) {
      if (!quote.refundRelayerFee64) {
        throw new Error("Missing refund relayer fee in quote");
      }
      instructions.push(sandwichInstructionInCpiProxy(createFastMctpOrderLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.fastMctpInputContract,
        randomKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: BigInt(quote.redeemRelayerFee64),
        feeRefund: BigInt(quote.refundRelayerFee64),
        gasDrop: quote.gasDrop,
        amountInMin64: BigInt(quote.effectiveAmountIn64),
        tokenOut,
        tokenOutDecimals: quote.toToken.decimals,
        referrerAddress,
        amountOutMin: quote.minAmountOut,
        deadline,
        feeRateRef: quote.referrerBps || 0,
        relayerAddress,
        maxCircleFee: BigInt(quote.circleMaxFee64),
        minFinalityThreshold: quote.fastMctpMinFinality
      }), options.skipProxyMayanInstructions));
      if (!forceSkipCctpInstructions) {
        const {
          instruction: _instruction,
          signer: _signer
        } = createFastMctpInitOrderInstruction(
          ledger,
          user,
          quote.toChain,
          quote.fastMctpInputContract,
          relayerAddress,
          feeSolana
        );
        instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
        signers.push(_signer);
      }
    } else {
      instructions.push(sandwichInstructionInCpiProxy(createFastMctpBridgeLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.fastMctpInputContract,
        randomKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: BigInt(quote.redeemRelayerFee64),
        gasDrop: quote.gasDrop,
        amountInMin64: BigInt(quote.effectiveAmountIn64),
        referrerAddress,
        relayerAddress,
        customPayload: customPayloadAccount,
        feeRateRef: quote.referrerBps || 0,
        maxCircleFee: BigInt(quote.circleMaxFee64),
        minFinalityThreshold: quote.fastMctpMinFinality
      }), options.skipProxyMayanInstructions));
      if (!forceSkipCctpInstructions) {
        const {
          instruction: _instruction,
          signers: _signers
        } = createFastMctpBridgeInstruction(
          ledger,
          user,
          quote.toChain,
          quote.fastMctpInputContract,
          relayerAddress,
          feeSolana
        );
        instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
        signers.push(..._signers);
      }
    }
  } else {
    if (!quote.minMiddleAmount) {
      throw new Error("Missing min middle amount in quote");
    }
    const clientSwapRaw = await getSwapSolana({
      minMiddleAmount: quote.minMiddleAmount,
      middleToken: quote.fastMctpInputContract,
      userWallet: swapperAddress,
      userLedger: ledger.toString(),
      slippageBps: quote.slippageBps,
      fromToken: quote.fromToken.contract,
      amountIn64: quote.effectiveAmountIn64,
      depositMode: quote.hasAuction ? "FAST_MCTP_ORDER" : "FAST_MCTP_BRIDGE",
      fillMaxAccounts: options?.separateSwapTx || false,
      tpmTokenAccount: options?.separateSwapTx ? tmpSwapTokenAccount.publicKey.toString() : null,
      referrerAddress: referrerAddress || null,
      chainName: quote.fromChain
    });
    const clientSwap = decentralizeClientSwapInstructions(clientSwapRaw, connection, relayer);
    if (options?.separateSwapTx && clientSwapRaw.maxAccountsFilled) {
      validateJupSwap(clientSwap, tmpSwapTokenAccount.publicKey, user);
      createSwapTpmTokenAccountInstructions = await createInitializeRandomTokenAccountInstructions(
        connection,
        relayer,
        new import_web38.PublicKey(quote.fastMctpInputContract),
        user,
        tmpSwapTokenAccount
      );
      swapInstructions.push(...clientSwap.computeBudgetInstructions);
      if (clientSwap.setupInstructions) {
        swapInstructions.push(...clientSwap.setupInstructions);
      }
      swapInstructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        swapInstructions.push(clientSwap.cleanupInstruction);
      }
      _swapAddressLookupTables.push(...clientSwap.addressLookupTableAddresses);
      instructions.push(sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(
        relayer,
        ledgerAccount,
        ledger,
        new import_web38.PublicKey(quote.fastMctpInputContract)
      )));
      instructions.push(sandwichInstructionInCpiProxy(createTransferAllAndCloseInstruction(
        user,
        new import_web38.PublicKey(quote.fastMctpInputContract),
        tmpSwapTokenAccount.publicKey,
        ledgerAccount,
        relayer
      )));
    } else {
      validateJupSwap(clientSwap, ledgerAccount, user);
      instructions.push(...clientSwap.computeBudgetInstructions);
      if (clientSwap.setupInstructions) {
        instructions.push(...clientSwap.setupInstructions.map((ins) => sandwichInstructionInCpiProxy(ins)));
      }
      instructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        instructions.push(sandwichInstructionInCpiProxy(clientSwap.cleanupInstruction));
      }
      _lookupTablesAddress.push(...clientSwap.addressLookupTableAddresses);
    }
    const feeSolana = swapInstructions.length > 0 ? BigInt(0) : BigInt(quote.solanaRelayerFee64);
    if (quote.hasAuction) {
      if (!quote.refundRelayerFee64) {
        throw new Error("Missing refund relayer fee in quote");
      }
      instructions.push(sandwichInstructionInCpiProxy(createFastMctpOrderLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.fastMctpInputContract,
        randomKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: BigInt(quote.redeemRelayerFee64),
        feeRefund: BigInt(quote.refundRelayerFee64),
        gasDrop: quote.gasDrop,
        amountInMin64: getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS),
        tokenOut,
        tokenOutDecimals: quote.toToken.decimals,
        referrerAddress,
        amountOutMin: quote.minAmountOut,
        deadline,
        feeRateRef: quote.referrerBps || 0,
        relayerAddress,
        maxCircleFee: BigInt(quote.circleMaxFee64),
        minFinalityThreshold: quote.fastMctpMinFinality
      }), options.skipProxyMayanInstructions));
      if (swapInstructions.length > 0) {
        const {
          instruction: _instruction,
          signer: _signer
        } = createFastMctpInitOrderInstruction(
          ledger,
          user,
          quote.toChain,
          quote.fastMctpInputContract,
          relayerAddress,
          feeSolana
        );
        instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
        signers.push(_signer);
      }
    } else {
      instructions.push(sandwichInstructionInCpiProxy(createFastMctpBridgeLedgerInstruction({
        ledger,
        swapperAddress,
        mintAddress: quote.fastMctpInputContract,
        randomKey,
        toChain: quote.toChain,
        destinationAddress,
        feeSolana,
        feeRedeem: BigInt(quote.redeemRelayerFee64),
        gasDrop: quote.gasDrop,
        amountInMin64: getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS),
        referrerAddress,
        feeRateRef: quote.referrerBps || 0,
        relayerAddress,
        customPayload: customPayloadAccount,
        maxCircleFee: BigInt(quote.circleMaxFee64),
        minFinalityThreshold: quote.fastMctpMinFinality
      }), options.skipProxyMayanInstructions));
      if (swapInstructions.length > 0) {
        const {
          instruction: _instruction,
          signers: _signers
        } = createFastMctpBridgeInstruction(
          ledger,
          user,
          quote.toChain,
          quote.fastMctpInputContract,
          relayerAddress,
          feeSolana
        );
        instructions.push(sandwichInstructionInCpiProxy(_instruction, options.skipProxyMayanInstructions));
        signers.push(..._signers);
      }
    }
  }
  if (customPayloadAccount) {
    instructions.push(sandwichInstructionInCpiProxy(createPayloadWriterCloseInstruction(
      relayer,
      customPayloadAccount,
      customPayloadNonce
    )));
  }
  const totalLookupTables = await getAddressLookupTableAccounts(_lookupTablesAddress.concat(_swapAddressLookupTables), connection);
  lookupTables = totalLookupTables.slice(0, _lookupTablesAddress.length);
  if (swapInstructions.length > 0) {
    const swapLookupTables = totalLookupTables.slice(_lookupTablesAddress.length);
    swapMessageV0Params = {
      messageV0: {
        payerKey: user,
        instructions: swapInstructions,
        addressLookupTableAccounts: swapLookupTables
      },
      createTmpTokenAccountIxs: createSwapTpmTokenAccountInstructions,
      tmpTokenAccount: tmpSwapTokenAccount
    };
  }
  return { instructions, signers, lookupTables, swapMessageV0Params };
}

// src/solana/solanaHyperCore.ts
async function createHyperCoreDepositFromSolanaInstructions(quote, swapperAddress, destinationAddress, referrerAddress, connection, options = {}) {
  if (quote.toToken.contract.toLowerCase() !== addresses_default.ARBITRUM_USDC_CONTRACT.toLowerCase() || quote.type !== "MCTP" && quote.type !== "FAST_MCTP") {
    throw new Error("Unsupported quote type for USDC deposit: " + quote.type);
  }
  if (!options?.usdcPermitSignature) {
    throw new Error("USDC permit signature is required for this quote");
  }
  if (!quote.hyperCoreParams) {
    throw new Error("HyperCore parameters are required for this quote");
  }
  if (!Number(quote.deadline64)) {
    throw new Error("HyperCore deposit requires timeout");
  }
  const allowSwapperOffCurve = options.allowSwapperOffCurve || false;
  let instructions = [];
  let signers = [];
  let lookupTables = [];
  let _lookupTablesAddress = [];
  _lookupTablesAddress.push(getLookupTableAddress(quote.fromChain));
  let _swapAddressLookupTables = [];
  let swapInstructions = [];
  let createSwapTpmTokenAccountInstructions = [];
  const tmpSwapTokenAccount = import_web39.Keypair.generate();
  let swapMessageV0Params = null;
  const trader = new import_web39.PublicKey(swapperAddress);
  const relayerAddress = quote.relayer || swapperAddress;
  const inputMint = new import_web39.PublicKey(quote.hyperCoreParams.initiateTokenContract);
  const payloadNonce = Math.floor(Math.random() * 65e3);
  const [payloadAccount] = import_web39.PublicKey.findProgramAddressSync(
    [
      import_buffer10.Buffer.from("PAYLOAD"),
      trader.toBuffer(),
      (() => {
        const buf = import_buffer10.Buffer.alloc(2);
        buf.writeUInt16LE(payloadNonce, 0);
        return buf;
      })()
    ],
    new import_web39.PublicKey(addresses_default.PAYLOAD_WRITER_PROGRAM_ID)
  );
  const payload = getHyperCoreUSDCDepositCustomPayload(quote, destinationAddress, options.usdcPermitSignature);
  const mctpRandomKey = import_web39.Keypair.generate();
  const mctpProgram = new import_web39.PublicKey(addresses_default.MCTP_PROGRAM_ID);
  const fastMctpRandomKey = Math.floor(Math.random() * 65e3);
  const fastMctpProgram = new import_web39.PublicKey(addresses_default.FAST_MCTP_PROGRAM_ID);
  let ledger = void 0;
  if (quote.type === "MCTP") {
    const [_ledger] = import_web39.PublicKey.findProgramAddressSync(
      [
        import_buffer10.Buffer.from("LEDGER_BRIDGE"),
        trader.toBytes(),
        mctpRandomKey.publicKey.toBytes()
      ],
      mctpProgram
    );
    ledger = _ledger;
  } else if (quote.type === "FAST_MCTP") {
    const [_ledger] = import_web39.PublicKey.findProgramAddressSync(
      [
        import_buffer10.Buffer.from("LEDGER_BRIDGE"),
        trader.toBytes(),
        (() => {
          const buf = import_buffer10.Buffer.alloc(2);
          buf.writeUInt16LE(fastMctpRandomKey, 0);
          return buf;
        })()
      ],
      fastMctpProgram
    );
    ledger = _ledger;
  }
  if (!ledger) {
    throw new Error("Unsupported quote type for USDC deposit: " + quote.type);
  }
  const ledgerAccount = getAssociatedTokenAddress(
    inputMint,
    ledger,
    true
  );
  if (quote.fromToken.contract === quote.hyperCoreParams.initiateTokenContract) {
    if (quote.suggestedPriorityFee > 0) {
      instructions.push(
        import_web39.ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: quote.suggestedPriorityFee
        })
      );
    }
    instructions.push(
      sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(trader, ledgerAccount, ledger, inputMint))
    );
    instructions.push(
      sandwichInstructionInCpiProxy(createSplTransferInstruction(
        getAssociatedTokenAddress(
          inputMint,
          trader,
          allowSwapperOffCurve
        ),
        ledgerAccount,
        trader,
        BigInt(quote.hyperCoreParams.bridgeAmountUSDC64)
      ))
    );
    instructions.push(
      sandwichInstructionInCpiProxy(createPayloadWriterCreateInstruction(
        trader,
        payloadAccount,
        payload,
        payloadNonce
      ))
    );
    if (quote.type === "MCTP") {
      instructions.push(
        sandwichInstructionInCpiProxy(
          createMctpBridgeLedgerInstruction({
            ledger,
            randomKey: mctpRandomKey.publicKey,
            swapperAddress: trader.toString(),
            mintAddress: inputMint.toString(),
            mode: "WITH_FEE",
            feeSolana: BigInt(0),
            amountInMin64: BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
            customPayload: payloadAccount,
            destinationAddress: addresses_default.HC_ARBITRUM_DEPOSIT_PROCESSOR,
            referrerAddress,
            feeRedeem: 0,
            gasDrop: quote.hyperCoreParams.failureGasDrop,
            toChain: "arbitrum",
            relayerAddress
          }),
          options.skipProxyMayanInstructions
        )
      );
      const { instruction: _instruction, signers: _signers } = createMctpBridgeWithFeeInstruction(
        ledger,
        "arbitrum",
        quote.hyperCoreParams.initiateTokenContract,
        relayerAddress,
        BigInt(0),
        quote.fromChain
      );
      instructions.push(
        sandwichInstructionInCpiProxy(
          _instruction,
          options.skipProxyMayanInstructions
        )
      );
      signers.push(..._signers);
    } else if (quote.type === "FAST_MCTP") {
      instructions.push(
        sandwichInstructionInCpiProxy(
          createFastMctpBridgeLedgerInstruction({
            ledger,
            randomKey: fastMctpRandomKey,
            swapperAddress: trader.toString(),
            mintAddress: inputMint.toString(),
            feeSolana: BigInt(0),
            amountInMin64: BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
            customPayload: payloadAccount,
            destinationAddress: addresses_default.HC_ARBITRUM_DEPOSIT_PROCESSOR,
            referrerAddress,
            feeRedeem: BigInt(0),
            gasDrop: quote.hyperCoreParams.failureGasDrop,
            toChain: "arbitrum",
            relayerAddress,
            feeRateRef: quote.referrerBps || 0,
            maxCircleFee: BigInt(quote.circleMaxFee64),
            minFinalityThreshold: quote.fastMctpMinFinality
          }),
          options.skipProxyMayanInstructions
        )
      );
      const { instruction: _instruction, signers: _signers } = createFastMctpBridgeInstruction(
        ledger,
        trader,
        "arbitrum",
        quote.hyperCoreParams.initiateTokenContract,
        relayerAddress,
        BigInt(0)
      );
      instructions.push(
        sandwichInstructionInCpiProxy(
          _instruction,
          options.skipProxyMayanInstructions
        )
      );
      signers.push(..._signers);
    } else {
      throw new Error("Unsupported quote type for USDC deposit: " + quote.type);
    }
    instructions.push(sandwichInstructionInCpiProxy(createPayloadWriterCloseInstruction(
      trader,
      payloadAccount,
      payloadNonce
    )));
  } else {
    if (!quote.minMiddleAmount) {
      throw new Error("minMiddleAmount is required for swap");
    }
    const clientSwapRaw = await getSwapSolana({
      minMiddleAmount: quote.minMiddleAmount,
      middleToken: quote.hyperCoreParams.initiateTokenContract,
      userWallet: trader.toString(),
      slippageBps: quote.slippageBps,
      fromToken: quote.fromToken.contract,
      amountIn64: quote.effectiveAmountIn64,
      depositMode: "HC_USDC",
      fillMaxAccounts: options?.separateSwapTx || false,
      tpmTokenAccount: tmpSwapTokenAccount.publicKey.toString(),
      referrerAddress: referrerAddress || void 0,
      chainName: quote.fromChain,
      userLedger: ledger.toString(),
      quoteType: quote.type
    });
    const clientSwap = decentralizeClientSwapInstructions(clientSwapRaw, connection);
    if (options?.separateSwapTx && clientSwapRaw.maxAccountsFilled) {
      validateJupSwap(clientSwap, tmpSwapTokenAccount.publicKey, trader);
      createSwapTpmTokenAccountInstructions = await createInitializeRandomTokenAccountInstructions(
        connection,
        trader,
        inputMint,
        trader,
        tmpSwapTokenAccount
      );
      swapInstructions.push(...clientSwap.computeBudgetInstructions);
      if (clientSwap.setupInstructions) {
        swapInstructions.push(...clientSwap.setupInstructions);
      }
      swapInstructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        swapInstructions.push(clientSwap.cleanupInstruction);
      }
      _swapAddressLookupTables.push(...clientSwap.addressLookupTableAddresses);
    } else {
      validateJupSwap(clientSwap, tmpSwapTokenAccount.publicKey, trader);
      instructions.push(...clientSwap.computeBudgetInstructions);
      const _createSwapTpmTokenAccountInstructions = await createInitializeRandomTokenAccountInstructions(
        connection,
        trader,
        inputMint,
        trader,
        tmpSwapTokenAccount
      );
      instructions.push(..._createSwapTpmTokenAccountInstructions.map((ins) => sandwichInstructionInCpiProxy(ins)));
      signers.push(tmpSwapTokenAccount);
      if (clientSwap.setupInstructions) {
        instructions.push(...clientSwap.setupInstructions.map((ins) => sandwichInstructionInCpiProxy(ins)));
      }
      instructions.push(clientSwap.swapInstruction);
      if (clientSwap.cleanupInstruction) {
        instructions.push(sandwichInstructionInCpiProxy(clientSwap.cleanupInstruction));
      }
      _lookupTablesAddress.push(...clientSwap.addressLookupTableAddresses);
    }
    const feeSolana = swapInstructions.length > 0 ? BigInt(0) : BigInt(quote.solanaRelayerFee64);
    let initiateAmountUSDC64 = BigInt(quote.hyperCoreParams.bridgeAmountUSDC64);
    if (swapInstructions.length > 0) {
      initiateAmountUSDC64 = initiateAmountUSDC64 - BigInt(quote.solanaRelayerFee64);
    }
    instructions.push(sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(
      trader,
      ledgerAccount,
      ledger,
      inputMint
    )));
    instructions.push(
      sandwichInstructionInCpiProxy(createSplTransferInstruction(
        tmpSwapTokenAccount.publicKey,
        ledgerAccount,
        trader,
        initiateAmountUSDC64
      ))
    );
    const traderInputMintAccount = getAssociatedTokenAddress(
      inputMint,
      trader,
      allowSwapperOffCurve
    );
    const traderInputMintAccountInfo = await connection.getAccountInfo(traderInputMintAccount);
    if (!traderInputMintAccountInfo || !traderInputMintAccountInfo.data) {
      instructions.push(sandwichInstructionInCpiProxy(createAssociatedTokenAccountInstruction(
        trader,
        traderInputMintAccount,
        trader,
        inputMint
      )));
    }
    instructions.push(sandwichInstructionInCpiProxy(createTransferAllAndCloseInstruction(
      trader,
      inputMint,
      tmpSwapTokenAccount.publicKey,
      traderInputMintAccount,
      trader
    )));
    instructions.push(
      sandwichInstructionInCpiProxy(createPayloadWriterCreateInstruction(
        trader,
        payloadAccount,
        payload,
        payloadNonce
      ))
    );
    if (quote.type === "MCTP") {
      instructions.push(
        sandwichInstructionInCpiProxy(
          createMctpBridgeLedgerInstruction({
            ledger,
            swapperAddress: trader.toString(),
            mintAddress: inputMint.toString(),
            randomKey: mctpRandomKey.publicKey,
            mode: "WITH_FEE",
            feeSolana,
            amountInMin64: initiateAmountUSDC64,
            customPayload: payloadAccount,
            destinationAddress: addresses_default.HC_ARBITRUM_DEPOSIT_PROCESSOR,
            referrerAddress,
            feeRedeem: 0,
            gasDrop: quote.hyperCoreParams.failureGasDrop,
            toChain: "arbitrum",
            relayerAddress
          }),
          options.skipProxyMayanInstructions
        )
      );
    } else if (quote.type === "FAST_MCTP") {
      instructions.push(
        sandwichInstructionInCpiProxy(
          createFastMctpBridgeLedgerInstruction({
            ledger,
            randomKey: fastMctpRandomKey,
            swapperAddress: trader.toString(),
            mintAddress: inputMint.toString(),
            feeSolana,
            amountInMin64: initiateAmountUSDC64,
            customPayload: payloadAccount,
            destinationAddress: addresses_default.HC_ARBITRUM_DEPOSIT_PROCESSOR,
            referrerAddress,
            feeRedeem: BigInt(0),
            gasDrop: quote.hyperCoreParams.failureGasDrop,
            toChain: "arbitrum",
            relayerAddress,
            feeRateRef: quote.referrerBps || 0,
            maxCircleFee: BigInt(quote.circleMaxFee64),
            minFinalityThreshold: quote.fastMctpMinFinality
          }),
          options.skipProxyMayanInstructions
        )
      );
    } else {
      throw new Error("Unsupported quote type");
    }
    instructions.push(sandwichInstructionInCpiProxy(createPayloadWriterCloseInstruction(
      trader,
      payloadAccount,
      payloadNonce
    )));
    if (swapInstructions.length > 0) {
      if (quote.type === "MCTP") {
        const { instruction: _instruction, signers: _signers } = createMctpBridgeWithFeeInstruction(
          ledger,
          "arbitrum",
          quote.hyperCoreParams.initiateTokenContract,
          relayerAddress,
          BigInt(0),
          quote.fromChain
        );
        instructions.push(
          sandwichInstructionInCpiProxy(
            _instruction,
            options.skipProxyMayanInstructions
          )
        );
        signers.push(..._signers);
      } else if (quote.type === "FAST_MCTP") {
        const { instruction: _instruction, signers: _signers } = createFastMctpBridgeInstruction(
          ledger,
          trader,
          "arbitrum",
          quote.hyperCoreParams.initiateTokenContract,
          relayerAddress,
          BigInt(0)
        );
        instructions.push(
          sandwichInstructionInCpiProxy(
            _instruction,
            options.skipProxyMayanInstructions
          )
        );
        signers.push(..._signers);
      } else {
        throw new Error("Unsupported quote type");
      }
    }
  }
  const totalLookupTables = await getAddressLookupTableAccounts(
    _lookupTablesAddress.concat(_swapAddressLookupTables),
    connection
  );
  lookupTables = totalLookupTables.slice(0, _lookupTablesAddress.length);
  if (swapInstructions.length > 0) {
    const swapLookupTables = totalLookupTables.slice(_lookupTablesAddress.length);
    swapMessageV0Params = {
      messageV0: {
        payerKey: trader,
        instructions: swapInstructions,
        addressLookupTableAccounts: swapLookupTables
      },
      createTmpTokenAccountIxs: createSwapTpmTokenAccountInstructions,
      tmpTokenAccount: tmpSwapTokenAccount
    };
  }
  return { instructions, signers, lookupTables, swapMessageV0Params };
}

// src/solana/solanaMonoChain.ts
var import_web310 = require("@solana/web3.js");
var import_ethers4 = require("ethers");
async function createMonoChainFromSolanaInstructions(quote, swapperAddress, destinationAddress, referrerAddress, connection, options = {}) {
  if (quote.type !== "MONO_CHAIN") {
    throw new Error("Unsupported quote type for mono chain: " + quote.type);
  }
  if (quote.fromChain !== "solana") {
    throw new Error(
      "Unsupported destination chain for mono chain: " + quote.fromChain
    );
  }
  if (quote.toChain !== "solana") {
    throw new Error(
      "Unsupported destination chain for mono chain: " + quote.toChain
    );
  }
  if (quote.fromToken.contract === quote.toToken.contract) {
    throw new Error(
      "From token and to token are the same: " + quote.fromToken.contract
    );
  }
  if (destinationAddress.startsWith("0x")) {
    throw new Error("Destination address should not be EVM address");
  }
  try {
    new import_web310.PublicKey(destinationAddress);
  } catch (e) {
    throw new Error("Invalid destination address: " + destinationAddress);
  }
  let instructions = [];
  let lookupTables = [];
  let _lookupTablesAddress = [];
  const swapper = new import_web310.PublicKey(swapperAddress);
  const destination = new import_web310.PublicKey(destinationAddress);
  const toMint = quote.toToken.contract === import_ethers4.ZeroAddress ? solMint : new import_web310.PublicKey(quote.toToken.contract);
  const destAcc = getAssociatedTokenAddress(
    toMint,
    destination,
    true,
    quote.toToken.standard === "spl2022" ? new import_web310.PublicKey(addresses_default.TOKEN_2022_PROGRAM_ID) : new import_web310.PublicKey(addresses_default.TOKEN_PROGRAM_ID)
  );
  const expectedAmountOut64 = getAmountOfFractionalAmount(
    quote.expectedAmountOut,
    quote.toToken.decimals
  );
  const clientSwapRaw = await getSwapSolana({
    userWallet: swapperAddress,
    destinationWallet: destinationAddress,
    slippageBps: quote.slippageBps,
    fromToken: quote.fromToken.contract,
    middleToken: quote.toToken.contract,
    amountIn64: quote.effectiveAmountIn64,
    expectedAmountOut64: String(expectedAmountOut64),
    depositMode: "MONO_CHAIN",
    referrerAddress,
    referrerBps: quote.referrerBps || 0,
    chainName: quote.fromChain
  });
  const clientSwap = decentralizeClientSwapInstructions(
    clientSwapRaw,
    connection
  );
  validateJupSwap(clientSwap, destAcc, swapper, destination, swapper.equals(destination));
  validateJupSwapInstructionData(clientSwap.swapInstruction, quote);
  instructions.push(...clientSwap.computeBudgetInstructions);
  if (clientSwap.setupInstructions) {
    instructions.push(...clientSwap.setupInstructions.map((ins) => sandwichInstructionInCpiProxy(ins)));
  }
  instructions.push(clientSwap.swapInstruction);
  if (clientSwap.cleanupInstruction) {
    instructions.push(sandwichInstructionInCpiProxy(clientSwap.cleanupInstruction));
  }
  _lookupTablesAddress.push(...clientSwap.addressLookupTableAddresses);
  _lookupTablesAddress.push(getLookupTableAddress(quote.fromChain));
  lookupTables = await getAddressLookupTableAccounts(_lookupTablesAddress, connection);
  return { instructions, signers: [], lookupTables, swapMessageV0Params: null };
}

// src/solana/solanaSwap.ts
var STATE_SIZE = 420;
var SwapLayout = (0, import_buffer_layout5.struct)([
  (0, import_buffer_layout5.u8)("instruction"),
  (0, import_buffer_layout5.u8)("stateNonce"),
  (0, import_buffer_layout5.blob)(8, "amount"),
  (0, import_buffer_layout5.blob)(8, "minAmountOut"),
  (0, import_buffer_layout5.blob)(8, "deadline"),
  (0, import_buffer_layout5.blob)(8, "feeSwap"),
  (0, import_buffer_layout5.blob)(8, "feeReturn"),
  (0, import_buffer_layout5.blob)(8, "feeCancel"),
  (0, import_buffer_layout5.blob)(8, "gasDrop"),
  (0, import_buffer_layout5.u16)("destinationChain"),
  (0, import_buffer_layout5.blob)(32, "destinationAddress"),
  (0, import_buffer_layout5.u8)("unwrapRedeem"),
  (0, import_buffer_layout5.u8)("unwrapRefund"),
  (0, import_buffer_layout5.u8)("mayanFeeNonce"),
  (0, import_buffer_layout5.u8)("referrerFeeNonce")
]);
async function createSwapFromSolanaInstructions(quote, swapperWalletAddress, destinationAddress, referrerAddresses, connection, options = {}) {
  const referrerAddress = getQuoteSuitableReferrerAddress(quote, referrerAddresses);
  if (quote.fromChain === "hypercore") {
    throw new Error("HyperCore as source chain is not supported in Solana");
  }
  if (quote.toChain === "hypercore") {
    if (options.customPayload) {
      throw new Error("Custom payload is not supported for HyperCore");
    }
    return createHyperCoreDepositFromSolanaInstructions(quote, swapperWalletAddress, destinationAddress, referrerAddress, connection, options);
  }
  if (quote.type === "MCTP") {
    return createMctpFromSolanaInstructions(quote, swapperWalletAddress, destinationAddress, referrerAddress, connection, options);
  }
  if (quote.type === "SWIFT") {
    return createSwiftFromSolanaInstructions(quote, swapperWalletAddress, destinationAddress, referrerAddress, connection, options);
  }
  if (quote.type === "MONO_CHAIN") {
    if (options.customPayload) {
      throw new Error("Custom payload is not supported for MONO_CHAIN yet");
    }
    return createMonoChainFromSolanaInstructions(quote, swapperWalletAddress, destinationAddress, referrerAddress, connection, options);
  }
  if (quote.type === "FAST_MCTP") {
    return createFastMctpFromSolanaInstructions(quote, swapperWalletAddress, destinationAddress, referrerAddress, connection, options);
  }
  if (options.customPayload) {
    throw new Error("Custom payload is not supported for WH from Solana");
  }
  let instructions = [];
  const solanaConnection = connection ?? new import_web311.Connection("https://rpc.ankr.com/solana");
  const mayanProgram = new import_web311.PublicKey(addresses_default.MAYAN_PROGRAM_ID);
  const tokenProgram = new import_web311.PublicKey(addresses_default.TOKEN_PROGRAM_ID);
  const swapper = new import_web311.PublicKey(swapperWalletAddress);
  const auctionAddr = new import_web311.PublicKey(addresses_default.AUCTION_PROGRAM_ID);
  if (quote.suggestedPriorityFee > 0) {
    instructions.push(import_web311.ComputeBudgetProgram.setComputeUnitPrice({
      microLamports: quote.suggestedPriorityFee
    }));
  }
  let referrerAddr;
  if (referrerAddress) {
    referrerAddr = new import_web311.PublicKey(referrerAddress);
  } else {
    referrerAddr = import_web311.SystemProgram.programId;
  }
  const [mayanFee, mayanFeeNonce] = import_web311.PublicKey.findProgramAddressSync(
    [import_buffer11.Buffer.from("MAYANFEE")],
    mayanProgram
  );
  const [referrerFee, referrerFeeNonce] = import_web311.PublicKey.findProgramAddressSync(
    [
      import_buffer11.Buffer.from("REFERRERFEE"),
      referrerAddr.toBuffer()
    ],
    mayanProgram
  );
  const msg1 = import_web311.Keypair.generate();
  const msg2 = import_web311.Keypair.generate();
  const [state, stateNonce] = import_web311.PublicKey.findProgramAddressSync(
    [
      import_buffer11.Buffer.from("V2STATE"),
      import_buffer11.Buffer.from(msg1.publicKey.toBytes()),
      import_buffer11.Buffer.from(msg2.publicKey.toBytes())
    ],
    mayanProgram
  );
  const fromMint = new import_web311.PublicKey(quote.fromToken.mint);
  const toMint = new import_web311.PublicKey(quote.toToken.mint);
  const fromAccount = getAssociatedTokenAddress(fromMint, swapper);
  const toAccount = getAssociatedTokenAddress(fromMint, state, true);
  const [
    [fromAccountData, toAccountData],
    stateRent,
    relayer
  ] = await Promise.all([
    solanaConnection.getMultipleAccountsInfo([fromAccount, toAccount], "finalized"),
    solanaConnection.getMinimumBalanceForRentExemption(STATE_SIZE),
    decideRelayer()
  ]);
  if (!fromAccountData || fromAccountData.data.length === 0) {
    instructions.push(createAssociatedTokenAccountInstruction(
      swapper,
      fromAccount,
      swapper,
      fromMint
    ));
  }
  if (!toAccountData || toAccountData.data.length === 0) {
    instructions.push(createAssociatedTokenAccountInstruction(
      swapper,
      toAccount,
      state,
      fromMint
    ));
  }
  if (quote.fromToken.contract === import_ethers5.ZeroAddress) {
    instructions.push(import_web311.SystemProgram.transfer({
      fromPubkey: swapper,
      toPubkey: fromAccount,
      lamports: BigInt(quote.effectiveAmountIn64)
    }));
    instructions.push(createSyncNativeInstruction(fromAccount));
  }
  const amount = BigInt(quote.effectiveAmountIn64);
  const delegate = import_web311.Keypair.generate();
  instructions.push(createApproveInstruction(
    fromAccount,
    delegate.publicKey,
    swapper,
    amount
  ));
  instructions.push(import_web311.SystemProgram.transfer({
    fromPubkey: swapper,
    toPubkey: delegate.publicKey,
    lamports: stateRent
  }));
  const swapKeys = [
    { pubkey: delegate.publicKey, isWritable: false, isSigner: true },
    { pubkey: msg1.publicKey, isWritable: false, isSigner: true },
    { pubkey: msg2.publicKey, isWritable: false, isSigner: true },
    { pubkey: state, isWritable: true, isSigner: false },
    { pubkey: fromAccount, isWritable: true, isSigner: false },
    { pubkey: swapper, isWritable: false, isSigner: false },
    { pubkey: toAccount, isWritable: true, isSigner: false },
    { pubkey: fromMint, isWritable: false, isSigner: false },
    { pubkey: toMint, isWritable: false, isSigner: false },
    { pubkey: auctionAddr, isWritable: false, isSigner: false },
    { pubkey: referrerAddr, isWritable: false, isSigner: false },
    { pubkey: mayanFee, isWritable: false, isSigner: false },
    { pubkey: referrerFee, isWritable: false, isSigner: false },
    { pubkey: delegate.publicKey, isWritable: true, isSigner: true },
    { pubkey: relayer, isWritable: false, isSigner: false },
    { pubkey: import_web311.SYSVAR_CLOCK_PUBKEY, isWritable: false, isSigner: false },
    { pubkey: import_web311.SYSVAR_RENT_PUBKEY, isWritable: false, isSigner: false },
    { pubkey: tokenProgram, isWritable: false, isSigner: false },
    { pubkey: import_web311.SystemProgram.programId, isWritable: false, isSigner: false }
  ];
  const destinationChainId = getWormholeChainIdByName(quote.toChain);
  if (destinationChainId === 1) {
    const destinationAccount = await solanaConnection.getAccountInfo(new import_web311.PublicKey(destinationAddress));
    if (destinationAccount && destinationAccount.owner && destinationAccount.owner.equals(tokenProgram)) {
      throw new Error(
        "Destination address is not about token account. It should be a owner address"
      );
    }
  }
  const destAddress = import_buffer11.Buffer.from(
    hexToUint8Array(
      nativeAddressToHexString(destinationAddress, destinationChainId)
    )
  );
  if (!quote.mintDecimals) {
    throw new Error("Mint decimals not provided");
  }
  const minAmountOut = getAmountOfFractionalAmount(
    quote.minAmountOut,
    quote.mintDecimals.to
  );
  const feeSwap = getAmountOfFractionalAmount(
    quote.swapRelayerFee,
    quote.mintDecimals.from
  );
  const feeReturn = getAmountOfFractionalAmount(
    quote.redeemRelayerFee,
    quote.mintDecimals.to
  );
  const feeCancel = getAmountOfFractionalAmount(
    quote.refundRelayerFee,
    quote.mintDecimals.from
  );
  const gasDrop = getAmountOfFractionalAmount(
    quote.gasDrop,
    getGasDecimalsInSolana(quote.toChain)
  );
  const unwrapRedeem = quote.toToken.contract === import_ethers5.ZeroAddress;
  const unwrapRefund = quote.fromToken.contract === import_ethers5.ZeroAddress;
  if (!Number(quote.deadline64)) {
    throw new Error("Deadline is not valid");
  }
  const deadline = BigInt(quote.deadline64);
  const swapData = import_buffer11.Buffer.alloc(SwapLayout.span);
  const swapFields = {
    instruction: 101,
    stateNonce,
    amount: getSafeU64Blob(amount),
    minAmountOut: getSafeU64Blob(minAmountOut),
    deadline: getSafeU64Blob(deadline),
    feeSwap: getSafeU64Blob(feeSwap),
    feeReturn: getSafeU64Blob(feeReturn),
    feeCancel: getSafeU64Blob(feeCancel),
    gasDrop: getSafeU64Blob(gasDrop),
    destinationChain: destinationChainId,
    destinationAddress: destAddress,
    unwrapRedeem: unwrapRedeem ? 1 : 0,
    unwrapRefund: unwrapRefund ? 1 : 0,
    mayanFeeNonce,
    referrerFeeNonce
  };
  SwapLayout.encode(swapFields, swapData);
  const swapInstruction = new import_web311.TransactionInstruction({
    keys: swapKeys,
    data: swapData,
    programId: mayanProgram
  });
  instructions.push(swapInstruction);
  return {
    instructions,
    signers: [delegate, msg1, msg2],
    lookupTables: [],
    swapMessageV0Params: null
  };
}
async function swapFromSolana(quote, swapperWalletAddress, destinationAddress, referrerAddresses, signTransaction, connection, extraRpcs, sendOptions, jitoOptions, instructionOptions) {
  const jitoEnabled = !!(!quote.gasless && jitoOptions && jitoOptions.tipLamports > 0 && jitoOptions.signAllTransactions);
  let instructions = [];
  let feePayer;
  let recentBlockhash;
  let lastValidBlockHeight;
  const {
    instructions: _instructions,
    signers,
    lookupTables,
    swapMessageV0Params
  } = await createSwapFromSolanaInstructions(
    quote,
    swapperWalletAddress,
    destinationAddress,
    referrerAddresses,
    connection,
    {
      allowSwapperOffCurve: instructionOptions?.allowSwapperOffCurve,
      forceSkipCctpInstructions: instructionOptions?.forceSkipCctpInstructions,
      separateSwapTx: jitoEnabled && jitoOptions?.separateSwapTx,
      usdcPermitSignature: instructionOptions?.usdcPermitSignature,
      skipProxyMayanInstructions: instructionOptions?.skipProxyMayanInstructions === true,
      // default is false
      customPayload: instructionOptions?.customPayload
    }
  );
  if (quote.gasless) {
    feePayer = new import_web311.PublicKey(quote.relayer);
    const {
      publicKey: noncePubkey,
      nonce
    } = await getSvmDurableNonce(quote.fromChain, swapperWalletAddress);
    instructions = [import_web311.SystemProgram.nonceAdvance({
      noncePubkey: new import_web311.PublicKey(noncePubkey),
      authorizedPubkey: feePayer
    }), ..._instructions];
    recentBlockhash = nonce;
    lastValidBlockHeight = 0;
  } else {
    feePayer = new import_web311.PublicKey(swapperWalletAddress);
    instructions = _instructions;
    const latestBlockHash = await connection.getLatestBlockhash();
    recentBlockhash = latestBlockHash.blockhash;
    lastValidBlockHeight = latestBlockHash.lastValidBlockHeight;
  }
  const swapper = new import_web311.PublicKey(swapperWalletAddress);
  const message = import_web311.MessageV0.compile({
    instructions,
    payerKey: feePayer,
    recentBlockhash,
    addressLookupTableAccounts: lookupTables
  });
  const transaction = new import_web311.VersionedTransaction(message);
  transaction.sign(signers);
  let signedTrx;
  if (jitoEnabled && !quote.gasless) {
    const allTransactions = [];
    if (swapMessageV0Params) {
      if (!lastValidBlockHeight) {
        throw new Error("lastValidBlockHeight is missing");
      }
      const createTmpTokenAccount = new import_web311.Transaction({
        feePayer: swapper,
        blockhash: recentBlockhash,
        lastValidBlockHeight
      }).add(...swapMessageV0Params.createTmpTokenAccountIxs);
      createTmpTokenAccount.partialSign(swapMessageV0Params.tmpTokenAccount);
      allTransactions.push(createTmpTokenAccount);
      const swapMessage = import_web311.MessageV0.compile({
        ...swapMessageV0Params.messageV0,
        recentBlockhash
      });
      allTransactions.push(new import_web311.VersionedTransaction(swapMessage));
    }
    const jitoTipTransfer = getJitoTipTransfer(swapperWalletAddress, recentBlockhash, lastValidBlockHeight, jitoOptions);
    allTransactions.push(transaction);
    allTransactions.push(jitoTipTransfer);
    const signedTrxs = await jitoOptions.signAllTransactions(allTransactions);
    signedTrx = signedTrxs[signedTrxs.length - 2];
    let mayanTxHash = null;
    const isVersionedTx = "version" in signedTrx;
    if (isVersionedTx && signedTrx.signatures[0]) {
      mayanTxHash = import_bs582.default.encode(Uint8Array.from(signedTrx.signatures[0]));
    } else if (!isVersionedTx && signedTrx.signatures[0]?.publicKey) {
      mayanTxHash = import_bs582.default.encode(Uint8Array.from(signedTrx.signatures[0].signature));
    }
    if (mayanTxHash === null) {
      throw new Error("Failed to get mayan tx hash");
    }
    if (swapMessageV0Params) {
      const jitoBundleId = await sendJitoBundle(signedTrxs, jitoOptions, true);
      await confirmJitoBundleId(jitoBundleId, jitoOptions, lastValidBlockHeight, mayanTxHash, connection);
      broadcastJitoBundleId(jitoBundleId);
      return {
        signature: mayanTxHash,
        serializedTrx: null
      };
    } else {
      sendJitoBundle(signedTrxs, jitoOptions).then(() => {
        console.log("Jito bundle sent");
      }).catch(() => {
      });
    }
  } else {
    signedTrx = await signTransaction(transaction);
  }
  if (quote.gasless) {
    const serializedTrx = import_buffer11.Buffer.from(signedTrx.serialize()).toString("base64");
    const { orderHash } = await submitSwiftSolanaSwap(serializedTrx, quote.fromChain);
    return { signature: orderHash, serializedTrx: null };
  }
  return await submitTransactionWithRetry({
    trx: signedTrx.serialize(),
    connection,
    extraRpcs: extraRpcs ?? [],
    errorChance: 2,
    options: sendOptions
  });
}

// src/evm/evmSwift.ts
var import_buffer12 = require("buffer");
function getEvmSwiftParams(quote, swapperAddress, destinationAddress, referrerAddress, signerChainId, customPayload) {
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  const destChainId = getWormholeChainIdByName(quote.toChain);
  if (sourceChainId !== signerWormholeChainId) {
    throw new Error(`Signer chain id(${Number(signerChainId)}) and quote from chain are not same! ${sourceChainId} !== ${signerWormholeChainId}`);
  }
  if (!quote.swiftMayanContract) {
    throw new Error("SWIFT contract address is missing");
  }
  if (quote.toToken.wChainId !== destChainId) {
    throw new Error(`Destination chain ID mismatch: ${destChainId} != ${quote.toToken.wChainId}`);
  }
  if (quote.swiftVersion !== "V2" && quote.toChain === "sui") {
    throw new Error("Swift V2 is required for SUI chain");
  }
  const contractAddress = quote.swiftMayanContract;
  if (!Number(quote.deadline64)) {
    throw new Error("Swift order requires timeout");
  }
  const deadline = BigInt(quote.deadline64);
  const tokenIn = quote.swiftInputContract;
  const amountIn = BigInt(quote.effectiveAmountIn64);
  let referrerHex;
  const referrerChainId = quote.swiftVersion === "V2" ? sourceChainId : destChainId;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(
      referrerAddress,
      referrerChainId
    );
  } else {
    referrerHex = nativeAddressToHexString(
      import_web312.SystemProgram.programId.toString(),
      1
    );
  }
  const random = "0x" + createSwiftRandomKey(quote).toString("hex");
  if (quote.toChain === "sui" && !quote.toToken.verifiedAddress) {
    throw new Error("Missing verified address for SUI coin");
  }
  const tokenOut = getSwiftToTokenHexString(quote);
  const minAmountOut = getAmountOfFractionalAmount(
    quote.minAmountOut,
    Math.min(quote.toToken.decimals, getNormalizeFactor(quote.toChain, quote.type))
  );
  const gasDrop = getAmountOfFractionalAmount(
    quote.gasDrop,
    Math.min(getGasDecimal(quote.toChain), getNormalizeFactor(quote.toChain, quote.type))
  );
  if (!quote.refundRelayerFee64 || !quote.cancelRelayerFee64) {
    throw new Error("Swift order requires refund and cancel fees");
  }
  const destinationAddressHex = nativeAddressToHexString(destinationAddress, destChainId);
  if (!quote.swiftAuctionMode) {
    throw new Error("Swift order requires auction mode");
  }
  const orderParams = {
    payloadType: customPayload ? SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD : SWIFT_PAYLOAD_TYPE_DEFAULT,
    trader: nativeAddressToHexString(swapperAddress, sourceChainId),
    tokenOut,
    minAmountOut,
    gasDrop,
    cancelFee: BigInt(quote.cancelRelayerFee64),
    refundFee: BigInt(quote.refundRelayerFee64),
    deadline,
    destAddr: destinationAddressHex,
    destChainId,
    referrerAddr: referrerHex,
    referrerBps: quote.referrerBps || 0,
    auctionMode: quote.swiftAuctionMode,
    random
  };
  return {
    contractAddress,
    tokenIn,
    amountIn,
    order: orderParams,
    customPayload: customPayload ? `0x${import_buffer12.Buffer.from(customPayload).toString("hex")}` : "0x"
  };
}
async function getSwiftFromEvmTxPayload(quote, swapperAddress, destinationAddress, referrerAddress, signerChainId, permit, customPayload) {
  if (quote.type !== "SWIFT") {
    throw new Error("Quote type is not SWIFT");
  }
  if (!Number.isFinite(Number(signerChainId))) {
    throw new Error("Invalid signer chain id");
  }
  if (!Number(quote.deadline64)) {
    throw new Error("Swift order requires timeout");
  }
  signerChainId = Number(signerChainId);
  const _permit = permit || ZeroPermit;
  const forwarder = new import_ethers6.Contract(addresses_default.MAYAN_FORWARDER_CONTRACT, MayanForwarderArtifact_default.abi);
  const {
    tokenIn: swiftTokenIn,
    amountIn,
    order,
    contractAddress: swiftContractAddress,
    customPayload: swiftCustomPayload
  } = getEvmSwiftParams(
    quote,
    swapperAddress,
    destinationAddress,
    referrerAddress,
    signerChainId,
    customPayload
  );
  let swiftCallData;
  const swiftContract = new import_ethers6.Contract(
    swiftContractAddress,
    quote.swiftVersion === "V2" ? MayanSwiftV2Artifact_default.abi : MayanSwiftArtifact_default.abi
  );
  if (quote.swiftInputContract === import_ethers6.ZeroAddress) {
    swiftCallData = swiftContract.interface.encodeFunctionData(
      "createOrderWithEth",
      quote.swiftVersion === "V2" ? [order, swiftCustomPayload] : [order]
    );
  } else {
    swiftCallData = swiftContract.interface.encodeFunctionData(
      "createOrderWithToken",
      quote.swiftVersion === "V2" ? [swiftTokenIn, amountIn, order, swiftCustomPayload] : [swiftTokenIn, amountIn, order]
    );
  }
  let forwarderMethod;
  let forwarderParams;
  let value;
  if (quote.fromToken.contract === quote.swiftInputContract) {
    if (quote.fromToken.contract === import_ethers6.ZeroAddress) {
      forwarderMethod = "forwardEth";
      forwarderParams = [swiftContractAddress, swiftCallData];
      value = (0, import_ethers6.toBeHex)(amountIn);
    } else {
      forwarderMethod = "forwardERC20";
      forwarderParams = [swiftTokenIn, amountIn, _permit, swiftContractAddress, swiftCallData];
      value = (0, import_ethers6.toBeHex)(0);
    }
  } else {
    const { swapRouterCalldata, swapRouterAddress } = await getSwapEvm({
      forwarderAddress: addresses_default.MAYAN_FORWARDER_CONTRACT,
      slippageBps: quote.slippageBps,
      referrerAddress,
      fromToken: quote.fromToken.contract,
      middleToken: quote.swiftInputContract,
      chainName: quote.fromChain,
      amountIn64: quote.effectiveAmountIn64
    });
    if (!quote.minMiddleAmount) {
      throw new Error("Swift swap requires middle amount, router address and calldata");
    }
    const tokenIn = quote.fromToken.contract;
    const minMiddleAmount = getAmountOfFractionalAmount(quote.minMiddleAmount, quote.swiftInputDecimals);
    if (quote.fromToken.contract === import_ethers6.ZeroAddress) {
      forwarderMethod = "swapAndForwardEth";
      forwarderParams = [
        amountIn,
        swapRouterAddress,
        swapRouterCalldata,
        quote.swiftInputContract,
        minMiddleAmount,
        swiftContractAddress,
        swiftCallData
      ];
      value = (0, import_ethers6.toBeHex)(amountIn);
    } else {
      forwarderMethod = "swapAndForwardERC20";
      forwarderParams = [
        tokenIn,
        amountIn,
        _permit,
        swapRouterAddress,
        swapRouterCalldata,
        quote.swiftInputContract,
        minMiddleAmount,
        swiftContractAddress,
        swiftCallData
      ];
      value = (0, import_ethers6.toBeHex)(0);
    }
  }
  const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
  return {
    data,
    to: addresses_default.MAYAN_FORWARDER_CONTRACT,
    value,
    chainId: signerChainId,
    _forwarder: {
      method: forwarderMethod,
      params: forwarderParams
    }
  };
}
function getSwiftOrderTypeData(quote, orderHash, signerChainId) {
  if (!Number.isFinite(Number(signerChainId))) {
    throw new Error("Invalid signer chain id");
  }
  if (!quote.submitRelayerFee64) {
    throw new Error("Swift gasless order requires submit relayer fee");
  }
  if (!quote.swiftMayanContract) {
    throw new Error("Swift contract address is missing in quote");
  }
  const totalAmountIn = BigInt(quote.effectiveAmountIn64);
  const submitFee = BigInt(quote.submitRelayerFee64);
  return {
    domain: {
      name: "Mayan Swift",
      chainId: Number(signerChainId),
      verifyingContract: quote.swiftMayanContract
    },
    types: {
      CreateOrder: [
        { name: "OrderId", type: "bytes32" },
        { name: "InputAmount", type: "uint256" },
        { name: "SubmissionFee", type: "uint256" }
      ]
    },
    value: {
      OrderId: orderHash,
      InputAmount: totalAmountIn - submitFee,
      SubmissionFee: submitFee
    }
  };
}
function getSwiftFromEvmGasLessParams(quote, swapperAddress, destinationAddress, referrerAddress, signerChainId, permit, customPayload) {
  if (quote.type !== "SWIFT") {
    throw new Error("Quote type is not SWIFT");
  }
  if (!quote.gasless) {
    throw new Error("Quote does not support gasless");
  }
  if (!Number.isFinite(Number(signerChainId))) {
    throw new Error("Invalid signer chain id");
  }
  if (!Number(quote.deadline64)) {
    throw new Error("Swift order requires timeout");
  }
  if (quote.fromToken.contract !== quote.swiftInputContract) {
    throw new Error("Swift gasless order creation does not support source swap");
  }
  if (!quote.submitRelayerFee64) {
    throw new Error("Swift gasless order requires submit relayer fee");
  }
  const {
    tokenIn,
    amountIn,
    order,
    customPayload: swiftCustomPayload
  } = getEvmSwiftParams(
    quote,
    swapperAddress,
    destinationAddress,
    referrerAddress,
    Number(signerChainId),
    customPayload
  );
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  const orderHashBuf = createSwiftOrderHash(
    quote,
    swapperAddress,
    destinationAddress,
    referrerAddress,
    order.random,
    customPayload
  );
  const orderHash = `0x${orderHashBuf.toString("hex")}`;
  const orderTypedData = getSwiftOrderTypeData(quote, orderHash, signerChainId);
  return {
    swiftVersion: quote.swiftVersion,
    permitParams: permit,
    orderParams: {
      ...order,
      sourceChainId,
      amountIn,
      tokenIn,
      submissionFee: BigInt(quote.submitRelayerFee64)
    },
    orderHash,
    customPayload: swiftCustomPayload,
    orderTypedData
  };
}

// src/evm/evmFastMctp.ts
var import_ethers7 = require("ethers");
var import_web313 = require("@solana/web3.js");

// src/evm/MayanFastMctpArtifact.ts
var MayanFastMctpArtifact_default = {
  "abi": [
    {
      "type": "constructor",
      "inputs": [
        {
          "name": "_cctpTokenMessengerV2",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "_feeManager",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "receive",
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "bridge",
      "inputs": [
        {
          "name": "tokenIn",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amountIn",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "redeemFee",
          "type": "uint64",
          "internalType": "uint64"
        },
        {
          "name": "circleMaxFee",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "gasDrop",
          "type": "uint64",
          "internalType": "uint64"
        },
        {
          "name": "destAddr",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "destDomain",
          "type": "uint32",
          "internalType": "uint32"
        },
        {
          "name": "referrerAddress",
          "type": "bytes32",
          "internalType": "bytes32"
        },
        {
          "name": "referrerBps",
          "type": "uint8",
          "internalType": "uint8"
        },
        {
          "name": "payloadType",
          "type": "uint8",
          "internalType": "uint8"
        },
        {
          "name": "minFinalityThreshold",
          "type": "uint32",
          "internalType": "uint32"
        },
        {
          "name": "customPayload",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "cctpTokenMessengerV2",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "contract ITokenMessengerV2"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "changeGuardian",
      "inputs": [
        {
          "name": "newGuardian",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "claimGuardian",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "createOrder",
      "inputs": [
        {
          "name": "tokenIn",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amountIn",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "circleMaxFee",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "destDomain",
          "type": "uint32",
          "internalType": "uint32"
        },
        {
          "name": "minFinalityThreshold",
          "type": "uint32",
          "internalType": "uint32"
        },
        {
          "name": "orderPayload",
          "type": "tuple",
          "internalType": "struct FastMCTP.OrderPayload",
          "components": [
            {
              "name": "payloadType",
              "type": "uint8",
              "internalType": "uint8"
            },
            {
              "name": "destAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "tokenOut",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "amountOutMin",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "gasDrop",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "redeemFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "refundFee",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "deadline",
              "type": "uint64",
              "internalType": "uint64"
            },
            {
              "name": "referrerAddr",
              "type": "bytes32",
              "internalType": "bytes32"
            },
            {
              "name": "referrerBps",
              "type": "uint8",
              "internalType": "uint8"
            }
          ]
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "domainToCaller",
      "inputs": [
        {
          "name": "",
          "type": "uint32",
          "internalType": "uint32"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "feeManager",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "fulfillOrder",
      "inputs": [
        {
          "name": "cctpMsg",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "cctpSigs",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "swapProtocol",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "swapData",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "guardian",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "keyToMintRecipient",
      "inputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "nextGuardian",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "paused",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "redeem",
      "inputs": [
        {
          "name": "cctpMsg",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "cctpSigs",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "refund",
      "inputs": [
        {
          "name": "cctpMsg",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "cctpSigs",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "rescueEth",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address payable"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "rescueRedeem",
      "inputs": [
        {
          "name": "cctpMsg",
          "type": "bytes",
          "internalType": "bytes"
        },
        {
          "name": "cctpSigs",
          "type": "bytes",
          "internalType": "bytes"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "rescueToken",
      "inputs": [
        {
          "name": "token",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "to",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setDomainCallers",
      "inputs": [
        {
          "name": "domain",
          "type": "uint32",
          "internalType": "uint32"
        },
        {
          "name": "caller",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setFeeManager",
      "inputs": [
        {
          "name": "_feeManager",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setMintRecipient",
      "inputs": [
        {
          "name": "destDomain",
          "type": "uint32",
          "internalType": "uint32"
        },
        {
          "name": "tokenIn",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "mintRecipient",
          "type": "bytes32",
          "internalType": "bytes32"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setPause",
      "inputs": [
        {
          "name": "_pause",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setWhitelistedMsgSenders",
      "inputs": [
        {
          "name": "sender",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "isWhitelisted",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setWhitelistedSwapProtocols",
      "inputs": [
        {
          "name": "protocol",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "isWhitelisted",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "whitelistedMsgSenders",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "whitelistedSwapProtocols",
      "inputs": [
        {
          "name": "",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "event",
      "name": "OrderFulfilled",
      "inputs": [
        {
          "name": "sourceDomain",
          "type": "uint32",
          "indexed": false,
          "internalType": "uint32"
        },
        {
          "name": "sourceNonce",
          "type": "bytes32",
          "indexed": false,
          "internalType": "bytes32"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "OrderRefunded",
      "inputs": [
        {
          "name": "sourceDomain",
          "type": "uint32",
          "indexed": false,
          "internalType": "uint32"
        },
        {
          "name": "sourceNonce",
          "type": "bytes32",
          "indexed": false,
          "internalType": "bytes32"
        },
        {
          "name": "amount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "AlreadySet",
      "inputs": []
    },
    {
      "type": "error",
      "name": "CallerNotSet",
      "inputs": []
    },
    {
      "type": "error",
      "name": "CctpReceiveFailed",
      "inputs": []
    },
    {
      "type": "error",
      "name": "DeadlineViolation",
      "inputs": []
    },
    {
      "type": "error",
      "name": "EthTransferFailed",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidAddress",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidAmountOut",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidGasDrop",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidMintRecipient",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidPayload",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidPayloadType",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidRedeemFee",
      "inputs": []
    },
    {
      "type": "error",
      "name": "InvalidRefundFee",
      "inputs": []
    },
    {
      "type": "error",
      "name": "MintRecipientNotSet",
      "inputs": []
    },
    {
      "type": "error",
      "name": "Paused",
      "inputs": []
    },
    {
      "type": "error",
      "name": "Unauthorized",
      "inputs": []
    },
    {
      "type": "error",
      "name": "UnauthorizedMsgSender",
      "inputs": []
    },
    {
      "type": "error",
      "name": "UnauthorizedSwapProtocol",
      "inputs": []
    }
  ]
};

// src/evm/evmFastMctp.ts
var import_buffer13 = require("buffer");
function getEvmFastMctpBridgeParams(quote, destinationAddress, referrerAddress, signerChainId, customPayload) {
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  const destChainId = getWormholeChainIdByName(quote.toChain);
  if (sourceChainId !== signerWormholeChainId) {
    throw new Error(`Signer chain id(${Number(signerChainId)}) and quote from chain are not same! ${sourceChainId} !== ${signerWormholeChainId}`);
  }
  const destinationAddressHex = nativeAddressToHexString(destinationAddress, destChainId);
  const redeemFee = getAmountOfFractionalAmount(quote.redeemRelayerFee, CCTP_TOKEN_DECIMALS);
  const gasDrop = getAmountOfFractionalAmount(quote.gasDrop, Math.min(getGasDecimal(quote.toChain), 8));
  const circleMaxFee = BigInt(quote.circleMaxFee64);
  const amountIn = BigInt(quote.effectiveAmountIn64);
  const destDomain = getCCTPDomain(quote.toChain);
  let referrerHex;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(
      referrerAddress,
      destChainId
    );
  } else {
    referrerHex = nativeAddressToHexString(
      import_web313.SystemProgram.programId.toString(),
      getWormholeChainIdByName("solana")
    );
  }
  if (!quote.fastMctpMayanContract) {
    throw new Error("FastMctp contract address is missing");
  }
  const contractAddress = quote.fastMctpMayanContract;
  return {
    tokenIn: quote.fastMctpInputContract,
    amountIn,
    redeemFee,
    gasDrop,
    destAddr: destinationAddressHex,
    destDomain,
    referrerAddr: referrerHex,
    referrerBps: quote.referrerBps || 0,
    payloadType: customPayload ? FAST_MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD : FAST_MCTP_PAYLOAD_TYPE_DEFAULT,
    customPayload: customPayload ? `0x${import_buffer13.Buffer.from(customPayload).toString("hex")}` : "0x",
    minFinalityThreshold: Number(quote.fastMctpMinFinality),
    circleMaxFee,
    contractAddress
  };
}
function getEvmFastMctpBridgeTxPayload(quote, destinationAddress, referrerAddress, signerChainId, payload) {
  const params = getEvmFastMctpBridgeParams(
    quote,
    destinationAddress,
    referrerAddress,
    signerChainId,
    payload
  );
  const {
    contractAddress,
    tokenIn,
    amountIn,
    destAddr,
    redeemFee,
    gasDrop,
    circleMaxFee,
    referrerAddr,
    referrerBps,
    destDomain,
    customPayload,
    minFinalityThreshold,
    payloadType
  } = params;
  const fastMctpContract = new import_ethers7.Contract(contractAddress, MayanFastMctpArtifact_default.abi);
  let data;
  let value;
  data = fastMctpContract.interface.encodeFunctionData(
    "bridge",
    [
      tokenIn,
      amountIn,
      redeemFee,
      circleMaxFee,
      gasDrop,
      destAddr,
      destDomain,
      referrerAddr,
      referrerBps,
      payloadType,
      minFinalityThreshold,
      customPayload
    ]
  );
  value = (0, import_ethers7.toBeHex)(0);
  return {
    to: contractAddress,
    data,
    value,
    _params: params
  };
}
function getEvmFastMctpCreateOrderParams(quote, destinationAddress, referrerAddress, signerChainId) {
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  const destChainId = getWormholeChainIdByName(quote.toChain);
  if (sourceChainId !== signerWormholeChainId) {
    throw new Error(`Signer chain id(${Number(signerChainId)}) and quote from chain are not same! ${sourceChainId} !== ${signerWormholeChainId}`);
  }
  if (!quote.fastMctpMayanContract) {
    throw new Error("Fast MCTP contract address is missing");
  }
  const contractAddress = quote.fastMctpMayanContract;
  const destinationAddressHex = nativeAddressToHexString(destinationAddress, destChainId);
  let referrerHex;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(
      referrerAddress,
      destChainId
    );
  } else {
    referrerHex = nativeAddressToHexString(
      import_web313.SystemProgram.programId.toString(),
      getWormholeChainIdByName("solana")
    );
  }
  const redeemFee = getAmountOfFractionalAmount(quote.redeemRelayerFee, CCTP_TOKEN_DECIMALS);
  if (!quote.refundRelayerFee64) {
    throw new Error("Refund relayer fee is missing in quote");
  }
  const refundFee = BigInt(quote.refundRelayerFee64);
  const circleMaxFee = BigInt(quote.circleMaxFee64);
  const gasDrop = getAmountOfFractionalAmount(quote.gasDrop, Math.min(getGasDecimal(quote.toChain), 8));
  const destDomain = getCCTPDomain(quote.toChain);
  const amountIn = BigInt(quote.effectiveAmountIn64);
  const amountOutMin = getAmountOfFractionalAmount(
    quote.minAmountOut,
    Math.min(8, quote.toToken.decimals)
  );
  const deadline = BigInt(quote.deadline64);
  if (quote.toChain === "sui" && !quote.toToken.verifiedAddress) {
    throw new Error("To token verified address is missing for SUI");
  }
  const tokenOut = quote.toToken.contract === import_ethers7.ZeroAddress ? nativeAddressToHexString(import_web313.SystemProgram.programId.toString(), getWormholeChainIdByName("solana")) : nativeAddressToHexString(
    quote.toChain === "sui" ? quote.toToken.verifiedAddress : quote.toToken.contract,
    quote.toToken.wChainId
  );
  return {
    tokenIn: quote.fastMctpInputContract,
    amountIn,
    circleMaxFee,
    destDomain,
    minFinalityThreshold: Number(quote.fastMctpMinFinality),
    orderPayload: {
      payloadType: FAST_MCTP_PAYLOAD_TYPE_ORDER,
      destAddr: destinationAddressHex,
      tokenOut,
      amountOutMin,
      gasDrop,
      redeemFee,
      refundFee,
      deadline,
      referrerAddr: referrerHex,
      referrerBps: quote.referrerBps || 0
    },
    contractAddress
  };
}
function getEvmFastMctpCreateOrderTxPayload(quote, destinationAddress, referrerAddress, signerChainId) {
  const orderParams = getEvmFastMctpCreateOrderParams(
    quote,
    destinationAddress,
    referrerAddress,
    signerChainId
  );
  const {
    contractAddress,
    orderPayload,
    tokenIn,
    amountIn,
    circleMaxFee,
    destDomain,
    minFinalityThreshold
  } = orderParams;
  const fastMctpContract = new import_ethers7.Contract(contractAddress, MayanFastMctpArtifact_default.abi);
  const data = fastMctpContract.interface.encodeFunctionData(
    "createOrder",
    [tokenIn, amountIn, circleMaxFee, destDomain, minFinalityThreshold, orderPayload]
  );
  const value = (0, import_ethers7.toBeHex)(0);
  return {
    to: contractAddress,
    data,
    value,
    _params: orderParams
  };
}
async function getFastMctpFromEvmTxPayload(quote, destinationAddress, referrerAddress, signerChainId, permit, payload) {
  if (quote.type !== "FAST_MCTP") {
    throw new Error("Quote type is not FAST_MCTP");
  }
  if (!Number.isFinite(Number(signerChainId))) {
    throw new Error("Invalid signer chain id");
  }
  signerChainId = Number(signerChainId);
  const _permit = permit || ZeroPermit;
  const forwarder = new import_ethers7.Contract(addresses_default.MAYAN_FORWARDER_CONTRACT, MayanForwarderArtifact_default.abi);
  if (quote.fromToken.contract === quote.fastMctpInputContract) {
    if (quote.hasAuction) {
      if (!Number(quote.deadline64)) {
        throw new Error("Fast Mctp order requires timeout");
      }
      const fastMctpPayloadIx = getEvmFastMctpCreateOrderTxPayload(
        quote,
        destinationAddress,
        referrerAddress,
        signerChainId
      );
      const forwarderMethod = "forwardERC20";
      const forwarderParams = [
        quote.fromToken.contract,
        fastMctpPayloadIx._params.amountIn,
        _permit,
        fastMctpPayloadIx._params.contractAddress,
        fastMctpPayloadIx.data
      ];
      const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
      return {
        data,
        to: addresses_default.MAYAN_FORWARDER_CONTRACT,
        value: (0, import_ethers7.toBeHex)(0),
        chainId: signerChainId,
        _forwarder: {
          method: forwarderMethod,
          params: forwarderParams
        }
      };
    } else {
      const fastMctpPayloadIx = getEvmFastMctpBridgeTxPayload(
        quote,
        destinationAddress,
        referrerAddress,
        signerChainId,
        payload
      );
      const forwarderMethod = "forwardERC20";
      const forwarderParams = [
        quote.fromToken.contract,
        fastMctpPayloadIx._params.amountIn,
        _permit,
        fastMctpPayloadIx._params.contractAddress,
        fastMctpPayloadIx.data
      ];
      const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
      return {
        data,
        to: addresses_default.MAYAN_FORWARDER_CONTRACT,
        value: (0, import_ethers7.toBeHex)(0),
        chainId: signerChainId,
        _forwarder: {
          method: forwarderMethod,
          params: forwarderParams
        }
      };
    }
  } else {
    const { minMiddleAmount } = quote;
    if (!minMiddleAmount) {
      throw new Error("Fast Mctp swap requires middle amount, router address and calldata");
    }
    const { swapRouterCalldata, swapRouterAddress } = await getSwapEvm({
      forwarderAddress: addresses_default.MAYAN_FORWARDER_CONTRACT,
      fromToken: quote.fromToken.contract,
      middleToken: quote.fastMctpInputContract,
      slippageBps: quote.slippageBps,
      referrerAddress: referrerAddress || void 0,
      amountIn64: quote.effectiveAmountIn64,
      chainName: quote.fromChain
    });
    if (quote.hasAuction) {
      if (!Number(quote.deadline64)) {
        throw new Error("Fast Mctp order requires timeout");
      }
      const fastMctpPayloadIx = getEvmFastMctpCreateOrderTxPayload(
        quote,
        destinationAddress,
        referrerAddress,
        signerChainId
      );
      if (!quote.minMiddleAmount) {
        throw new Error("minMiddleAmount is required for Fast MCTP swap");
      }
      const minMiddleAmount2 = getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS);
      if (quote.fromToken.contract === import_ethers7.ZeroAddress) {
        const forwarderMethod = "swapAndForwardEth";
        const forwarderParams = [
          fastMctpPayloadIx._params.amountIn,
          swapRouterAddress,
          swapRouterCalldata,
          quote.fastMctpInputContract,
          minMiddleAmount2,
          fastMctpPayloadIx._params.contractAddress,
          fastMctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers7.toBeHex)(fastMctpPayloadIx._params.amountIn),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      } else {
        const forwarderMethod = "swapAndForwardERC20";
        const forwarderParams = [
          quote.fromToken.contract,
          fastMctpPayloadIx._params.amountIn,
          _permit,
          swapRouterAddress,
          swapRouterCalldata,
          quote.fastMctpInputContract,
          minMiddleAmount2,
          fastMctpPayloadIx._params.contractAddress,
          fastMctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers7.toBeHex)(0),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      }
    } else {
      const fastMctpPayloadIx = getEvmFastMctpBridgeTxPayload(
        quote,
        destinationAddress,
        referrerAddress,
        signerChainId,
        payload
      );
      if (!quote.minMiddleAmount) {
        throw new Error("minMiddleAmount is required for Fast MCTP swap");
      }
      const minMiddleAmount2 = getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS);
      if (quote.fromToken.contract === import_ethers7.ZeroAddress) {
        const forwarderMethod = "swapAndForwardEth";
        const forwarderParams = [
          fastMctpPayloadIx._params.amountIn,
          swapRouterAddress,
          swapRouterCalldata,
          quote.fastMctpInputContract,
          minMiddleAmount2,
          fastMctpPayloadIx._params.contractAddress,
          fastMctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers7.toBeHex)(fastMctpPayloadIx._params.amountIn),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      } else {
        const forwarderMethod = "swapAndForwardERC20";
        const forwarderParams = [
          quote.fromToken.contract,
          fastMctpPayloadIx._params.amountIn,
          _permit,
          swapRouterAddress,
          swapRouterCalldata,
          quote.fastMctpInputContract,
          minMiddleAmount2,
          fastMctpPayloadIx._params.contractAddress,
          fastMctpPayloadIx.data
        ];
        const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
        return {
          data,
          to: addresses_default.MAYAN_FORWARDER_CONTRACT,
          value: (0, import_ethers7.toBeHex)(0),
          chainId: signerChainId,
          _forwarder: {
            method: forwarderMethod,
            params: forwarderParams
          }
        };
      }
    }
  }
}

// src/evm/evmHyperCore.ts
var import_ethers8 = require("ethers");
var import_web314 = require("@solana/web3.js");

// src/evm/HCDepositInitiatorArtifact.ts
var HCDepositInitiatorArtifact_default = {
  abi: [
    {
      type: "constructor",
      inputs: [
        { name: "_hcProcessor", type: "address", internalType: "address" },
        {
          name: "_usdc",
          type: "address",
          internalType: "address"
        }
      ],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "changeGuardian",
      inputs: [
        { name: "newGuardian", type: "address", internalType: "address" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "claimGuardian",
      inputs: [],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "deposit",
      inputs: [
        { name: "tokenIn", type: "address", internalType: "address" },
        {
          name: "amountIn",
          type: "uint256",
          internalType: "uint256"
        },
        { name: "trader", type: "address", internalType: "address" },
        {
          name: "gasDrop",
          type: "uint64",
          internalType: "uint64"
        },
        { name: "bridgeAmount", type: "uint256", internalType: "uint256" },
        {
          name: "depositPayload",
          type: "tuple",
          internalType: "struct HCDepositInitiator.DepositPayload",
          components: [
            { name: "relayerFee", type: "uint64", internalType: "uint64" },
            {
              name: "permit",
              type: "tuple",
              internalType: "struct IHCBridge.DepositWithPermit",
              components: [
                { name: "user", type: "address", internalType: "address" },
                {
                  name: "usd",
                  type: "uint64",
                  internalType: "uint64"
                },
                { name: "deadline", type: "uint64", internalType: "uint64" },
                {
                  name: "signature",
                  type: "tuple",
                  internalType: "struct IHCBridge.Signature",
                  components: [
                    { name: "r", type: "uint256", internalType: "uint256" },
                    {
                      name: "s",
                      type: "uint256",
                      internalType: "uint256"
                    },
                    { name: "v", type: "uint8", internalType: "uint8" }
                  ]
                }
              ]
            }
          ]
        }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "fastDeposit",
      inputs: [
        { name: "tokenIn", type: "address", internalType: "address" },
        {
          name: "amountIn",
          type: "uint256",
          internalType: "uint256"
        },
        { name: "trader", type: "address", internalType: "address" },
        {
          name: "circleMaxFee",
          type: "uint256",
          internalType: "uint256"
        },
        { name: "gasDrop", type: "uint64", internalType: "uint64" },
        {
          name: "referrerAddress",
          type: "bytes32",
          internalType: "bytes32"
        },
        { name: "referrerBps", type: "uint8", internalType: "uint8" },
        {
          name: "minFinalityThreshold",
          type: "uint32",
          internalType: "uint32"
        },
        { name: "bridgeAmount", type: "uint256", internalType: "uint256" },
        {
          name: "depositPayload",
          type: "tuple",
          internalType: "struct HCDepositInitiator.DepositPayload",
          components: [
            { name: "relayerFee", type: "uint64", internalType: "uint64" },
            {
              name: "permit",
              type: "tuple",
              internalType: "struct IHCBridge.DepositWithPermit",
              components: [
                { name: "user", type: "address", internalType: "address" },
                {
                  name: "usd",
                  type: "uint64",
                  internalType: "uint64"
                },
                { name: "deadline", type: "uint64", internalType: "uint64" },
                {
                  name: "signature",
                  type: "tuple",
                  internalType: "struct IHCBridge.Signature",
                  components: [
                    { name: "r", type: "uint256", internalType: "uint256" },
                    {
                      name: "s",
                      type: "uint256",
                      internalType: "uint256"
                    },
                    { name: "v", type: "uint8", internalType: "uint8" }
                  ]
                }
              ]
            }
          ]
        }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "fastMCTP",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "guardian",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "mayanCircle",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "nextGuardian",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "setFastMCTP",
      inputs: [{ name: "_fastMCTP", type: "address", internalType: "address" }],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "setMayanCircle",
      inputs: [
        { name: "_mayanCircle", type: "address", internalType: "address" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    { type: "error", name: "AlreadySet", inputs: [] },
    {
      type: "error",
      name: "InsufficientAmount",
      inputs: []
    },
    { type: "error", name: "Unauthorized", inputs: [] }
  ]
};

// src/evm/evmHyperCore.ts
var import_buffer14 = require("buffer");
function getUsdcDepositInitiatorMctpTxPayload(quote, swapperAddress, destinationAddress, usdcPermitSignature) {
  if (!quote.hyperCoreParams) {
    throw new Error("HyperCore parameters are missing");
  }
  if (!quote.hyperCoreParams.initiateContractAddress) {
    throw new Error("HyperCore initiate contract address is missing");
  }
  if (quote.type !== "MCTP") {
    throw new Error("Unsupported quote type for HyperCore deposit: " + quote.type);
  }
  const initiatorContract = new import_ethers8.Contract(
    quote.hyperCoreParams.initiateContractAddress,
    HCDepositInitiatorArtifact_default.abi
  );
  const signatureBuf = import_buffer14.Buffer.from(hexToUint8Array(usdcPermitSignature));
  if (signatureBuf.length !== 65) {
    throw new Error("Invalid USDC permit signature length");
  }
  const r = "0x" + signatureBuf.subarray(0, 32).toString("hex");
  const s = "0x" + signatureBuf.subarray(32, 64).toString("hex");
  const v = signatureBuf[64];
  let data;
  let value;
  data = initiatorContract.interface.encodeFunctionData("deposit", [
    quote.hyperCoreParams.initiateTokenContract,
    BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
    swapperAddress,
    getAmountOfFractionalAmount(
      quote.hyperCoreParams.failureGasDrop,
      Math.min(getGasDecimal("arbitrum"), 8)
    ),
    BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
    {
      relayerFee: getAmountOfFractionalAmount(quote.redeemRelayerFee, CCTP_TOKEN_DECIMALS),
      permit: {
        user: destinationAddress,
        usd: BigInt(quote.hyperCoreParams.depositAmountUSDC64),
        deadline: BigInt(quote.deadline64),
        signature: {
          r,
          s,
          v
        }
      }
    }
  ]);
  value = (0, import_ethers8.toBeHex)(0);
  return {
    to: quote.hyperCoreParams.initiateContractAddress,
    data,
    value,
    _params: {
      amountIn: BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
      contractAddress: quote.hyperCoreParams.initiateContractAddress
    }
  };
}
function getUsdcDepositInitiatorFastMctpTxPayload(quote, swapperAddress, destinationAddress, referrerAddress, usdcPermitSignature) {
  const destChainId = getWormholeChainIdByName("arbitrum");
  if (!quote.hyperCoreParams) {
    throw new Error("HyperCore parameters are missing");
  }
  if (!quote.hyperCoreParams.initiateContractAddress) {
    throw new Error("HyperCore initiate contract address is missing");
  }
  if (quote.type !== "FAST_MCTP") {
    throw new Error("Unsupported quote type for HyperCore deposit: " + quote.type);
  }
  const initiatorContract = new import_ethers8.Contract(
    quote.hyperCoreParams.initiateContractAddress,
    HCDepositInitiatorArtifact_default.abi
  );
  const signatureBuf = import_buffer14.Buffer.from(hexToUint8Array(usdcPermitSignature));
  if (signatureBuf.length !== 65) {
    throw new Error("Invalid USDC permit signature length");
  }
  const r = "0x" + signatureBuf.subarray(0, 32).toString("hex");
  const s = "0x" + signatureBuf.subarray(32, 64).toString("hex");
  const v = signatureBuf[64];
  let referrerHex;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(
      referrerAddress,
      destChainId
    );
  } else {
    referrerHex = nativeAddressToHexString(
      import_web314.SystemProgram.programId.toString(),
      getWormholeChainIdByName("solana")
    );
  }
  let data;
  let value;
  data = initiatorContract.interface.encodeFunctionData("fastDeposit", [
    quote.hyperCoreParams.initiateTokenContract,
    BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
    swapperAddress,
    BigInt(quote.circleMaxFee64),
    getAmountOfFractionalAmount(
      quote.hyperCoreParams.failureGasDrop,
      Math.min(getGasDecimal("arbitrum"), 8)
    ),
    referrerHex,
    quote.referrerBps,
    Number(quote.fastMctpMinFinality),
    BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
    {
      relayerFee: getAmountOfFractionalAmount(quote.redeemRelayerFee, CCTP_TOKEN_DECIMALS),
      permit: {
        user: destinationAddress,
        usd: BigInt(quote.hyperCoreParams.depositAmountUSDC64),
        deadline: BigInt(quote.deadline64),
        signature: {
          r,
          s,
          v
        }
      }
    }
  ]);
  value = (0, import_ethers8.toBeHex)(0);
  return {
    to: quote.hyperCoreParams.initiateContractAddress,
    data,
    value,
    _params: {
      amountIn: BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
      contractAddress: quote.hyperCoreParams.initiateContractAddress
    }
  };
}
async function getHyperCoreDepositFromEvmTxPayload(quote, swapperAddress, destinationAddress, referrerAddress, signerChainId, permit, payload, options = {}) {
  if (quote.toToken.contract.toLowerCase() !== addresses_default.ARBITRUM_USDC_CONTRACT.toLowerCase() || quote.type !== "MCTP" && quote.type !== "FAST_MCTP") {
    throw new Error("Unsupported quote type for USDC deposit: " + quote.type);
  }
  if (!options?.usdcPermitSignature) {
    throw new Error("USDC permit signature is required for this quote");
  }
  if (!quote.hyperCoreParams) {
    throw new Error("HyperCore parameters are required for this quote");
  }
  if (payload) {
    throw new Error("HyperCore deposit does not support payload");
  }
  if (!Number.isFinite(Number(signerChainId))) {
    throw new Error("Invalid signer chain id");
  }
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  if (sourceChainId !== signerWormholeChainId) {
    throw new Error(`Signer chain id(${Number(signerChainId)}) and quote from chain are not same! ${sourceChainId} !== ${signerWormholeChainId}`);
  }
  const _permit = permit || ZeroPermit;
  const forwarder = new import_ethers8.Contract(addresses_default.MAYAN_FORWARDER_CONTRACT, MayanForwarderArtifact_default.abi);
  let initiatorPayloadIx;
  if (!Number(quote.deadline64)) {
    throw new Error("HyperCore deposit requires timeout");
  }
  if (quote.type === "MCTP") {
    initiatorPayloadIx = getUsdcDepositInitiatorMctpTxPayload(
      quote,
      swapperAddress,
      destinationAddress,
      options.usdcPermitSignature
    );
  } else if (quote.type === "FAST_MCTP") {
    initiatorPayloadIx = getUsdcDepositInitiatorFastMctpTxPayload(
      quote,
      swapperAddress,
      destinationAddress,
      referrerAddress,
      options.usdcPermitSignature
    );
  } else {
    throw new Error("Unsupported quote type for HyperCore deposit: " + quote.type);
  }
  if (quote.fromToken.contract.toLowerCase() === quote.hyperCoreParams.initiateTokenContract.toLowerCase()) {
    const forwarderMethod = "forwardERC20";
    const forwarderParams = [
      quote.fromToken.contract,
      BigInt(quote.effectiveAmountIn64),
      _permit,
      initiatorPayloadIx._params.contractAddress,
      initiatorPayloadIx.data
    ];
    const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
    return {
      data,
      to: addresses_default.MAYAN_FORWARDER_CONTRACT,
      value: (0, import_ethers8.toBeHex)(0),
      chainId: signerChainId,
      _forwarder: {
        method: forwarderMethod,
        params: forwarderParams
      }
    };
  } else {
    const { swapRouterCalldata, swapRouterAddress } = await getSwapEvm({
      fromToken: quote.fromToken.contract,
      middleToken: quote.hyperCoreParams.initiateTokenContract,
      chainName: quote.fromChain,
      amountIn64: quote.effectiveAmountIn64,
      referrerAddress,
      slippageBps: quote.slippageBps,
      forwarderAddress: addresses_default.MAYAN_FORWARDER_CONTRACT
    });
    if (!quote.minMiddleAmount) {
      throw new Error("Fast Mctp swap requires middle amount, router address and calldata");
    }
    const minMiddleAmount = getAmountOfFractionalAmount(quote.minMiddleAmount, CCTP_TOKEN_DECIMALS);
    if (quote.fromToken.contract === import_ethers8.ZeroAddress) {
      const forwarderMethod = "swapAndForwardEth";
      const forwarderParams = [
        BigInt(quote.effectiveAmountIn64),
        swapRouterAddress,
        swapRouterCalldata,
        quote.hyperCoreParams.initiateTokenContract,
        minMiddleAmount,
        initiatorPayloadIx._params.contractAddress,
        initiatorPayloadIx.data
      ];
      const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
      return {
        data,
        to: addresses_default.MAYAN_FORWARDER_CONTRACT,
        value: (0, import_ethers8.toBeHex)(BigInt(quote.effectiveAmountIn64)),
        chainId: signerChainId,
        _forwarder: {
          method: forwarderMethod,
          params: forwarderParams
        }
      };
    } else {
      const forwarderMethod = "swapAndForwardERC20";
      const forwarderParams = [
        quote.fromToken.contract,
        BigInt(quote.effectiveAmountIn64),
        _permit,
        swapRouterAddress,
        swapRouterCalldata,
        quote.hyperCoreParams.initiateTokenContract,
        minMiddleAmount,
        initiatorPayloadIx._params.contractAddress,
        initiatorPayloadIx.data
      ];
      const data = forwarder.interface.encodeFunctionData(forwarderMethod, forwarderParams);
      return {
        data,
        to: addresses_default.MAYAN_FORWARDER_CONTRACT,
        value: (0, import_ethers8.toBeHex)(0),
        chainId: signerChainId,
        _forwarder: {
          method: forwarderMethod,
          params: forwarderParams
        }
      };
    }
  }
}

// src/evm/evmMonoChain.ts
var import_ethers9 = require("ethers");

// src/evm/MayanMonoChainArtifact.ts
var MayanMonoChainArtifact_default = {
  abi: [
    {
      type: "constructor",
      inputs: [
        { name: "_forwarderAddress", type: "address", internalType: "address" }
      ],
      stateMutability: "nonpayable"
    },
    { type: "receive", stateMutability: "payable" },
    {
      type: "function",
      name: "ForwarderAddress",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "MAX_REFERRER_BPS",
      inputs: [],
      outputs: [{ name: "", type: "uint8", internalType: "uint8" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "changeGuardian",
      inputs: [
        { name: "newGuardian", type: "address", internalType: "address" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "claimGuardian",
      inputs: [],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "guardian",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "nextGuardian",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "rescueETH",
      inputs: [
        { name: "to", type: "address", internalType: "address" },
        {
          name: "amount",
          type: "uint256",
          internalType: "uint256"
        }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "rescueToken",
      inputs: [
        { name: "token", type: "address", internalType: "address" },
        {
          name: "to",
          type: "address",
          internalType: "address"
        },
        { name: "amount", type: "uint256", internalType: "uint256" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "transferEth",
      inputs: [
        { name: "to", type: "address", internalType: "address" },
        {
          name: "referrerAddr",
          type: "address",
          internalType: "address"
        },
        { name: "referrerBps", type: "uint8", internalType: "uint8" }
      ],
      outputs: [],
      stateMutability: "payable"
    },
    {
      type: "function",
      name: "transferToken",
      inputs: [
        { name: "token", type: "address", internalType: "address" },
        {
          name: "amount",
          type: "uint256",
          internalType: "uint256"
        },
        { name: "to", type: "address", internalType: "address" },
        {
          name: "referrerAddr",
          type: "address",
          internalType: "address"
        },
        { name: "referrerBps", type: "uint8", internalType: "uint8" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "event",
      name: "EthTransferred",
      inputs: [
        {
          name: "to",
          type: "address",
          indexed: false,
          internalType: "address"
        },
        {
          name: "amount",
          type: "uint256",
          indexed: false,
          internalType: "uint256"
        }
      ],
      anonymous: false
    },
    {
      type: "event",
      name: "TokenTransferred",
      inputs: [
        {
          name: "token",
          type: "address",
          indexed: false,
          internalType: "address"
        },
        {
          name: "to",
          type: "address",
          indexed: false,
          internalType: "address"
        },
        {
          name: "amount",
          type: "uint256",
          indexed: false,
          internalType: "uint256"
        }
      ],
      anonymous: false
    },
    { type: "error", name: "InvalidReferrerBps", inputs: [] },
    {
      type: "error",
      name: "Unauthorized",
      inputs: []
    }
  ]
};

// src/evm/evmMonoChain.ts
function getEvmMonoChainTxPayload(quote, destinationAddress, referrerAddress) {
  const amountOut = getAmountOfFractionalAmount(
    quote.expectedAmountOut,
    quote.toToken.decimals
  );
  const monoChainContract = new import_ethers9.Contract(
    quote.monoChainMayanContract,
    MayanMonoChainArtifact_default.abi
  );
  const referrerBps = referrerAddress ? quote.referrerBps || 0 : 0;
  let data;
  let value;
  if (quote.toToken.contract === import_ethers9.ZeroAddress) {
    data = monoChainContract.interface.encodeFunctionData("transferEth", [
      destinationAddress,
      referrerAddress || import_ethers9.ZeroAddress,
      referrerBps
    ]);
  } else {
    data = monoChainContract.interface.encodeFunctionData("transferToken", [
      quote.toToken.contract,
      amountOut,
      destinationAddress,
      referrerAddress || import_ethers9.ZeroAddress,
      referrerBps
    ]);
  }
  if (quote.fromToken.contract === import_ethers9.ZeroAddress) {
    value = (0, import_ethers9.toBeHex)(quote.effectiveAmountIn64);
  } else {
    value = (0, import_ethers9.toBeHex)(0);
  }
  return {
    to: quote.monoChainMayanContract,
    data,
    value,
    _params: {
      amountIn: BigInt(quote.effectiveAmountIn64),
      tokenIn: quote.fromToken.contract
    }
  };
}
function getMonoChainFromEvmTxPayload(quote, destinationAddress, referrerAddress, signerChainId, permit) {
  if (quote.type !== "MONO_CHAIN") {
    throw new Error("Quote type is not MONO_CHAIN");
  }
  if (quote.fromChain !== quote.toChain) {
    throw new Error("Quote chains are not equal");
  }
  if (quote.fromToken.contract.toLowerCase() === quote.toToken.contract.toLowerCase()) {
    throw new Error(
      `From token and to token are the same: ${quote.fromToken.contract}`
    );
  }
  if (!Number.isFinite(Number(signerChainId))) {
    throw new Error("Invalid signer chain id");
  }
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const sourceChainId = getWormholeChainIdByName(quote.fromChain);
  if (sourceChainId !== signerWormholeChainId) {
    throw new Error(
      `Signer chain id(${Number(
        signerChainId
      )}) and quote from chain are not same! ${sourceChainId} !== ${signerWormholeChainId}`
    );
  }
  signerChainId = Number(signerChainId);
  const _permit = permit || ZeroPermit;
  const forwarder = new import_ethers9.Contract(
    addresses_default.MAYAN_FORWARDER_CONTRACT,
    MayanForwarderArtifact_default.abi
  );
  const { evmSwapRouterAddress, evmSwapRouterCalldata } = quote;
  if (!evmSwapRouterAddress || !evmSwapRouterCalldata) {
    throw new Error(
      "Mono chain swap requires router address and calldata"
    );
  }
  const monoChainPayloadIx = getEvmMonoChainTxPayload(
    quote,
    destinationAddress,
    referrerAddress
  );
  const minMiddleAmount = getAmountOfFractionalAmount(
    quote.minAmountOut,
    quote.toToken.decimals
  );
  if (quote.fromToken.contract === import_ethers9.ZeroAddress) {
    const forwarderMethod = "swapAndForwardEth";
    const forwarderParams = [
      monoChainPayloadIx._params.amountIn,
      evmSwapRouterAddress,
      evmSwapRouterCalldata,
      quote.toToken.contract,
      minMiddleAmount,
      quote.monoChainMayanContract,
      monoChainPayloadIx.data
    ];
    const data = forwarder.interface.encodeFunctionData(
      forwarderMethod,
      forwarderParams
    );
    return {
      data,
      to: addresses_default.MAYAN_FORWARDER_CONTRACT,
      value: (0, import_ethers9.toBeHex)(monoChainPayloadIx._params.amountIn),
      chainId: signerChainId,
      _forwarder: {
        method: forwarderMethod,
        params: forwarderParams
      }
    };
  } else {
    const forwarderMethod = "swapAndForwardERC20";
    const forwarderParams = [
      quote.fromToken.contract,
      monoChainPayloadIx._params.amountIn,
      _permit,
      evmSwapRouterAddress,
      evmSwapRouterCalldata,
      quote.toToken.contract,
      minMiddleAmount,
      quote.monoChainMayanContract,
      monoChainPayloadIx.data
    ];
    const data = forwarder.interface.encodeFunctionData(
      forwarderMethod,
      forwarderParams
    );
    return {
      data,
      to: addresses_default.MAYAN_FORWARDER_CONTRACT,
      value: (0, import_ethers9.toBeHex)(0),
      chainId: signerChainId,
      _forwarder: {
        method: forwarderMethod,
        params: forwarderParams
      }
    };
  }
}

// src/evm/evmSwap.ts
function getEvmSwapParams(quote, destinationAddress, referrerAddress, signerAddress, signerChainId, payload) {
  const mayanProgram = new import_web315.PublicKey(addresses_default.MAYAN_PROGRAM_ID);
  const [mayanMainAccount] = import_web315.PublicKey.findProgramAddressSync(
    [import_buffer15.Buffer.from("MAIN")],
    mayanProgram
  );
  const recipient = getAssociatedTokenAddress(
    new import_web315.PublicKey(quote.fromToken.mint),
    mayanMainAccount,
    true
  );
  const amountIn = BigInt(quote.effectiveAmountIn64);
  const recipientHex = nativeAddressToHexString(recipient.toString(), 1);
  const auctionHex = nativeAddressToHexString(addresses_default.AUCTION_PROGRAM_ID, 1);
  let referrerHex;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(referrerAddress, 1);
  } else {
    referrerHex = nativeAddressToHexString(
      import_web315.SystemProgram.programId.toString(),
      1
    );
  }
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const fromChainId = getWormholeChainIdByName(quote.fromChain);
  const destinationChainId = getWormholeChainIdByName(quote.toChain);
  if (fromChainId !== signerWormholeChainId) {
    throw new Error(
      `Signer chain id(${Number(
        signerChainId
      )}) and quote from chain are not same! ${fromChainId} !== ${signerWormholeChainId}`
    );
  }
  const contractAddress = quote.whMayanContract;
  const recipientStruct = {
    mayanAddr: recipientHex,
    mayanChainId: 1,
    destAddr: nativeAddressToHexString(destinationAddress, destinationChainId),
    destChainId: destinationChainId,
    auctionAddr: auctionHex,
    referrer: referrerHex,
    refundAddr: nativeAddressToHexString(signerAddress, signerWormholeChainId)
  };
  const unwrapRedeem = quote.toToken.contract === import_ethers10.ZeroAddress;
  const criteria = {
    transferDeadline: BigInt(quote.deadline64),
    swapDeadline: BigInt(quote.deadline64),
    amountOutMin: getAmountOfFractionalAmount(
      quote.minAmountOut,
      Math.min(8, quote.toToken.decimals)
    ),
    gasDrop: getAmountOfFractionalAmount(
      quote.gasDrop,
      Math.min(8, getGasDecimal(quote.toChain))
    ),
    unwrap: unwrapRedeem,
    customPayload: payload ? `0x${import_buffer15.Buffer.from(payload).toString("hex")}` : "0x"
  };
  const contractRelayerFees = {
    swapFee: getAmountOfFractionalAmount(
      quote.swapRelayerFee,
      Math.min(8, quote.fromToken.decimals)
    ),
    redeemFee: getAmountOfFractionalAmount(
      quote.redeemRelayerFee,
      Math.min(8, quote.toToken.decimals)
    ),
    refundFee: getAmountOfFractionalAmount(
      quote.refundRelayerFee,
      Math.min(8, quote.fromToken.decimals)
    )
  };
  if (!quote.toToken.realOriginContractAddress || !quote.toToken.realOriginChainId) {
    throw new Error("Missing toToken real origin contract address");
  }
  const tokenOut = nativeAddressToHexString(
    quote.toToken.realOriginContractAddress,
    quote.toToken.realOriginChainId
  );
  const bridgeFee = getAmountOfFractionalAmount(quote.bridgeFee, 18);
  return {
    amountIn,
    tokenIn: quote.fromToken.contract,
    tokenOut,
    tokenOutWChainId: quote.toToken.realOriginChainId,
    criteria,
    recipient: recipientStruct,
    relayerFees: contractRelayerFees,
    contractAddress,
    bridgeFee
  };
}
async function getSwapFromEvmTxPayload(quote, swapperAddress, destinationAddress, referrerAddresses, signerAddress, signerChainId, payload, permit, options) {
  const signerWormholeChainId = getWormholeChainIdById(Number(signerChainId));
  const fromChainId = getWormholeChainIdByName(quote.fromChain);
  if (fromChainId !== signerWormholeChainId) {
    throw new Error(
      `Signer chain id(${Number(
        signerChainId
      )}) and quote from chain are not same! ${fromChainId} !== ${signerWormholeChainId}`
    );
  }
  const referrerAddress = getQuoteSuitableReferrerAddress(
    quote,
    referrerAddresses
  );
  if (quote.toChain === "hypercore") {
    return getHyperCoreDepositFromEvmTxPayload(
      quote,
      swapperAddress,
      destinationAddress,
      referrerAddress,
      signerChainId,
      permit,
      payload,
      options
    );
  }
  if (quote.type === "MCTP") {
    return getMctpFromEvmTxPayload(
      quote,
      destinationAddress,
      referrerAddress,
      signerChainId,
      permit,
      payload
    );
  }
  if (quote.type === "SWIFT") {
    return getSwiftFromEvmTxPayload(
      quote,
      swapperAddress,
      destinationAddress,
      referrerAddress,
      signerChainId,
      permit,
      payload
    );
  }
  if (quote.type === "SHUTTLE") {
    throw new Error("SHUTTLE quote type is not supported on EVM");
  }
  if (quote.type === "FAST_MCTP") {
    return getFastMctpFromEvmTxPayload(
      quote,
      destinationAddress,
      referrerAddress,
      signerChainId,
      permit,
      payload
    );
  }
  if (quote.type === "MONO_CHAIN") {
    return getMonoChainFromEvmTxPayload(
      quote,
      destinationAddress,
      referrerAddress,
      signerChainId,
      permit
    );
  }
  if (quote.type != "WH") {
    throw new Error("Unsupported quote type");
  }
  if (!Number(quote.deadline64)) {
    throw new Error("WH mode requires a timeout");
  }
  const {
    relayerFees,
    recipient,
    tokenOut,
    tokenOutWChainId,
    criteria,
    tokenIn,
    amountIn,
    contractAddress,
    bridgeFee
  } = getEvmSwapParams(
    quote,
    destinationAddress,
    referrerAddress,
    signerAddress,
    signerChainId,
    payload
  );
  const forwarderContract = new import_ethers10.Contract(
    addresses_default.MAYAN_FORWARDER_CONTRACT,
    MayanForwarderArtifact_default.abi
  );
  const mayanSwap = new import_ethers10.Contract(contractAddress, MayanSwapArtifact_default.abi);
  let forwarderMethod;
  let forwarderParams;
  let value;
  const _permit = permit || ZeroPermit;
  if (tokenIn === import_ethers10.ZeroAddress) {
    const mayanCallData = mayanSwap.interface.encodeFunctionData(
      "wrapAndSwapETH",
      [relayerFees, recipient, tokenOut, tokenOutWChainId, criteria]
    );
    forwarderMethod = "forwardEth";
    forwarderParams = [contractAddress, mayanCallData];
    value = (0, import_ethers10.toBeHex)(amountIn);
  } else {
    const mayanCallData = mayanSwap.interface.encodeFunctionData("swap", [
      relayerFees,
      recipient,
      tokenOut,
      tokenOutWChainId,
      criteria,
      tokenIn,
      amountIn
    ]);
    forwarderMethod = "forwardERC20";
    forwarderParams = [
      tokenIn,
      amountIn,
      _permit,
      contractAddress,
      mayanCallData
    ];
    value = (0, import_ethers10.toBeHex)(bridgeFee);
  }
  const data = forwarderContract.interface.encodeFunctionData(
    forwarderMethod,
    forwarderParams
  );
  return {
    to: addresses_default.MAYAN_FORWARDER_CONTRACT,
    data,
    value,
    chainId: signerChainId,
    _forwarder: {
      method: forwarderMethod,
      params: forwarderParams
    }
  };
}
async function swapFromEvm(quote, swapperAddress, destinationAddress, referrerAddresses, signer, permit, overrides, payload, options) {
  if (!signer.provider) {
    throw new Error("No provider found for signer");
  }
  const signerAddress = await signer.getAddress();
  if (signerAddress.toLowerCase() !== swapperAddress.toLowerCase()) {
    throw new Error("Signer address does not match swapper address");
  }
  const signerChainId = Number((await signer.provider.getNetwork()).chainId);
  if (quote.type === "SWIFT" && quote.gasless && quote.toChain !== "hypercore") {
    const referrerAddress = getQuoteSuitableReferrerAddress(
      quote,
      referrerAddresses
    );
    const gasLessParams = getSwiftFromEvmGasLessParams(
      quote,
      swapperAddress,
      destinationAddress,
      referrerAddress,
      signerChainId,
      permit,
      payload
    );
    const signedOrderHash = await signer.signTypedData(
      gasLessParams.orderTypedData.domain,
      gasLessParams.orderTypedData.types,
      gasLessParams.orderTypedData.value
    );
    await submitSwiftEvmSwap(gasLessParams, signedOrderHash);
    return gasLessParams.orderHash;
  }
  const transactionRequest = await getSwapFromEvmTxPayload(
    quote,
    swapperAddress,
    destinationAddress,
    referrerAddresses,
    signerAddress,
    signerChainId,
    payload,
    permit,
    options
  );
  delete transactionRequest._forwarder;
  if (overrides?.gasPrice) {
    transactionRequest.gasPrice = overrides.gasPrice;
  }
  if (overrides?.maxFeePerGas) {
    transactionRequest.maxFeePerGas = overrides.maxFeePerGas;
  }
  if (overrides?.maxPriorityFeePerGas) {
    transactionRequest.maxPriorityFeePerGas = overrides.maxPriorityFeePerGas;
  }
  if (overrides?.gasLimit) {
    transactionRequest.gasLimit = overrides.gasLimit;
  } else {
    const estimatedGas = await signer.estimateGas(transactionRequest);
    transactionRequest.gasLimit = String(
      BigInt(String(estimatedGas)) * BigInt(110) / BigInt(100)
    );
  }
  transactionRequest.chainId = getEvmChainIdByName(quote.fromChain);
  return signer.sendTransaction(transactionRequest);
}
async function estimateQuoteRequiredGas(quote, swapperAddress, signer, permit, payload) {
  const signerAddress = await signer.getAddress();
  const sampleDestinationAddress = quote.toChain === "solana" ? "ENsytooJVSZyNHbxvueUeX8Am8gcNqPivVVE8USCBiy5" : "0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a";
  const signerChainId = Number((await signer.provider.getNetwork()).chainId);
  if (quote.type === "SWIFT" && quote.gasless) {
    return BigInt(0);
  }
  const transactionRequest = await getSwapFromEvmTxPayload(
    quote,
    swapperAddress,
    sampleDestinationAddress,
    null,
    signerAddress,
    signerChainId,
    payload,
    permit
  );
  delete transactionRequest._forwarder;
  let baseGas = await signer.estimateGas(transactionRequest);
  baseGas = BigInt(String(baseGas));
  if (quote.type === "MCTP" || quote.type === "SWIFT") {
    return baseGas * BigInt(110) / BigInt(100);
  }
  return baseGas;
}
async function estimateQuoteRequiredGasAprox(quote, provider, permit, payload) {
  const signerAddress = "0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a";
  const sampleDestinationAddress = quote.toChain === "solana" ? "ENsytooJVSZyNHbxvueUeX8Am8gcNqPivVVE8USCBiy5" : "0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a";
  const signerChainId = quote?.fromToken?.chainId;
  if (quote.type === "SWIFT" && quote.gasless) {
    return BigInt(0);
  }
  const transactionRequest = await getSwapFromEvmTxPayload(
    quote,
    signerAddress,
    sampleDestinationAddress,
    null,
    signerAddress,
    signerChainId,
    payload,
    permit
  );
  delete transactionRequest._forwarder;
  return provider.estimateGas(transactionRequest);
}
async function estimateQuoteRequiredGasAprox2(quote, payload) {
  const signerAddress = "0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a";
  const sampleDestinationAddress = quote.toChain === "solana" ? "ENsytooJVSZyNHbxvueUeX8Am8gcNqPivVVE8USCBiy5" : quote.toChain === "sui" ? "0xcde6dbe01902be1f200ff03dbbd149e586847be8cee15235f82750d9b06c0e04" : "0x1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a";
  const signerChainId = getEvmChainIdByName(quote.fromChain);
  if (quote.type === "SWIFT" && quote.gasless) {
    return {
      estimateGas: BigInt(0),
      gasPrice: BigInt(0),
      requiredNative: BigInt(0)
    };
  }
  const transactionRequest = await getSwapFromEvmTxPayload(
    quote,
    signerAddress,
    sampleDestinationAddress,
    null,
    signerAddress,
    signerChainId,
    payload,
    void 0
  );
  const { gasPrice, estimatedGas } = await getEstimateGasEvm({
    from: signerAddress,
    chainId: signerChainId,
    tokenIn: quote.fromToken.contract,
    value: "0x" + BigInt(String(transactionRequest.value)).toString(16),
    data: transactionRequest.data,
    to: transactionRequest.to
  });
  return {
    estimateGas: estimatedGas * BigInt(110) / BigInt(100),
    gasPrice,
    requiredNative: gasPrice * estimatedGas
  };
}

// src/sui/utils.ts
async function assertArgumentIsImmutable(params, suiClient) {
  let argTypes;
  try {
    argTypes = await suiClient.getMoveFunctionArgTypes({
      package: params.package,
      module: params.module,
      function: params.function
    });
  } catch (error) {
    throw new Error(
      `Failed to fetch ${params.package}::${params.module}::${params.function} ArgTypes`
    );
  }
  if (argTypes) {
    if (argTypes[params.argumentIndex] !== "Pure" && //@ts-ignore
    argTypes[params.argumentIndex]?.Object !== "ByImmutableReference") {
      throw new Error(
        `Argument ${params.argumentIndex} of ${params.module}::${params.function} is not immutable`
      );
    }
  } else {
    throw new Error(
      `Failed to fetch package::${params.module}::${params.function} ArgTypes`
    );
  }
}
async function fetchAllCoins(inputs, suiClient) {
  let allCoinData = [];
  let currentSum = BigInt(0);
  let cursor = void 0;
  do {
    const paginatedCoins = await suiClient.getCoins({
      ...inputs,
      owner: inputs.walletAddress,
      cursor
    });
    const coinData = paginatedCoins.data.filter(
      (data) => BigInt(data.balance) > BigInt(0)
    );
    allCoinData = [...allCoinData, ...coinData];
    coinData.forEach((coin) => {
      currentSum += BigInt(coin.balance);
    });
    if (paginatedCoins.data.length === 0 || !paginatedCoins.hasNextPage || !paginatedCoins.nextCursor || currentSum >= inputs.coinAmount)
      return {
        coins: allCoinData.sort(
          (b, a) => Number(BigInt(b.coinObjectId) - BigInt(a.coinObjectId))
        ),
        sum: currentSum
      };
    cursor = paginatedCoins.nextCursor;
  } while (true);
}
async function fetchMayanSuiPackageId(stateObjectId, suiClient) {
  let object;
  try {
    object = await suiClient.getObject({
      id: stateObjectId,
      options: {
        showContent: true
      }
    });
  } catch (err) {
    throw new Error(`Failed to fetch Mayan Sui package ID: 

 ${err}`);
  }
  if (object.data?.content?.fields?.latest_package_id) {
    return object.data.content.fields.latest_package_id;
  }
  throw new Error("latest_package_id not found in Mayan Sui state object");
}
async function resolveInputCoin(amount, owner, coinType, suiClient, tx, preparedCoin) {
  let inputCoin;
  if (preparedCoin?.result) {
    inputCoin = preparedCoin.result;
  } else if (preparedCoin?.objectId) {
    inputCoin = tx.object(preparedCoin.objectId);
  } else {
    const { coins, sum } = await fetchAllCoins(
      {
        walletAddress: owner,
        coinType,
        coinAmount: amount
      },
      suiClient
    );
    if (sum < amount) {
      throw new Error(
        `Insufficient funds to create Coin ${coinType} with amount ${amount}`
      );
    }
    if (coins.length > 1) {
      tx.mergeCoins(
        coins[0].coinObjectId,
        coins.slice(1).map((c) => c.coinObjectId)
      );
    }
    const [spitedCoin] = tx.splitCoins(coins[0].coinObjectId, [amount]);
    inputCoin = spitedCoin;
  }
  return inputCoin;
}

// src/sui/suiMctp.ts
var import_transactions = require("@mysten/sui/transactions");
var import_utils21 = require("@mysten/sui/utils");
var import_web316 = require("@solana/web3.js");
var import_ethers11 = require("ethers");
async function createMctpFromSuiMoveCalls(quote, swapperAddress, destinationAddress, referrerAddress, payload, suiClient, options) {
  if (!quote.fromToken.verifiedAddress) {
    throw new Error("from token verified address is not provided");
  }
  const [mctpPackageId, feeManagerPackageId] = await Promise.all([
    fetchMayanSuiPackageId(addresses_default.SUI_MCTP_STATE, suiClient),
    quote.hasAuction ? fetchMayanSuiPackageId(addresses_default.SUI_MCTP_FEE_MANAGER_STATE, suiClient) : null
  ]);
  let tx;
  let inputCoin;
  let whFeeCoin = null;
  if (quote.fromToken.contract === quote.mctpInputContract) {
    tx = options?.builtTransaction ?? new import_transactions.Transaction();
    inputCoin = await resolveInputCoin(
      BigInt(quote.effectiveAmountIn64),
      swapperAddress,
      quote.mctpInputContract,
      suiClient,
      tx,
      options?.inputCoin
    );
  } else {
    const {
      tx: serializedTx,
      outCoin,
      whFeeCoin: suiSplitViaSwap
    } = await getSwapSui({
      amountIn64: quote.effectiveAmountIn64,
      inputCoinType: quote.fromToken.contract,
      middleCoinType: quote.mctpInputContract,
      userWallet: swapperAddress,
      withWhFee: quote.hasAuction || quote.cheaperChain !== "sui",
      referrerAddress,
      inputCoin: options?.inputCoin,
      transaction: options?.builtTransaction ? await options.builtTransaction.toJSON() : void 0,
      slippageBps: quote.slippageBps,
      chainName: quote.fromChain
    });
    tx = import_transactions.Transaction.from(serializedTx);
    inputCoin = outCoin;
    whFeeCoin = suiSplitViaSwap ? { result: suiSplitViaSwap } : null;
  }
  if (quote.hasAuction) {
    if (!feeManagerPackageId) {
      throw new Error("Fee manager package ID is not found for swap quote");
    }
    await addInitOrderMoveCalls(
      quote,
      swapperAddress,
      destinationAddress,
      referrerAddress,
      mctpPackageId,
      feeManagerPackageId,
      suiClient,
      {
        inputCoin: { result: inputCoin },
        whFeeCoin,
        builtTransaction: tx
      }
    );
  } else {
    if (quote.cheaperChain === "sui") {
      await addBridgeLockedFeeMoveCalls(
        quote,
        swapperAddress,
        destinationAddress,
        mctpPackageId,
        suiClient,
        {
          inputCoin: { result: inputCoin },
          whFeeCoin,
          builtTransaction: tx
        }
      );
    } else {
      await addBridgeWithFeeMoveCalls(
        quote,
        swapperAddress,
        destinationAddress,
        mctpPackageId,
        payload,
        suiClient,
        {
          inputCoin: { result: inputCoin },
          whFeeCoin,
          builtTransaction: tx
        }
      );
    }
  }
  const amountIn = BigInt(quote.effectiveAmountIn64);
  const _payload = payload ? Uint8Array.from(payload) : Uint8Array.from([]);
  tx.moveCall({
    package: mctpPackageId,
    module: "init_order",
    function: "log_initialize_mctp",
    typeArguments: [quote.fromToken.contract],
    arguments: [
      tx.pure.u64(amountIn),
      tx.object(quote.fromToken.verifiedAddress),
      tx.pure.vector("u8", _payload)
    ]
  });
  try {
    let referrerHex;
    if (referrerAddress) {
      referrerHex = nativeAddressToHexString(referrerAddress, getWormholeChainIdByName(quote.toChain));
    } else {
      referrerHex = nativeAddressToHexString(
        import_web316.SystemProgram.programId.toString(),
        getWormholeChainIdByName("solana")
      );
    }
    tx.moveCall({
      package: addresses_default.SUI_LOGGER_PACKAGE_ID,
      module: "referrer_logger",
      function: "log_referrer",
      arguments: [
        tx.pure.address(referrerHex),
        tx.pure.u8(quote.referrerBps || 0)
      ]
    });
  } catch (err) {
    console.error("Failed to log referrer", err);
  }
  return tx;
}
async function addBridgeWithFeeMoveCalls(quote, swapperAddress, destinationAddress, mctpPackageId, payload, suiClient, options) {
  return addBridgeWithFeeMoveCalls2({
    swapperAddress,
    destinationAddress,
    toChain: quote.toChain,
    effectiveAmountIn64: quote.effectiveAmountIn64,
    minMiddleAmount: quote.minMiddleAmount,
    mctpPackageId,
    fromToken: quote.fromToken,
    mctpInputContract: quote.mctpInputContract,
    gasDrop: quote.gasDrop,
    redeemRelayerFee: quote.redeemRelayerFee,
    mctpVerifiedInputAddress: quote.mctpVerifiedInputAddress,
    mctpInputTreasury: quote.mctpInputTreasury,
    bridgeFee: quote.bridgeFee,
    payload,
    suiClient,
    options
  });
}
async function addBridgeLockedFeeMoveCalls(quote, swapperAddress, destinationAddress, mctpPackageId, suiClient, options) {
  const destChainId = getWormholeChainIdByName(quote.toChain);
  const tx = options?.builtTransaction ?? new import_transactions.Transaction();
  let amountInMin;
  if (quote.fromToken.contract === quote.mctpInputContract) {
    amountInMin = BigInt(quote.effectiveAmountIn64);
  } else {
    if (!quote.minMiddleAmount) {
      throw new Error("minMiddleAmount is required for bridge locked fee when fromToken is different than mctpInputContract");
    }
    amountInMin = getAmountOfFractionalAmount(
      quote.minMiddleAmount,
      CCTP_TOKEN_DECIMALS
    );
  }
  const inputCoin = await resolveInputCoin(
    BigInt(quote.effectiveAmountIn64),
    swapperAddress,
    quote.mctpInputContract,
    suiClient,
    tx,
    options?.inputCoin
  );
  const addrDest = nativeAddressToHexString(destinationAddress, destChainId);
  const domainDest = getCCTPDomain(quote.toChain);
  const gasDrop = getAmountOfFractionalAmount(
    quote.gasDrop,
    Math.min(getGasDecimal(quote.toChain), 8)
  );
  const redeemFee = getAmountOfFractionalAmount(
    quote.redeemRelayerFee,
    CCTP_TOKEN_DECIMALS
  );
  const [bridgeLockedFeeTicket] = tx.moveCall({
    package: mctpPackageId,
    module: "bridge_locked_fee",
    function: "prepare_bridge_locked_fee",
    typeArguments: [quote.mctpInputContract],
    arguments: [
      inputCoin,
      tx.pure.u64(amountInMin),
      tx.pure.address(addrDest),
      tx.pure.u32(domainDest),
      tx.pure.u64(gasDrop),
      tx.pure.u64(redeemFee)
    ]
  });
  const [burnRequest, depositTicket] = tx.moveCall({
    package: mctpPackageId,
    module: "bridge_locked_fee",
    function: "bridge_locked_fee",
    typeArguments: [quote.mctpInputContract],
    arguments: [
      tx.object(addresses_default.SUI_MCTP_STATE),
      tx.object(addresses_default.SUI_CCTP_CORE_STATE),
      tx.object(quote.mctpVerifiedInputAddress),
      bridgeLockedFeeTicket
    ]
  });
  const [_burnMessage, cctpMessage] = tx.moveCall({
    package: addresses_default.SUI_CCTP_TOKEN_PACKAGE_ID,
    module: "deposit_for_burn",
    function: "deposit_for_burn_with_caller_with_package_auth",
    typeArguments: [
      quote.mctpInputContract,
      `${mctpPackageId}::bridge_locked_fee::CircleAuth`
    ],
    arguments: [
      depositTicket,
      tx.object(addresses_default.SUI_CCTP_TOKEN_STATE),
      tx.object(addresses_default.SUI_CCTP_CORE_STATE),
      tx.object("0x403"),
      tx.object(quote.mctpInputTreasury)
    ]
  });
  tx.moveCall({
    package: mctpPackageId,
    module: "bridge_locked_fee",
    function: "store_bridge_locked_fee",
    typeArguments: [quote.mctpInputContract],
    arguments: [
      tx.object(addresses_default.SUI_MCTP_STATE),
      tx.object(quote.mctpVerifiedInputAddress),
      burnRequest,
      cctpMessage
    ]
  });
  return tx;
}
async function addInitOrderMoveCalls(quote, swapperAddress, destinationAddress, referrerAddress, mctpPackageId, feeManagerPackageId, suiClient, options) {
  const destChainId = getWormholeChainIdByName(quote.toChain);
  const tx = options?.builtTransaction ?? new import_transactions.Transaction();
  let amountInMin;
  if (quote.fromToken.contract === quote.mctpInputContract) {
    amountInMin = BigInt(quote.effectiveAmountIn64);
  } else {
    if (!quote.minMiddleAmount) {
      throw new Error("minMiddleAmount is required for init order when fromToken is different than mctpInputContract");
    }
    amountInMin = getAmountOfFractionalAmount(
      quote.minMiddleAmount,
      CCTP_TOKEN_DECIMALS
    );
  }
  const [inputCoin] = await Promise.all([
    resolveInputCoin(
      BigInt(quote.effectiveAmountIn64),
      swapperAddress,
      quote.mctpInputContract,
      suiClient,
      tx,
      options?.inputCoin
    ),
    assertArgumentIsImmutable(
      {
        package: feeManagerPackageId,
        module: "calculate_mctp_fee",
        function: "prepare_calc_mctp_fee",
        argumentIndex: 3
      },
      suiClient
    )
  ]);
  const tokenOut = quote.toToken.contract === import_ethers11.ZeroAddress ? nativeAddressToHexString(import_web316.SystemProgram.programId.toString(), getWormholeChainIdByName("solana")) : nativeAddressToHexString(quote.toToken.contract, quote.toToken.wChainId);
  const amountOutMin = getAmountOfFractionalAmount(
    quote.minAmountOut,
    Math.min(8, quote.toToken.decimals)
  );
  const addrDest = nativeAddressToHexString(destinationAddress, destChainId);
  const domainDest = getCCTPDomain(quote.toChain);
  const gasDrop = getAmountOfFractionalAmount(
    quote.gasDrop,
    Math.min(getGasDecimal(quote.toChain), 8)
  );
  const redeemFee = getAmountOfFractionalAmount(
    quote.redeemRelayerFee,
    CCTP_TOKEN_DECIMALS
  );
  const deadline = BigInt(quote.deadline64);
  let referrerHex;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(referrerAddress, destChainId);
  } else {
    referrerHex = nativeAddressToHexString(
      import_web316.SystemProgram.programId.toString(),
      getWormholeChainIdByName("solana")
    );
  }
  const commonArguments = [
    tx.object(quote.mctpVerifiedInputAddress),
    tx.pure.u8(MCTP_INIT_ORDER_PAYLOAD_ID),
    tx.pure.address(swapperAddress),
    inputCoin,
    tx.pure.address(addrDest),
    tx.pure.u16(destChainId),
    tx.pure.address(tokenOut),
    tx.pure.u64(amountOutMin),
    tx.pure.u64(gasDrop),
    tx.pure.u64(redeemFee),
    tx.pure.u64(deadline),
    tx.pure.address(referrerHex),
    tx.pure.u8(quote.referrerBps || 0)
  ];
  const [feeManagerInitOrderParamsTicket] = tx.moveCall({
    package: feeManagerPackageId,
    module: "calculate_mctp_fee",
    function: "prepare_calc_mctp_fee",
    typeArguments: [quote.mctpInputContract],
    arguments: commonArguments
  });
  const [feeManagerInitOrderParams] = tx.moveCall({
    package: feeManagerPackageId,
    module: "calculate_mctp_fee",
    function: "calculate_mctp_fee",
    arguments: [
      tx.object(addresses_default.SUI_MCTP_FEE_MANAGER_STATE),
      feeManagerInitOrderParamsTicket
    ]
  });
  const [initOrderTicket] = tx.moveCall({
    package: mctpPackageId,
    module: "init_order",
    function: "prepare_initialize_order",
    typeArguments: [quote.mctpInputContract],
    arguments: [
      ...commonArguments.slice(1),
      tx.pure.u32(domainDest),
      tx.pure.u64(amountInMin)
    ]
  });
  const [burnRequest, depositTicket] = tx.moveCall({
    package: mctpPackageId,
    module: "init_order",
    function: "initialize_order",
    typeArguments: [quote.mctpInputContract],
    arguments: [
      tx.object(addresses_default.SUI_MCTP_STATE),
      tx.object(addresses_default.SUI_CCTP_CORE_STATE),
      tx.object(quote.mctpVerifiedInputAddress),
      initOrderTicket,
      feeManagerInitOrderParams
    ]
  });
  const [_burnMessage, cctpMessage] = tx.moveCall({
    package: addresses_default.SUI_CCTP_TOKEN_PACKAGE_ID,
    module: "deposit_for_burn",
    function: "deposit_for_burn_with_caller_with_package_auth",
    typeArguments: [
      quote.mctpInputContract,
      `${mctpPackageId}::init_order::CircleAuth`
    ],
    arguments: [
      depositTicket,
      tx.object(addresses_default.SUI_CCTP_TOKEN_STATE),
      tx.object(addresses_default.SUI_CCTP_CORE_STATE),
      tx.object("0x403"),
      tx.object(quote.mctpInputTreasury)
    ]
  });
  const [wormholeMessage] = tx.moveCall({
    package: mctpPackageId,
    module: "init_order",
    function: "publish_init_order",
    arguments: [tx.object(addresses_default.SUI_MCTP_STATE), burnRequest, cctpMessage]
  });
  await addPublishWormholeMessage(
    tx,
    wormholeMessage,
    suiClient,
    BigInt(quote.bridgeFee),
    swapperAddress,
    options?.whFeeCoin
  );
  return tx;
}
async function addPublishWormholeMessage(tx, messageTicket, suiClient, bridgeFee, feePayer, suiCoin) {
  let gasCoin;
  if (suiCoin?.result) {
    gasCoin = suiCoin.result;
  } else if (suiCoin?.objectId) {
    gasCoin = tx.object(suiCoin.objectId);
  } else {
    if (bridgeFee > BigInt(0)) {
      const { coins, sum } = await fetchAllCoins(
        {
          walletAddress: feePayer,
          coinType: import_utils21.SUI_TYPE_ARG,
          coinAmount: bridgeFee
        },
        suiClient
      );
      if (sum < bridgeFee) {
        throw new Error(`Insufficient funds to pay Wormhole message fee`);
      }
      if (coins.length > 1) {
        tx.mergeCoins(
          coins[0].coinObjectId,
          coins.slice(1).map((c) => c.coinObjectId)
        );
      }
      const [spitedCoin] = tx.splitCoins(coins[0].coinObjectId, [bridgeFee]);
      gasCoin = spitedCoin;
    } else {
      const [zeroSui] = tx.splitCoins(tx.gas, [tx.pure.u64(0)]);
      gasCoin = zeroSui;
    }
  }
  tx.moveCall({
    package: addresses_default.SUI_WORMHOLE_PACKAGE_ID,
    module: "publish_message",
    function: "publish_message",
    arguments: [
      tx.object(addresses_default.SUI_WORMHOLE_STATE),
      gasCoin,
      messageTicket,
      tx.object(import_utils21.SUI_CLOCK_OBJECT_ID)
    ]
  });
  return tx;
}
async function addBridgeWithFeeMoveCalls2(params) {
  const {
    swapperAddress,
    destinationAddress,
    mctpPackageId,
    payload,
    suiClient,
    options
  } = params;
  const destChainId = getWormholeChainIdByName(params.toChain);
  const tx = options?.builtTransaction ?? new import_transactions.Transaction();
  let amountInMin;
  if (params.fromToken.contract === params.mctpInputContract) {
    amountInMin = BigInt(params.effectiveAmountIn64);
  } else {
    if (!params.minMiddleAmount) {
      throw new Error("minMiddleAmount is required for bridge with fee when fromToken is different than mctpInputContract");
    }
    amountInMin = getAmountOfFractionalAmount(
      params.minMiddleAmount,
      CCTP_TOKEN_DECIMALS
    );
  }
  const inputCoin = await resolveInputCoin(
    BigInt(params.effectiveAmountIn64),
    swapperAddress,
    params.mctpInputContract,
    suiClient,
    tx,
    options?.inputCoin
  );
  const payloadType = payload ? MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD : MCTP_PAYLOAD_TYPE_DEFAULT;
  const addrDest = nativeAddressToHexString(destinationAddress, destChainId);
  const domainDest = getCCTPDomain(params.toChain);
  const gasDrop = getAmountOfFractionalAmount(
    params.gasDrop,
    Math.min(getGasDecimal(params.toChain), 8)
  );
  const redeemFee = getAmountOfFractionalAmount(
    params.redeemRelayerFee,
    CCTP_TOKEN_DECIMALS
  );
  const _payload = payload ? Uint8Array.from(payload) : Uint8Array.from([]);
  const [bridgeWithFeeTicket] = tx.moveCall({
    package: mctpPackageId,
    module: "bridge_with_fee",
    function: "prepare_bridge_with_fee",
    typeArguments: [params.mctpInputContract],
    arguments: [
      tx.pure.u8(payloadType),
      inputCoin,
      tx.pure.u64(amountInMin),
      tx.pure.address(addrDest),
      tx.pure.u32(domainDest),
      tx.pure.u64(gasDrop),
      tx.pure.u64(redeemFee),
      tx.pure.vector("u8", _payload)
    ]
  });
  const [burnRequest, depositTicket] = tx.moveCall({
    package: mctpPackageId,
    module: "bridge_with_fee",
    function: "bridge_with_fee",
    typeArguments: [params.mctpInputContract],
    arguments: [
      tx.object(addresses_default.SUI_MCTP_STATE),
      tx.object(addresses_default.SUI_CCTP_CORE_STATE),
      tx.object(params.mctpVerifiedInputAddress),
      bridgeWithFeeTicket
    ]
  });
  const [_burnMessage, cctpMessage] = tx.moveCall({
    package: addresses_default.SUI_CCTP_TOKEN_PACKAGE_ID,
    module: "deposit_for_burn",
    function: "deposit_for_burn_with_caller_with_package_auth",
    typeArguments: [
      params.mctpInputContract,
      `${mctpPackageId}::bridge_with_fee::CircleAuth`
    ],
    arguments: [
      depositTicket,
      tx.object(addresses_default.SUI_CCTP_TOKEN_STATE),
      tx.object(addresses_default.SUI_CCTP_CORE_STATE),
      tx.object("0x403"),
      tx.object(params.mctpInputTreasury)
    ]
  });
  const [wormholeMessage] = tx.moveCall({
    package: mctpPackageId,
    module: "bridge_with_fee",
    function: "publish_bridge_with_fee",
    arguments: [tx.object(addresses_default.SUI_MCTP_STATE), burnRequest, cctpMessage]
  });
  await addPublishWormholeMessage(
    tx,
    wormholeMessage,
    suiClient,
    BigInt(params.bridgeFee),
    swapperAddress,
    options?.whFeeCoin
  );
  return tx;
}

// src/sui/suiHyperCore.ts
var import_transactions2 = require("@mysten/sui/transactions");
var import_web317 = require("@solana/web3.js");
async function createHyperCoreDepositFromSuiMoveCalls(quote, swapperAddress, destinationAddress, referrerAddress, suiClient, options) {
  if (quote.toToken.contract.toLowerCase() !== addresses_default.ARBITRUM_USDC_CONTRACT.toLowerCase() || quote.type !== "MCTP") {
    throw new Error("Unsupported quote type for USDC deposit: " + quote.type);
  }
  if (!quote.hyperCoreParams) {
    throw new Error("HyperCore parameters are required for this quote");
  }
  if (!options?.usdcPermitSignature) {
    throw new Error("USDC permit signature is required for this quote");
  }
  if (!Number(quote.deadline64)) {
    throw new Error("HyperCore deposit requires timeout");
  }
  const [mctpPackageId] = await Promise.all([
    fetchMayanSuiPackageId(addresses_default.SUI_MCTP_STATE, suiClient)
  ]);
  let tx;
  let inputCoin;
  let whFeeCoin = null;
  if (quote.fromToken.contract === quote.hyperCoreParams.initiateTokenContract) {
    tx = options?.builtTransaction ?? new import_transactions2.Transaction();
    inputCoin = await resolveInputCoin(
      BigInt(quote.hyperCoreParams.bridgeAmountUSDC64),
      swapperAddress,
      quote.mctpInputContract,
      suiClient,
      tx,
      options?.inputCoin
    );
  } else {
    const {
      tx: serializedTx,
      outCoin,
      whFeeCoin: suiSplitViaSwap
    } = await getSwapSui({
      amountIn64: quote.effectiveAmountIn64,
      inputCoinType: quote.fromToken.contract,
      middleCoinType: quote.hyperCoreParams.initiateTokenContract,
      userWallet: swapperAddress,
      withWhFee: true,
      referrerAddress,
      inputCoin: options?.inputCoin,
      transaction: options?.builtTransaction ? await options.builtTransaction.toJSON() : void 0,
      chainName: "sui",
      slippageBps: quote.slippageBps
    });
    tx = import_transactions2.Transaction.from(serializedTx);
    const [initiateCoin] = tx.splitCoins(
      outCoin,
      [BigInt(quote.hyperCoreParams.bridgeAmountUSDC64)]
    );
    tx.transferObjects(
      [outCoin],
      tx.pure.address(swapperAddress)
    );
    inputCoin = initiateCoin;
    whFeeCoin = suiSplitViaSwap ? { result: suiSplitViaSwap } : null;
  }
  const payload = getHyperCoreUSDCDepositCustomPayload(quote, destinationAddress, options.usdcPermitSignature);
  await addBridgeWithFeeMoveCalls2({
    swapperAddress,
    destinationAddress: addresses_default.HC_ARBITRUM_DEPOSIT_PROCESSOR,
    mctpPackageId,
    toChain: "arbitrum",
    effectiveAmountIn64: quote.effectiveAmountIn64,
    minMiddleAmount: getDisplayAmount(quote.hyperCoreParams.bridgeAmountUSDC64, CCTP_TOKEN_DECIMALS),
    bridgeFee: quote.bridgeFee,
    gasDrop: quote.hyperCoreParams.failureGasDrop,
    fromToken: quote.fromToken,
    mctpInputContract: quote.mctpInputContract,
    mctpInputTreasury: quote.mctpInputTreasury,
    mctpVerifiedInputAddress: quote.mctpVerifiedInputAddress,
    redeemRelayerFee: 0,
    payload,
    suiClient,
    options: {
      inputCoin: { result: inputCoin },
      whFeeCoin,
      builtTransaction: tx
    }
  });
  const amountIn = BigInt(quote.effectiveAmountIn64);
  const _payload = Uint8Array.from(payload);
  if (!quote.fromToken.verifiedAddress) {
    throw new Error("From token verified address is required from Sui");
  }
  tx.moveCall({
    package: mctpPackageId,
    module: "init_order",
    function: "log_initialize_mctp",
    typeArguments: [quote.fromToken.contract],
    arguments: [
      tx.pure.u64(amountIn),
      tx.object(quote.fromToken.verifiedAddress),
      tx.pure.vector("u8", _payload)
    ]
  });
  try {
    let referrerHex;
    if (referrerAddress) {
      referrerHex = nativeAddressToHexString(referrerAddress, getWormholeChainIdByName("arbitrum"));
    } else {
      referrerHex = nativeAddressToHexString(
        import_web317.SystemProgram.programId.toString(),
        getWormholeChainIdByName("solana")
      );
    }
    tx.moveCall({
      package: addresses_default.SUI_LOGGER_PACKAGE_ID,
      module: "referrer_logger",
      function: "log_referrer",
      arguments: [
        tx.pure.address(referrerHex),
        tx.pure.u8(quote.referrerBps || 0)
      ]
    });
  } catch (err) {
    console.error("Failed to log referrer", err);
  }
  return tx;
}

// src/sui/suiSwift.ts
var import_transactions3 = require("@mysten/sui/transactions");
var import_buffer16 = require("buffer");
var import_web318 = require("@solana/web3.js");
var import_ethers12 = require("ethers");
async function createSwiftFromSuiMoveCalls(quote, swapperAddress, destinationAddress, referrerAddress, payload, suiClient, options) {
  if (!quote.fromToken.verifiedAddress || !quote.swiftVerifiedInputAddress) {
    throw new Error("from token or swift input verified address is not provided");
  }
  const [swiftPackageId, feeManagerPackageId] = await Promise.all([
    fetchMayanSuiPackageId(addresses_default.SUI_SWIFT_STATE, suiClient),
    fetchMayanSuiPackageId(addresses_default.SUI_SWIFT_FEE_MANAGER_STATE, suiClient)
  ]);
  let tx;
  let inputCoin;
  if (quote.fromToken.contract === quote.swiftInputContract) {
    tx = options?.builtTransaction ?? new import_transactions3.Transaction();
    inputCoin = await resolveInputCoin(
      BigInt(quote.effectiveAmountIn64),
      swapperAddress,
      quote.swiftInputContract,
      suiClient,
      tx,
      options?.inputCoin
    );
  } else {
    const {
      tx: serializedTx,
      outCoin
    } = await getSwapSui({
      amountIn64: quote.effectiveAmountIn64,
      inputCoinType: quote.fromToken.contract,
      middleCoinType: quote.swiftInputContract,
      userWallet: swapperAddress,
      withWhFee: false,
      referrerAddress,
      inputCoin: options?.inputCoin,
      transaction: options?.builtTransaction ? await options.builtTransaction.toJSON() : void 0,
      slippageBps: quote.slippageBps,
      chainName: quote.fromChain
    });
    tx = import_transactions3.Transaction.from(serializedTx);
    inputCoin = outCoin;
  }
  await addInitSwiftOrderMoveCalls(
    quote,
    swapperAddress,
    destinationAddress,
    referrerAddress,
    swiftPackageId,
    feeManagerPackageId,
    payload,
    suiClient,
    {
      inputCoin: { result: inputCoin },
      builtTransaction: tx,
      randomKey: options?.randomKey
    }
  );
  const amountIn = BigInt(quote.effectiveAmountIn64);
  const _payload = payload ? Uint8Array.from(payload) : Uint8Array.from([]);
  tx.moveCall({
    package: swiftPackageId,
    module: "init_order",
    function: "log_initialize_order",
    typeArguments: [quote.fromToken.contract],
    arguments: [
      tx.pure.u64(amountIn),
      tx.object(quote.fromToken.verifiedAddress),
      tx.pure.vector("u8", _payload)
    ]
  });
  return tx;
}
async function addInitSwiftOrderMoveCalls(quote, swapperAddress, destinationAddress, referrerAddress, swiftPackageId, feeManagerPackageId, payload, suiClient, options) {
  const destChainId = getWormholeChainIdByName(quote.toChain);
  const tx = options?.builtTransaction ?? new import_transactions3.Transaction();
  const amountInMin = quote.fromToken.contract === quote.swiftInputContract ? BigInt(quote.effectiveAmountIn64) : getAmountOfFractionalAmount(
    quote.minMiddleAmount,
    quote.swiftInputDecimals
  );
  const [inputCoin] = await Promise.all([
    resolveInputCoin(
      BigInt(quote.effectiveAmountIn64),
      swapperAddress,
      quote.swiftInputContract,
      suiClient,
      tx,
      options?.inputCoin
    ),
    assertArgumentIsImmutable(
      {
        package: feeManagerPackageId,
        module: "calculate_swift_fee",
        function: "prepare_calc_swift_fee",
        argumentIndex: 3
      },
      suiClient
    )
  ]);
  const tokenOut = quote.toToken.contract === import_ethers12.ZeroAddress ? nativeAddressToHexString(import_web318.SystemProgram.programId.toString(), getWormholeChainIdByName("solana")) : nativeAddressToHexString(quote.toToken.contract, quote.toToken.wChainId);
  const amountOutMin = getAmountOfFractionalAmount(
    quote.minAmountOut,
    Math.min(8, quote.toToken.decimals)
  );
  const addrDest = nativeAddressToHexString(destinationAddress, destChainId);
  const gasDrop = getAmountOfFractionalAmount(
    quote.gasDrop,
    Math.min(getGasDecimal(quote.toChain), 8)
  );
  const cancelFee = BigInt(quote.cancelRelayerFee64);
  const refundFee = BigInt(quote.refundRelayerFee64);
  const deadline = BigInt(quote.deadline64);
  let referrerHex;
  if (referrerAddress) {
    referrerHex = nativeAddressToHexString(referrerAddress, getWormholeChainIdByName("sui"));
  } else {
    referrerHex = nativeAddressToHexString(
      import_web318.SystemProgram.programId.toString(),
      getWormholeChainIdByName("solana")
    );
  }
  const payloadType = payload ? SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD : SWIFT_PAYLOAD_TYPE_DEFAULT;
  let customPayloadHash;
  if (payload) {
    customPayloadHash = import_buffer16.Buffer.from(hexToUint8Array(import_ethers12.ethers.keccak256(import_buffer16.Buffer.from(payload))));
  } else {
    customPayloadHash = import_web318.SystemProgram.programId.toBuffer();
  }
  const commonArguments = [
    tx.pure.u8(payloadType),
    tx.pure.address(swapperAddress),
    tx.object(quote.swiftVerifiedInputAddress),
    inputCoin,
    tx.pure.address(addrDest),
    tx.pure.u16(destChainId),
    tx.pure.address(tokenOut),
    tx.pure.u64(amountOutMin),
    tx.pure.u64(gasDrop),
    tx.pure.u64(cancelFee),
    tx.pure.u64(refundFee),
    tx.pure.u64(deadline),
    tx.pure.address(referrerHex),
    tx.pure.u8(quote.referrerBps),
    tx.pure.u8(quote.swiftAuctionMode)
  ];
  const [feeManagerInitOrderParamsTicket] = tx.moveCall({
    package: feeManagerPackageId,
    module: "calculate_swift_fee",
    function: "prepare_calc_swift_fee",
    typeArguments: [quote.swiftInputContract],
    arguments: commonArguments
  });
  const [feeManagerInitOrderParams] = tx.moveCall({
    package: feeManagerPackageId,
    module: "calculate_swift_fee",
    function: "calculate_swift_fee",
    arguments: [
      tx.object(addresses_default.SUI_SWIFT_FEE_MANAGER_STATE),
      feeManagerInitOrderParamsTicket
    ]
  });
  const randomKey = options?.randomKey ? import_buffer16.Buffer.from(options.randomKey) : import_web318.Keypair.generate().publicKey.toBuffer();
  const [initOrderTicket] = tx.moveCall({
    package: swiftPackageId,
    module: "init_order",
    function: "prepare_initialize_order",
    typeArguments: [quote.swiftInputContract],
    arguments: [
      commonArguments[0],
      //payloadType
      commonArguments[1],
      //swapperAddress
      commonArguments[3],
      //inputCoin
      tx.pure.u64(amountInMin),
      ...commonArguments.slice(4),
      tx.pure.address("0x" + randomKey.toString("hex")),
      tx.pure.address("0x" + customPayloadHash.toString("hex"))
    ]
  });
  const [burnRequest, depositTicket] = tx.moveCall({
    package: swiftPackageId,
    module: "init_order",
    function: "initialize_order",
    typeArguments: [quote.swiftInputContract],
    arguments: [
      tx.object(addresses_default.SUI_SWIFT_STATE),
      tx.object(quote.swiftVerifiedInputAddress),
      initOrderTicket,
      feeManagerInitOrderParams
    ]
  });
  return tx;
}

// src/sui/suiSwap.ts
async function createSwapFromSuiMoveCalls(quote, swapperWalletAddress, destinationAddress, referrerAddresses, payload, suiClient, options) {
  const referrerAddress = getQuoteSuitableReferrerAddress(
    quote,
    referrerAddresses
  );
  if (quote.toChain === "hypercore") {
    if (!quote.hyperCoreParams) {
      throw new Error("HyperCore parameters are required for this quote");
    }
    if (!options?.usdcPermitSignature) {
      throw new Error("USDC permit signature is required for this quote");
    }
    if (quote.type !== "MCTP") {
      throw new Error("Unsupported quote type for HyperCore deposit: " + quote.type);
    }
    if (payload) {
      throw new Error("Payload is not supported for HyperCore deposit quotes");
    }
    return createHyperCoreDepositFromSuiMoveCalls(
      quote,
      swapperWalletAddress,
      destinationAddress,
      referrerAddress,
      suiClient,
      options
    );
  }
  if (quote.type === "MCTP") {
    return createMctpFromSuiMoveCalls(
      quote,
      swapperWalletAddress,
      destinationAddress,
      referrerAddress,
      payload,
      suiClient,
      options
    );
  } else if (quote.type === "SWIFT") {
    throw new Error("SWIFT swaps are not supported to Sui chain yet");
    return createSwiftFromSuiMoveCalls(
      quote,
      swapperWalletAddress,
      destinationAddress,
      referrerAddress,
      payload,
      suiClient,
      options
    );
  } else {
    throw new Error("Unsupported quote type from Sui chain");
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FAST_MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD,
  FAST_MCTP_PAYLOAD_TYPE_DEFAULT,
  FAST_MCTP_PAYLOAD_TYPE_ORDER,
  MCTP_INIT_ORDER_PAYLOAD_ID,
  MCTP_PAYLOAD_TYPE_CUSTOM_PAYLOAD,
  MCTP_PAYLOAD_TYPE_DEFAULT,
  PermitTypes,
  SWIFT_PAYLOAD_TYPE_CUSTOM_PAYLOAD,
  SWIFT_PAYLOAD_TYPE_DEFAULT,
  ZeroPermit,
  addBridgeLockedFeeMoveCalls,
  addBridgeWithFeeMoveCalls,
  addBridgeWithFeeMoveCalls2,
  addInitOrderMoveCalls,
  addresses,
  assertArgumentIsImmutable,
  broadcastJitoBundleId,
  checkHyperCoreDeposit,
  checkSdkVersionSupport,
  confirmJitoBundleId,
  createApproveInstruction,
  createAssociatedTokenAccountInstruction,
  createCloseAccountInstruction,
  createHyperCoreDepositFromSolanaInstructions,
  createHyperCoreDepositFromSuiMoveCalls,
  createInitializeRandomTokenAccountInstructions,
  createMctpBridgeLedgerInstruction,
  createMctpBridgeWithFeeInstruction,
  createMctpFromSolanaInstructions,
  createMctpFromSuiMoveCalls,
  createMonoChainFromSolanaInstructions,
  createPayloadWriterCloseInstruction,
  createPayloadWriterCreateInstruction,
  createSplTransferInstruction,
  createSwapFromSolanaInstructions,
  createSwapFromSuiMoveCalls,
  createSwiftFromSolanaInstructions,
  createSwiftOrderHash,
  createSwiftRandomKey,
  createSyncNativeInstruction,
  createTransferAllAndCloseInstruction,
  decentralizeClientSwapInstructions,
  decideRelayer,
  deserializeInstructionInfo,
  estimateQuoteRequiredGas,
  estimateQuoteRequiredGasAprox,
  estimateQuoteRequiredGasAprox2,
  fetchAllCoins,
  fetchAllTokenList,
  fetchMayanSuiPackageId,
  fetchQuote,
  fetchTokenList,
  generateFetchQuoteUrl,
  getAddressLookupTableAccounts,
  getAmountOfFractionalAmount,
  getAnchorInstructionData,
  getAssociatedTokenAddress,
  getCurrentChainTime,
  getDisplayAmount,
  getEstimateGasEvm,
  getEvmChainIdByName,
  getEvmSwiftParams,
  getFastMctpFromEvmTxPayload,
  getGasDecimal,
  getGasDecimalsInSolana,
  getHyperCoreDepositFromEvmTxPayload,
  getHyperCoreUSDCDepositCustomPayload,
  getHyperCoreUSDCDepositPermitParams,
  getJitoTipTransfer,
  getLookupTableAddress,
  getMctpFromEvmTxPayload,
  getMonoChainFromEvmTxPayload,
  getNormalizeFactor,
  getPermitDomain,
  getPermitParams,
  getQuoteSuitableReferrerAddress,
  getSafeU64Blob,
  getSdkVersion,
  getSuggestedRelayer,
  getSvmDurableNonce,
  getSwapEvm,
  getSwapFromEvmTxPayload,
  getSwapSolana,
  getSwapSui,
  getSwiftFromEvmGasLessParams,
  getSwiftFromEvmTxPayload,
  getSwiftOrderTypeData,
  getSwiftToTokenHexString,
  getWormholeChainIdById,
  getWormholeChainIdByName,
  hexToUint8Array,
  isValidAptosType,
  nativeAddressToHexString,
  resolveInputCoin,
  sandwichInstructionInCpiProxy,
  sendJitoBundle,
  solMint,
  submitSwiftEvmSwap,
  submitSwiftSolanaSwap,
  submitTransactionWithRetry,
  swapFromEvm,
  swapFromSolana,
  unwrapSol,
  validateJupSwap,
  validateJupSwapInstructionData,
  wait,
  wrapSol
});
